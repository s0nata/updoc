Class;Method1;Method2;Type;Param1;Param2;Cloned text;Legit?
com.google.common.escape.CharEscaper;String escape(String string);String escapeSlow(String s, int index);@return;;;the escaped form of string;false
com.google.common.escape.CharEscaper;String escape(String string);String escapeSlow(String s, int index);@param;String string;String s;the literal string to be escaped;false
com.google.common.escape.CharEscaper;String escape(String string);String escapeSlow(String s, int index);@throws;;;if string is null;true
com.google.common.escape.ArrayBasedUnicodeEscaper; ArrayBasedUnicodeEscaper(Map replacementMap, int safeMin, int safeMax, String unsafeReplacement); ArrayBasedUnicodeEscaper(ArrayBasedEscaperMap escaperMap, int safeMin, int safeMax, String unsafeReplacement);@param;int safeMin;int safeMin;the lowest character value in the safe range;true
com.google.common.escape.ArrayBasedUnicodeEscaper; ArrayBasedUnicodeEscaper(Map replacementMap, int safeMin, int safeMax, String unsafeReplacement); ArrayBasedUnicodeEscaper(ArrayBasedEscaperMap escaperMap, int safeMin, int safeMax, String unsafeReplacement);@param;int safeMax;int safeMax;the highest character value in the safe range;true
com.google.common.escape.ArrayBasedUnicodeEscaper; ArrayBasedUnicodeEscaper(Map replacementMap, int safeMin, int safeMax, String unsafeReplacement); ArrayBasedUnicodeEscaper(ArrayBasedEscaperMap escaperMap, int safeMin, int safeMax, String unsafeReplacement);@param;String unsafeReplacement;String unsafeReplacement;the default replacement for unsafe characters or null if no default replacement is required;true
com.google.common.escape.Escapers;String computeReplacement(CharEscaper escaper, char c);String computeReplacement(UnicodeEscaper escaper, int cp);@return;;;the replacement string, or null if no escaping was needed;true
com.google.common.escape.UnicodeEscaper;String escape(String string);String escapeSlow(String s, int index);@return;;;the escaped form of string;false
com.google.common.escape.UnicodeEscaper;String escape(String string);String escapeSlow(String s, int index);@param;String string;String s;the literal string to be escaped;false
com.google.common.escape.UnicodeEscaper;String escape(String string);String escapeSlow(String s, int index);@throws;;;if string is null;true
com.google.common.escape.UnicodeEscaper;String escape(String string);String escapeSlow(String s, int index);@throws;;;if invalid surrogate characters are encountered;true
com.google.common.escape.ArrayBasedCharEscaper; ArrayBasedCharEscaper(Map replacementMap, char safeMin, char safeMax); ArrayBasedCharEscaper(ArrayBasedEscaperMap escaperMap, char safeMin, char safeMax);@param;char safeMin;char safeMin;the lowest character value in the safe range;true
com.google.common.escape.ArrayBasedCharEscaper; ArrayBasedCharEscaper(Map replacementMap, char safeMin, char safeMax); ArrayBasedCharEscaper(ArrayBasedEscaperMap escaperMap, char safeMin, char safeMax);@param;char safeMax;char safeMax;the highest character value in the safe range;true
com.google.common.collect.DiscreteDomain;C next(C value);C previous(C value);@param;C value;C value;any value of type C;true
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap of(K k1, V v1, K k2, V v2);ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3);Free text;;;Returns an immutable sorted map containing the given entries, sorted by the natural ordering of their keys. ;true
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap of(K k1, V v1, K k2, V v2);ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);Free text;;;Returns an immutable sorted map containing the given entries, sorted by the natural ordering of their keys. ;true
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap of(K k1, V v1, K k2, V v2);ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);Free text;;;Returns an immutable sorted map containing the given entries, sorted by the natural ordering of their keys. ;true
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3);ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);Whole;;;Returns an immutable sorted map containing the given entries, sorted by the natural ordering of their keys.    @throws if any two keys are equal according to their natural ordering;false
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3);ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);Whole;;;Returns an immutable sorted map containing the given entries, sorted by the natural ordering of their keys.    @throws if any two keys are equal according to their natural ordering;false
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3);ImmutableSortedMap copyOf(Map map);@throws;;;if any two keys are equal according to their natural ordering;true
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);Whole;;;Returns an immutable sorted map containing the given entries, sorted by the natural ordering of their keys.    @throws if any two keys are equal according to their natural ordering;false
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);ImmutableSortedMap copyOf(Map map);@throws;;;if any two keys are equal according to their natural ordering;true
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);ImmutableSortedMap copyOf(Map map);@throws;;;if any two keys are equal according to their natural ordering;true
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap copyOf(Map map);ImmutableSortedMap copyOf(Map map, Comparator comparator);@throws;;;if any key or value in map is null;true
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap copyOf(Map map);ImmutableSortedMap copyOf(Iterable entries);@throws;;;if any key or value in map is null;true
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap copyOf(Map map);ImmutableSortedMap copyOf(Iterable entries, Comparator comparator);@throws;;;if any key or value in map is null;true
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap copyOf(Map map);ImmutableSortedMap copyOfSorted(SortedMap map);@throws;;;if any key or value in map is null;true
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap copyOf(Map map, Comparator comparator);ImmutableSortedMap copyOf(Iterable entries);@throws;;;if any key or value in map is null;true
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap copyOf(Map map, Comparator comparator);ImmutableSortedMap copyOf(Iterable entries);@throws;;;if any two keys are equal according to the comparator;true
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap copyOf(Map map, Comparator comparator);ImmutableSortedMap copyOf(Iterable entries, Comparator comparator);@throws;;;if any key or value in map is null;true
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap copyOf(Map map, Comparator comparator);ImmutableSortedMap copyOf(Iterable entries, Comparator comparator);@throws;;;if any two keys are equal according to the comparator;true
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap copyOf(Map map, Comparator comparator);ImmutableSortedMap copyOfSorted(SortedMap map);@throws;;;if any key or value in map is null;true
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap copyOf(Iterable entries);ImmutableSortedMap copyOf(Iterable entries, Comparator comparator);@throws;;;if any key or value in map is null;true
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap copyOf(Iterable entries);ImmutableSortedMap copyOf(Iterable entries, Comparator comparator);@throws;;;if any two keys are equal according to the comparator;true
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap copyOf(Iterable entries);ImmutableSortedMap copyOfSorted(SortedMap map);@throws;;;if any key or value in map is null;true
com.google.common.collect.ImmutableSortedMap;ImmutableSortedMap copyOf(Iterable entries, Comparator comparator);ImmutableSortedMap copyOfSorted(SortedMap map);@throws;;;if any key or value in map is null;true
com.google.common.collect.ImmutableSortedMap;Entry pollFirstEntry();Entry pollLastEntry();Whole;;;Guaranteed to throw an exception and leave the map unmodified.    @throws always;false
com.google.common.collect.Multiset;int add(E element, int occurrences);int remove(Object element, int occurrences);@return;;;the count of the element before the operation, possibly zero;false
com.google.common.collect.Multiset;int add(E element, int occurrences);int setCount(E element, int count);@return;;;the count of the element before the operation, possibly zero;false
com.google.common.collect.Multiset;int remove(Object element, int occurrences);int setCount(E element, int count);@return;;;the count of the element before the operation, possibly zero;false
com.google.common.collect.Multiset;int setCount(E element, int count);boolean setCount(E element, int oldCount, int newCount);@param;int count;int newCount;the desired count of the element in this multiset;true
com.google.common.collect.AbstractSetMultimap;Set get(K key);Set entries();Whole;;;{@inheritDoc} <p>Because a {@code SetMultimap} has unique values for a given key, this method returns a {@link Set}, instead of the {@link Collection} specified in the {@link Multimap} interface.    ;false
com.google.common.collect.AbstractSetMultimap;Set get(K key);Set removeAll(Object key);Whole;;;{@inheritDoc} <p>Because a {@code SetMultimap} has unique values for a given key, this method returns a {@link Set}, instead of the {@link Collection} specified in the {@link Multimap} interface.    ;false
com.google.common.collect.AbstractSetMultimap;Set entries();Set removeAll(Object key);Whole;;;{@inheritDoc} <p>Because a {@code SetMultimap} has unique values for a given key, this method returns a {@link Set}, instead of the {@link Collection} specified in the {@link Multimap} interface.    ;false
com.google.common.collect.Sets;HashSet newHashSetWithExpectedSize(int expectedSize);LinkedHashSet newLinkedHashSetWithExpectedSize(int expectedSize);@param;int expectedSize;int expectedSize;the number of elements you expect to add to the returned set;true
com.google.common.collect.Sets;HashSet newHashSetWithExpectedSize(int expectedSize);LinkedHashSet newLinkedHashSetWithExpectedSize(int expectedSize);@throws;;;if expectedSize is negative;true
com.google.common.collect.Sets;Set newConcurrentHashSet(Iterable elements);TreeSet newTreeSet(Iterable elements);@param;Iterable<? extends E> elements;Iterable<? extends E> elements;the elements that the set should contain;true
com.google.common.collect.Sets;LinkedHashSet newLinkedHashSet(Iterable elements);CopyOnWriteArraySet newCopyOnWriteArraySet(Iterable elements);@param;Iterable<? extends E> elements;Iterable<? extends E> elements;the elements that the set should contain, in order;true
com.google.common.collect.Sets;TreeSet newTreeSet();TreeSet newTreeSet(Comparator comparator);@return;;;a new, empty TreeSet;true
com.google.common.collect.Sets;Set cartesianProduct(List sets);Set cartesianProduct(Set sets);@return;;;the Cartesian product, as an immutable set containing immutable lists;true
com.google.common.collect.Sets;Set cartesianProduct(List sets);Set cartesianProduct(Set sets);@param;List<? extends Set<? extends B>> sets;Set<? extends B> sets;the sets to choose elements from, in the order that the elements chosen from those sets should appear in the resulting lists;true
com.google.common.collect.Sets;Set cartesianProduct(List sets);Set cartesianProduct(Set sets);@throws;;;if sets, any one of the sets, or any element of a provided set is null;true
com.google.common.collect.MapConstraints;Map constrainedMap(Map map, MapConstraint constraint);Multimap constrainedMultimap(Multimap multimap, MapConstraint constraint);@param;MapConstraint<? super K,? super V> constraint;MapConstraint<? super K,? super V> constraint;the constraint that validates added entries;true
com.google.common.collect.MapConstraints;Map constrainedMap(Map map, MapConstraint constraint);ListMultimap constrainedListMultimap(ListMultimap multimap, MapConstraint constraint);@param;MapConstraint<? super K,? super V> constraint;MapConstraint<? super K,? super V> constraint;the constraint that validates added entries;true
com.google.common.collect.MapConstraints;Map constrainedMap(Map map, MapConstraint constraint);SetMultimap constrainedSetMultimap(SetMultimap multimap, MapConstraint constraint);@param;MapConstraint<? super K,? super V> constraint;MapConstraint<? super K,? super V> constraint;the constraint that validates added entries;true
com.google.common.collect.MapConstraints;Map constrainedMap(Map map, MapConstraint constraint);SortedSetMultimap constrainedSortedSetMultimap(SortedSetMultimap multimap, MapConstraint constraint);@param;MapConstraint<? super K,? super V> constraint;MapConstraint<? super K,? super V> constraint;the constraint that validates added entries;true
com.google.common.collect.MapConstraints;Map constrainedMap(Map map, MapConstraint constraint);BiMap constrainedBiMap(BiMap map, MapConstraint constraint);@param;MapConstraint<? super K,? super V> constraint;MapConstraint<? super K,? super V> constraint;the constraint that validates added entries;true
com.google.common.collect.MapConstraints;Multimap constrainedMultimap(Multimap multimap, MapConstraint constraint);ListMultimap constrainedListMultimap(ListMultimap multimap, MapConstraint constraint);@param;Multimap<K,V> multimap;ListMultimap<K,V> multimap;the multimap to constrain;true
com.google.common.collect.MapConstraints;Multimap constrainedMultimap(Multimap multimap, MapConstraint constraint);ListMultimap constrainedListMultimap(ListMultimap multimap, MapConstraint constraint);@param;MapConstraint<? super K,? super V> constraint;MapConstraint<? super K,? super V> constraint;the constraint that validates added entries;true
com.google.common.collect.MapConstraints;Multimap constrainedMultimap(Multimap multimap, MapConstraint constraint);SetMultimap constrainedSetMultimap(SetMultimap multimap, MapConstraint constraint);@param;Multimap<K,V> multimap;SetMultimap<K,V> multimap;the multimap to constrain;true
com.google.common.collect.MapConstraints;Multimap constrainedMultimap(Multimap multimap, MapConstraint constraint);SetMultimap constrainedSetMultimap(SetMultimap multimap, MapConstraint constraint);@param;MapConstraint<? super K,? super V> constraint;MapConstraint<? super K,? super V> constraint;the constraint that validates added entries;true
com.google.common.collect.MapConstraints;Multimap constrainedMultimap(Multimap multimap, MapConstraint constraint);SortedSetMultimap constrainedSortedSetMultimap(SortedSetMultimap multimap, MapConstraint constraint);@param;Multimap<K,V> multimap;SortedSetMultimap<K,V> multimap;the multimap to constrain;true
com.google.common.collect.MapConstraints;Multimap constrainedMultimap(Multimap multimap, MapConstraint constraint);SortedSetMultimap constrainedSortedSetMultimap(SortedSetMultimap multimap, MapConstraint constraint);@param;MapConstraint<? super K,? super V> constraint;MapConstraint<? super K,? super V> constraint;the constraint that validates added entries;true
com.google.common.collect.MapConstraints;Multimap constrainedMultimap(Multimap multimap, MapConstraint constraint);BiMap constrainedBiMap(BiMap map, MapConstraint constraint);@param;MapConstraint<? super K,? super V> constraint;MapConstraint<? super K,? super V> constraint;the constraint that validates added entries;true
com.google.common.collect.MapConstraints;ListMultimap constrainedListMultimap(ListMultimap multimap, MapConstraint constraint);SetMultimap constrainedSetMultimap(SetMultimap multimap, MapConstraint constraint);@return;;;a constrained view of the specified multimap;false
com.google.common.collect.MapConstraints;ListMultimap constrainedListMultimap(ListMultimap multimap, MapConstraint constraint);SetMultimap constrainedSetMultimap(SetMultimap multimap, MapConstraint constraint);@param;ListMultimap<K,V> multimap;SetMultimap<K,V> multimap;the multimap to constrain;true
com.google.common.collect.MapConstraints;ListMultimap constrainedListMultimap(ListMultimap multimap, MapConstraint constraint);SetMultimap constrainedSetMultimap(SetMultimap multimap, MapConstraint constraint);@param;MapConstraint<? super K,? super V> constraint;MapConstraint<? super K,? super V> constraint;the constraint that validates added entries;true
com.google.common.collect.MapConstraints;ListMultimap constrainedListMultimap(ListMultimap multimap, MapConstraint constraint);SortedSetMultimap constrainedSortedSetMultimap(SortedSetMultimap multimap, MapConstraint constraint);@return;;;a constrained view of the specified multimap;false
com.google.common.collect.MapConstraints;ListMultimap constrainedListMultimap(ListMultimap multimap, MapConstraint constraint);SortedSetMultimap constrainedSortedSetMultimap(SortedSetMultimap multimap, MapConstraint constraint);@param;ListMultimap<K,V> multimap;SortedSetMultimap<K,V> multimap;the multimap to constrain;true
com.google.common.collect.MapConstraints;ListMultimap constrainedListMultimap(ListMultimap multimap, MapConstraint constraint);SortedSetMultimap constrainedSortedSetMultimap(SortedSetMultimap multimap, MapConstraint constraint);@param;MapConstraint<? super K,? super V> constraint;MapConstraint<? super K,? super V> constraint;the constraint that validates added entries;true
com.google.common.collect.MapConstraints;ListMultimap constrainedListMultimap(ListMultimap multimap, MapConstraint constraint);BiMap constrainedBiMap(BiMap map, MapConstraint constraint);@param;MapConstraint<? super K,? super V> constraint;MapConstraint<? super K,? super V> constraint;the constraint that validates added entries;true
com.google.common.collect.MapConstraints;SetMultimap constrainedSetMultimap(SetMultimap multimap, MapConstraint constraint);SortedSetMultimap constrainedSortedSetMultimap(SortedSetMultimap multimap, MapConstraint constraint);@return;;;a constrained view of the specified multimap;false
com.google.common.collect.MapConstraints;SetMultimap constrainedSetMultimap(SetMultimap multimap, MapConstraint constraint);SortedSetMultimap constrainedSortedSetMultimap(SortedSetMultimap multimap, MapConstraint constraint);@param;SetMultimap<K,V> multimap;SortedSetMultimap<K,V> multimap;the multimap to constrain;true
com.google.common.collect.MapConstraints;SetMultimap constrainedSetMultimap(SetMultimap multimap, MapConstraint constraint);SortedSetMultimap constrainedSortedSetMultimap(SortedSetMultimap multimap, MapConstraint constraint);@param;MapConstraint<? super K,? super V> constraint;MapConstraint<? super K,? super V> constraint;the constraint that validates added entries;true
com.google.common.collect.MapConstraints;SetMultimap constrainedSetMultimap(SetMultimap multimap, MapConstraint constraint);BiMap constrainedBiMap(BiMap map, MapConstraint constraint);@param;MapConstraint<? super K,? super V> constraint;MapConstraint<? super K,? super V> constraint;the constraint that validates added entries;true
com.google.common.collect.MapConstraints;SortedSetMultimap constrainedSortedSetMultimap(SortedSetMultimap multimap, MapConstraint constraint);BiMap constrainedBiMap(BiMap map, MapConstraint constraint);@param;MapConstraint<? super K,? super V> constraint;MapConstraint<? super K,? super V> constraint;the constraint that validates added entries;true
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet.Builder builder();ImmutableSortedSet of(E element);@throws;;;always;true
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet.Builder builder();ImmutableSortedSet of(E e1, E e2);@throws;;;always;true
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet.Builder builder();ImmutableSortedSet of(E e1, E e2, E e3);@throws;;;always;true
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet.Builder builder();ImmutableSortedSet of(E e1, E e2, E e3, E e4);@throws;;;always;true
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet.Builder builder();ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5);@throws;;;always;true
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet.Builder builder();ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);@throws;;;always;true
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet.Builder builder();ImmutableSortedSet copyOf(E[] elements);@throws;;;always;true
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet of(E element);ImmutableSortedSet of(E e1, E e2);Whole;;;Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet of(E element);ImmutableSortedSet of(E e1, E e2, E e3);Whole;;;Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet of(E element);ImmutableSortedSet of(E e1, E e2, E e3, E e4);Whole;;;Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet of(E element);ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5);Whole;;;Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet of(E element);ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);Whole;;;Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet of(E element);ImmutableSortedSet copyOf(E[] elements);@throws;;;always;true
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet of(E e1, E e2);ImmutableSortedSet of(E e1, E e2, E e3);Whole;;;Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet of(E e1, E e2);ImmutableSortedSet of(E e1, E e2, E e3, E e4);Whole;;;Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet of(E e1, E e2);ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5);Whole;;;Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet of(E e1, E e2);ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);Whole;;;Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet of(E e1, E e2);ImmutableSortedSet copyOf(E[] elements);@throws;;;always;true
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet of(E e1, E e2, E e3);ImmutableSortedSet of(E e1, E e2, E e3, E e4);Whole;;;Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet of(E e1, E e2, E e3);ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5);Whole;;;Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet of(E e1, E e2, E e3);ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);Whole;;;Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet of(E e1, E e2, E e3);ImmutableSortedSet copyOf(E[] elements);@throws;;;always;true
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet of(E e1, E e2, E e3, E e4);ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5);Whole;;;Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet of(E e1, E e2, E e3, E e4);ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);Whole;;;Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet of(E e1, E e2, E e3, E e4);ImmutableSortedSet copyOf(E[] elements);@throws;;;always;true
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5);ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);Whole;;;Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5);ImmutableSortedSet copyOf(E[] elements);@throws;;;always;true
com.google.common.collect.ImmutableSortedSetFauxverideShim;ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);ImmutableSortedSet copyOf(E[] elements);@throws;;;always;true
com.google.common.collect.Iterables;boolean removeAll(Iterable removeFrom, Collection elementsToRemove);boolean retainAll(Iterable removeFrom, Collection elementsToRetain);@return;;;true if any element was removed from iterable;false
com.google.common.collect.Iterables;boolean removeAll(Iterable removeFrom, Collection elementsToRemove);boolean retainAll(Iterable removeFrom, Collection elementsToRetain);@param;Iterable<?> removeFrom;Iterable<?> removeFrom;the iterable to (potentially) remove elements from;true
com.google.common.collect.Iterables;boolean removeAll(Iterable removeFrom, Collection elementsToRemove);boolean removeIf(Iterable removeFrom, Predicate predicate);@param;Iterable<?> removeFrom;Iterable<T> removeFrom;the iterable to (potentially) remove elements from;true
com.google.common.collect.Iterables;boolean retainAll(Iterable removeFrom, Collection elementsToRetain);boolean removeIf(Iterable removeFrom, Predicate predicate);@param;Iterable<?> removeFrom;Iterable<T> removeFrom;the iterable to (potentially) remove elements from;true
com.google.common.collect.Iterables;T getOnlyElement(Iterable iterable);T getLast(Iterable iterable);@throws;;;if the iterable is empty;true
com.google.common.collect.Iterables;T[] toArray(Iterable iterable, Class type);Object[] toArray(Iterable iterable);Free text;;;Copies an iterable's elements into an array. ;true
com.google.common.collect.Iterables;T[] toArray(Iterable iterable, Class type);Object[] toArray(Iterable iterable);@return;;;a newly-allocated array into which all the elements of the iterable have been copied;true
com.google.common.collect.Iterables;T[] toArray(Iterable iterable, Class type);Object[] toArray(Iterable iterable);@param;Iterable<? extends T> iterable;Iterable<?> iterable;the iterable to copy;true
com.google.common.collect.Iterables;Iterable partition(Iterable iterable, int size);Iterable paddedPartition(Iterable iterable, int size);@param;Iterable<T> iterable;Iterable<T> iterable;the iterable to return a partitioned view of;true
com.google.common.collect.Iterables;Iterable partition(Iterable iterable, int size);Iterable paddedPartition(Iterable iterable, int size);@throws;;;if size is nonpositive;true
com.google.common.collect.Iterables;T get(Iterable iterable, int position);T get(Iterable iterable, int position, T defaultValue);@param;int position;int position;position of the element to return;true
com.google.common.collect.Iterators;UnmodifiableIterator unmodifiableIterator(UnmodifiableIterator iterator);PeekingIterator peekingIterator(PeekingIterator iterator);Whole;;;Simply returns its argument. @deprecated no need to use this    ;false
com.google.common.collect.Iterators;boolean removeAll(Iterator removeFrom, Collection elementsToRemove);boolean removeIf(Iterator removeFrom, Predicate predicate);@param;Iterator<?> removeFrom;Iterator<T> removeFrom;the iterator to (potentially) remove elements from;true
com.google.common.collect.Iterators;boolean removeAll(Iterator removeFrom, Collection elementsToRemove);boolean retainAll(Iterator removeFrom, Collection elementsToRetain);@return;;;true if any element was removed from iterator;false
com.google.common.collect.Iterators;boolean removeAll(Iterator removeFrom, Collection elementsToRemove);boolean retainAll(Iterator removeFrom, Collection elementsToRetain);@param;Iterator<?> removeFrom;Iterator<?> removeFrom;the iterator to (potentially) remove elements from;true
com.google.common.collect.Iterators;boolean removeIf(Iterator removeFrom, Predicate predicate);boolean retainAll(Iterator removeFrom, Collection elementsToRetain);@param;Iterator<T> removeFrom;Iterator<?> removeFrom;the iterator to (potentially) remove elements from;true
com.google.common.collect.Iterators;T getOnlyElement(Iterator iterator);T getOnlyElement(Iterator iterator, T defaultValue);@throws;;;if the iterator contains multiple elements. The state of the iterator is unspecified.;true
com.google.common.collect.Iterators;T getOnlyElement(Iterator iterator);T getLast(Iterator iterator);@throws;;;if the iterator is empty;true
com.google.common.collect.Iterators;UnmodifiableIterator partition(Iterator iterator, int size);UnmodifiableIterator paddedPartition(Iterator iterator, int size);@param;Iterator<T> iterator;Iterator<T> iterator;the iterator to return a partitioned view of;true
com.google.common.collect.Iterators;UnmodifiableIterator partition(Iterator iterator, int size);UnmodifiableIterator paddedPartition(Iterator iterator, int size);@throws;;;if size is nonpositive;true
com.google.common.collect.Iterators;T get(Iterator iterator, int position);T get(Iterator iterator, int position, T defaultValue);@param;int position;int position;position of the element to return;true
com.google.common.collect.Iterators;T getNext(Iterator iterator, T defaultValue);T getLast(Iterator iterator, T defaultValue);@param;T defaultValue;T defaultValue;the default value to return if the iterator is empty;true
com.google.common.collect.Iterators;T getLast(Iterator iterator);T getLast(Iterator iterator, T defaultValue);@return;;;the last element of iterator;true
com.google.common.collect.Constraints;Collection constrainedCollection(Collection collection, Constraint constraint);Set constrainedSet(Set set, Constraint constraint);@param;Constraint<? super E> constraint;Constraint<? super E> constraint;the constraint that validates added elements;true
com.google.common.collect.Constraints;Collection constrainedCollection(Collection collection, Constraint constraint);SortedSet constrainedSortedSet(SortedSet sortedSet, Constraint constraint);@param;Constraint<? super E> constraint;Constraint<? super E> constraint;the constraint that validates added elements;true
com.google.common.collect.Constraints;Collection constrainedCollection(Collection collection, Constraint constraint);List constrainedList(List list, Constraint constraint);@param;Constraint<? super E> constraint;Constraint<? super E> constraint;the constraint that validates added elements;true
com.google.common.collect.Constraints;Set constrainedSet(Set set, Constraint constraint);SortedSet constrainedSortedSet(SortedSet sortedSet, Constraint constraint);@param;Constraint<? super E> constraint;Constraint<? super E> constraint;the constraint that validates added elements;true
com.google.common.collect.Constraints;Set constrainedSet(Set set, Constraint constraint);List constrainedList(List list, Constraint constraint);@param;Constraint<? super E> constraint;Constraint<? super E> constraint;the constraint that validates added elements;true
com.google.common.collect.Constraints;SortedSet constrainedSortedSet(SortedSet sortedSet, Constraint constraint);List constrainedList(List list, Constraint constraint);@param;Constraint<? super E> constraint;Constraint<? super E> constraint;the constraint that validates added elements;true
com.google.common.collect.ImmutableSetMultimap;ImmutableSetMultimap of(K k1, V v1, K k2, V v2);ImmutableSetMultimap of(K k1, V v1, K k2, V v2, K k3, V v3);Whole;;;Returns an immutable multimap containing the given entries, in order. Repeated occurrences of an entry (according to {@link Object#equals}) after the first are ignored.    ;false
com.google.common.collect.ImmutableSetMultimap;ImmutableSetMultimap of(K k1, V v1, K k2, V v2);ImmutableSetMultimap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);Whole;;;Returns an immutable multimap containing the given entries, in order. Repeated occurrences of an entry (according to {@link Object#equals}) after the first are ignored.    ;false
com.google.common.collect.ImmutableSetMultimap;ImmutableSetMultimap of(K k1, V v1, K k2, V v2);ImmutableSetMultimap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);Whole;;;Returns an immutable multimap containing the given entries, in order. Repeated occurrences of an entry (according to {@link Object#equals}) after the first are ignored.    ;false
com.google.common.collect.ImmutableSetMultimap;ImmutableSetMultimap of(K k1, V v1, K k2, V v2, K k3, V v3);ImmutableSetMultimap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);Whole;;;Returns an immutable multimap containing the given entries, in order. Repeated occurrences of an entry (according to {@link Object#equals}) after the first are ignored.    ;false
com.google.common.collect.ImmutableSetMultimap;ImmutableSetMultimap of(K k1, V v1, K k2, V v2, K k3, V v3);ImmutableSetMultimap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);Whole;;;Returns an immutable multimap containing the given entries, in order. Repeated occurrences of an entry (according to {@link Object#equals}) after the first are ignored.    ;false
com.google.common.collect.ImmutableSetMultimap;ImmutableSetMultimap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);ImmutableSetMultimap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);Whole;;;Returns an immutable multimap containing the given entries, in order. Repeated occurrences of an entry (according to {@link Object#equals}) after the first are ignored.    ;false
com.google.common.collect.ImmutableSetMultimap;ImmutableSet removeAll(Object key);ImmutableSet replaceValues(K key, Iterable values);Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2);ImmutableMultiset of(E e1, E e2, E e3);@throws;;;if any element is null;true
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2);ImmutableMultiset of(E e1, E e2, E e3, E e4);@throws;;;if any element is null;true
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2);ImmutableMultiset of(E e1, E e2, E e3, E e4, E e5);@throws;;;if any element is null;true
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2);ImmutableMultiset of(E e1, E e2, E e3, E e4, E e5, E e6, E others);@throws;;;if any element is null;true
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2, E e3);ImmutableMultiset of(E e1, E e2, E e3, E e4);Whole;;;Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation.    @throws if any element is null;false
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2, E e3);ImmutableMultiset of(E e1, E e2, E e3, E e4, E e5);Whole;;;Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation.    @throws if any element is null;false
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2, E e3);ImmutableMultiset of(E e1, E e2, E e3, E e4, E e5, E e6, E others);Whole;;;Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation.    @throws if any element is null;false
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2, E e3);ImmutableMultiset copyOf(E[] elements);Free text;;;Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation. ;false
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2, E e3);ImmutableMultiset copyOf(Iterable elements);Free text;;;Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation. ;false
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2, E e3);ImmutableMultiset copyOf(Iterator elements);Free text;;;Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation. ;false
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2, E e3, E e4);ImmutableMultiset of(E e1, E e2, E e3, E e4, E e5);Whole;;;Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation.    @throws if any element is null;false
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2, E e3, E e4);ImmutableMultiset of(E e1, E e2, E e3, E e4, E e5, E e6, E others);Whole;;;Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation.    @throws if any element is null;false
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2, E e3, E e4);ImmutableMultiset copyOf(E[] elements);Free text;;;Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation. ;false
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2, E e3, E e4);ImmutableMultiset copyOf(Iterable elements);Free text;;;Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation. ;false
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2, E e3, E e4);ImmutableMultiset copyOf(Iterator elements);Free text;;;Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation. ;false
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2, E e3, E e4, E e5);ImmutableMultiset of(E e1, E e2, E e3, E e4, E e5, E e6, E others);Whole;;;Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation.    @throws if any element is null;false
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2, E e3, E e4, E e5);ImmutableMultiset copyOf(E[] elements);Free text;;;Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation. ;false
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2, E e3, E e4, E e5);ImmutableMultiset copyOf(Iterable elements);Free text;;;Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation. ;false
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2, E e3, E e4, E e5);ImmutableMultiset copyOf(Iterator elements);Free text;;;Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation. ;false
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2, E e3, E e4, E e5, E e6, E others);ImmutableMultiset copyOf(E[] elements);Free text;;;Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation. ;false
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2, E e3, E e4, E e5, E e6, E others);ImmutableMultiset copyOf(Iterable elements);Free text;;;Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation. ;false
com.google.common.collect.ImmutableMultiset;ImmutableMultiset of(E e1, E e2, E e3, E e4, E e5, E e6, E others);ImmutableMultiset copyOf(Iterator elements);Free text;;;Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation. ;false
com.google.common.collect.ImmutableMultiset;ImmutableMultiset copyOf(E[] elements);ImmutableMultiset copyOf(Iterable elements);Whole;;;Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation.    @throws if any of elements is null;false
com.google.common.collect.ImmutableMultiset;ImmutableMultiset copyOf(E[] elements);ImmutableMultiset copyOf(Iterator elements);Whole;;;Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation.    @throws if any of elements is null;false
com.google.common.collect.ImmutableMultiset;ImmutableMultiset copyOf(Iterable elements);ImmutableMultiset copyOf(Iterator elements);Whole;;;Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation.    @throws if any of elements is null;false
com.google.common.collect.ImmutableMultiset;int add(E element, int occurrences);int remove(Object element, int occurrences);Whole;;;Guaranteed to throw an exception and leave the collection unmodified.    @throws always;false
com.google.common.collect.ImmutableMultiset;int add(E element, int occurrences);int setCount(E element, int count);Whole;;;Guaranteed to throw an exception and leave the collection unmodified.    @throws always;false
com.google.common.collect.ImmutableMultiset;int add(E element, int occurrences);boolean setCount(E element, int oldCount, int newCount);Whole;;;Guaranteed to throw an exception and leave the collection unmodified.    @throws always;false
com.google.common.collect.ImmutableMultiset;int remove(Object element, int occurrences);int setCount(E element, int count);Whole;;;Guaranteed to throw an exception and leave the collection unmodified.    @throws always;false
com.google.common.collect.ImmutableMultiset;int remove(Object element, int occurrences);boolean setCount(E element, int oldCount, int newCount);Whole;;;Guaranteed to throw an exception and leave the collection unmodified.    @throws always;false
com.google.common.collect.ImmutableMultiset;int setCount(E element, int count);boolean setCount(E element, int oldCount, int newCount);Whole;;;Guaranteed to throw an exception and leave the collection unmodified.    @throws always;false
com.google.common.collect.ImmutableSet;ImmutableSet of(E e1, E e2);ImmutableSet of(E e1, E e2, E e3);Whole;;;Returns an immutable set containing the given elements, minus duplicates, in the order each was first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except the first are ignored.    ;false
com.google.common.collect.ImmutableSet;ImmutableSet of(E e1, E e2);ImmutableSet of(E e1, E e2, E e3, E e4);Whole;;;Returns an immutable set containing the given elements, minus duplicates, in the order each was first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except the first are ignored.    ;false
com.google.common.collect.ImmutableSet;ImmutableSet of(E e1, E e2);ImmutableSet of(E e1, E e2, E e3, E e4, E e5);Whole;;;Returns an immutable set containing the given elements, minus duplicates, in the order each was first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except the first are ignored.    ;false
com.google.common.collect.ImmutableSet;ImmutableSet of(E e1, E e2);ImmutableSet of(E e1, E e2, E e3, E e4, E e5, E e6, E others);Whole;;;Returns an immutable set containing the given elements, minus duplicates, in the order each was first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except the first are ignored.    ;false
com.google.common.collect.ImmutableSet;ImmutableSet of(E e1, E e2, E e3);ImmutableSet of(E e1, E e2, E e3, E e4);Whole;;;Returns an immutable set containing the given elements, minus duplicates, in the order each was first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except the first are ignored.    ;false
com.google.common.collect.ImmutableSet;ImmutableSet of(E e1, E e2, E e3);ImmutableSet of(E e1, E e2, E e3, E e4, E e5);Whole;;;Returns an immutable set containing the given elements, minus duplicates, in the order each was first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except the first are ignored.    ;false
com.google.common.collect.ImmutableSet;ImmutableSet of(E e1, E e2, E e3);ImmutableSet of(E e1, E e2, E e3, E e4, E e5, E e6, E others);Whole;;;Returns an immutable set containing the given elements, minus duplicates, in the order each was first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except the first are ignored.    ;false
com.google.common.collect.ImmutableSet;ImmutableSet of(E e1, E e2, E e3, E e4);ImmutableSet of(E e1, E e2, E e3, E e4, E e5);Whole;;;Returns an immutable set containing the given elements, minus duplicates, in the order each was first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except the first are ignored.    ;false
com.google.common.collect.ImmutableSet;ImmutableSet of(E e1, E e2, E e3, E e4);ImmutableSet of(E e1, E e2, E e3, E e4, E e5, E e6, E others);Whole;;;Returns an immutable set containing the given elements, minus duplicates, in the order each was first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except the first are ignored.    ;false
com.google.common.collect.ImmutableSet;ImmutableSet of(E e1, E e2, E e3, E e4, E e5);ImmutableSet of(E e1, E e2, E e3, E e4, E e5, E e6, E others);Whole;;;Returns an immutable set containing the given elements, minus duplicates, in the order each was first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except the first are ignored.    ;false
com.google.common.collect.ImmutableSet;ImmutableSet copyOf(Collection elements);ImmutableSet copyOf(Iterable elements);@throws;;;if any of elements is null;true
com.google.common.collect.ImmutableSet;ImmutableSet copyOf(Collection elements);ImmutableSet copyOf(Iterator elements);@throws;;;if any of elements is null;true
com.google.common.collect.ImmutableSet;ImmutableSet copyOf(Collection elements);ImmutableSet copyOf(E[] elements);@throws;;;if any of elements is null;true
com.google.common.collect.ImmutableSet;ImmutableSet copyOf(Iterable elements);ImmutableSet copyOf(Iterator elements);@throws;;;if any of elements is null;true
com.google.common.collect.ImmutableSet;ImmutableSet copyOf(Iterable elements);ImmutableSet copyOf(E[] elements);@throws;;;if any of elements is null;true
com.google.common.collect.ImmutableSet;ImmutableSet copyOf(Iterator elements);ImmutableSet copyOf(E[] elements);@throws;;;if any of elements is null;true
com.google.common.collect.Maps;HashMap newHashMapWithExpectedSize(int expectedSize);LinkedHashMap newLinkedHashMapWithExpectedSize(int expectedSize);@param;int expectedSize;int expectedSize;the number of entries you expect to add to the returned map;true
com.google.common.collect.Maps;HashMap newHashMapWithExpectedSize(int expectedSize);LinkedHashMap newLinkedHashMapWithExpectedSize(int expectedSize);@throws;;;if expectedSize is negative;true
com.google.common.collect.Maps;HashMap newHashMap(Map map);LinkedHashMap newLinkedHashMap(Map map);@param;Map<? extends K,? extends V> map;Map<? extends K,? extends V> map;the mappings to be placed in the new map;true
com.google.common.collect.Maps;TreeMap newTreeMap();TreeMap newTreeMap(Comparator comparator);@return;;;a new, empty TreeMap;true
com.google.common.collect.Maps;MapDifference difference(Map left, Map right);MapDifference difference(Map left, Map right, Equivalence valueEquivalence);@return;;;the difference between the two maps;true
com.google.common.collect.Maps;MapDifference difference(Map left, Map right);MapDifference difference(Map left, Map right, Equivalence valueEquivalence);@param;Map<? extends K,? extends V> left;Map<? extends K,? extends V> left;the map to treat as the "left" map for purposes of comparison;true
com.google.common.collect.Maps;MapDifference difference(Map left, Map right);MapDifference difference(Map left, Map right, Equivalence valueEquivalence);@param;Map<? extends K,? extends V> right;Map<? extends K,? extends V> right;the map to treat as the "right" map for purposes of comparison;true
com.google.common.collect.Maps;MapDifference difference(Map left, Map right);SortedMapDifference difference(SortedMap left, Map right);@return;;;the difference between the two maps;true
com.google.common.collect.Maps;MapDifference difference(Map left, Map right);SortedMapDifference difference(SortedMap left, Map right);@param;Map<? extends K,? extends V> left;SortedMap<K,? extends V> left;the map to treat as the "left" map for purposes of comparison;true
com.google.common.collect.Maps;MapDifference difference(Map left, Map right);SortedMapDifference difference(SortedMap left, Map right);@param;Map<? extends K,? extends V> right;Map<? extends K,? extends V> right;the map to treat as the "right" map for purposes of comparison;true
com.google.common.collect.Maps;MapDifference difference(Map left, Map right, Equivalence valueEquivalence);SortedMapDifference difference(SortedMap left, Map right);@return;;;the difference between the two maps;true
com.google.common.collect.Maps;MapDifference difference(Map left, Map right, Equivalence valueEquivalence);SortedMapDifference difference(SortedMap left, Map right);@param;Map<? extends K,? extends V> left;SortedMap<K,? extends V> left;the map to treat as the "left" map for purposes of comparison;true
com.google.common.collect.Maps;MapDifference difference(Map left, Map right, Equivalence valueEquivalence);SortedMapDifference difference(SortedMap left, Map right);@param;Map<? extends K,? extends V> right;Map<? extends K,? extends V> right;the map to treat as the "right" map for purposes of comparison;true
com.google.common.collect.Maps;ImmutableMap toMap(Iterable keys, Function valueFunction);ImmutableMap toMap(Iterator keys, Function valueFunction);@throws;;;if any element of keys is null, or if valueFunction produces null for any key;true
com.google.common.collect.Maps;ImmutableMap uniqueIndex(Iterable values, Function keyFunction);ImmutableMap uniqueIndex(Iterator values, Function keyFunction);@return;;;a map mapping the result of evaluating the function keyFunction on each value in the input collection to that value;true
com.google.common.collect.Maps;ImmutableMap uniqueIndex(Iterable values, Function keyFunction);ImmutableMap uniqueIndex(Iterator values, Function keyFunction);@param;Iterable<V> values;Iterator<V> values;the values to use when constructing the Map;true
com.google.common.collect.Maps;ImmutableMap uniqueIndex(Iterable values, Function keyFunction);ImmutableMap uniqueIndex(Iterator values, Function keyFunction);@param;Function<? super V,K> keyFunction;Function<? super V,K> keyFunction;the function used to produce the key for each value;true
com.google.common.collect.Maps;ImmutableMap uniqueIndex(Iterable values, Function keyFunction);ImmutableMap uniqueIndex(Iterator values, Function keyFunction);@throws;;;if keyFunction produces the same key for more than one value in the input collection;true
com.google.common.collect.Maps;ImmutableMap uniqueIndex(Iterable values, Function keyFunction);ImmutableMap uniqueIndex(Iterator values, Function keyFunction);@throws;;;if any elements of values is null, or if keyFunction produces null for any value;true
com.google.common.collect.Maps;SortedMap filterEntries(SortedMap unfiltered, Predicate entryPredicate);NavigableMap filterEntries(NavigableMap unfiltered, Predicate entryPredicate);Whole;;;Returns a sorted map containing the mappings in {@code unfiltered} that satisfy a predicate. The returned map is a live view of {@code unfiltered}, changes to one affect the other. <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have iterators that don't support {@code remove()}, but all other methods are supported by the map and its views. When given a key/value pair that doesn't satisfy the predicate, the map's {@code put()} and {@code putAll()} methods throw an {@link IllegalArgumentException}. Similarly, the map's entries have a {@link Entry#setValue} method that throws an {@link IllegalArgumentException} when the existing key and the provided value don't satisfy the predicate. <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map or its views, only mappings that satisfy the filter will be removed from the underlying map. <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is. <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is <i>not</i> needed, it may be faster to copy the filtered map and use the copy. <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals</i>, as documented at {@link Predicate#apply}.    ;false
com.google.common.collect.Maps;boolean containsEntryImpl(Collection c, Object o);boolean removeEntryImpl(Collection c, Object o);@param;Collection<Entry<K,V>> c;Collection<Entry<K,V>> c;the delegate (unwrapped) collection of map entries;true
com.google.common.collect.ImmutableBiMap;ImmutableBiMap of(K k1, V v1, K k2, V v2);ImmutableBiMap of(K k1, V v1, K k2, V v2, K k3, V v3);Whole;;;Returns an immutable map containing the given entries, in order.    @throws if duplicate keys or values are added;false
com.google.common.collect.ImmutableBiMap;ImmutableBiMap of(K k1, V v1, K k2, V v2);ImmutableBiMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);Whole;;;Returns an immutable map containing the given entries, in order.    @throws if duplicate keys or values are added;false
com.google.common.collect.ImmutableBiMap;ImmutableBiMap of(K k1, V v1, K k2, V v2);ImmutableBiMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);Whole;;;Returns an immutable map containing the given entries, in order.    @throws if duplicate keys or values are added;false
com.google.common.collect.ImmutableBiMap;ImmutableBiMap of(K k1, V v1, K k2, V v2, K k3, V v3);ImmutableBiMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);Whole;;;Returns an immutable map containing the given entries, in order.    @throws if duplicate keys or values are added;false
com.google.common.collect.ImmutableBiMap;ImmutableBiMap of(K k1, V v1, K k2, V v2, K k3, V v3);ImmutableBiMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);Whole;;;Returns an immutable map containing the given entries, in order.    @throws if duplicate keys or values are added;false
com.google.common.collect.ImmutableBiMap;ImmutableBiMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);ImmutableBiMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);Whole;;;Returns an immutable map containing the given entries, in order.    @throws if duplicate keys or values are added;false
com.google.common.collect.ContiguousSet;Range range();Range range(BoundType lowerBoundType, BoundType upperBoundType);@throws;;;if this set is empty;true
com.google.common.collect.Collections2;Collection orderedPermutations(Iterable elements);Collection orderedPermutations(Iterable elements, Comparator comparator);@return;;;an immutable Collection containing all the different permutations of the original iterable.;true
com.google.common.collect.Collections2;Collection orderedPermutations(Iterable elements);Collection orderedPermutations(Iterable elements, Comparator comparator);@param;Iterable<E> elements;Iterable<E> elements;the original iterable whose elements have to be permuted.;true
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset.Builder builder();ImmutableSortedMultiset of(E element);@throws;;;always;true
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset.Builder builder();ImmutableSortedMultiset of(E e1, E e2);@throws;;;always;true
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset.Builder builder();ImmutableSortedMultiset of(E e1, E e2, E e3);@throws;;;always;true
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset.Builder builder();ImmutableSortedMultiset of(E e1, E e2, E e3, E e4);@throws;;;always;true
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset.Builder builder();ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5);@throws;;;always;true
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset.Builder builder();ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);@throws;;;always;true
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset.Builder builder();ImmutableSortedMultiset copyOf(E[] elements);@throws;;;always;true
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset of(E element);ImmutableSortedMultiset of(E e1, E e2);Whole;;;Not supported. <b>You are attempting to create a multiset that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedMultiset}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset of(E element);ImmutableSortedMultiset of(E e1, E e2, E e3);Whole;;;Not supported. <b>You are attempting to create a multiset that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedMultiset}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset of(E element);ImmutableSortedMultiset of(E e1, E e2, E e3, E e4);Whole;;;Not supported. <b>You are attempting to create a multiset that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedMultiset}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset of(E element);ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5);Whole;;;Not supported. <b>You are attempting to create a multiset that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedMultiset}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset of(E element);ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);Whole;;;Not supported. <b>You are attempting to create a multiset that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedMultiset}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset of(E element);ImmutableSortedMultiset copyOf(E[] elements);@throws;;;always;true
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset of(E e1, E e2);ImmutableSortedMultiset of(E e1, E e2, E e3);Whole;;;Not supported. <b>You are attempting to create a multiset that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedMultiset}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset of(E e1, E e2);ImmutableSortedMultiset of(E e1, E e2, E e3, E e4);Whole;;;Not supported. <b>You are attempting to create a multiset that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedMultiset}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset of(E e1, E e2);ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5);Whole;;;Not supported. <b>You are attempting to create a multiset that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedMultiset}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset of(E e1, E e2);ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);Whole;;;Not supported. <b>You are attempting to create a multiset that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedMultiset}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset of(E e1, E e2);ImmutableSortedMultiset copyOf(E[] elements);@throws;;;always;true
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset of(E e1, E e2, E e3);ImmutableSortedMultiset of(E e1, E e2, E e3, E e4);Whole;;;Not supported. <b>You are attempting to create a multiset that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedMultiset}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset of(E e1, E e2, E e3);ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5);Whole;;;Not supported. <b>You are attempting to create a multiset that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedMultiset}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset of(E e1, E e2, E e3);ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);Whole;;;Not supported. <b>You are attempting to create a multiset that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedMultiset}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset of(E e1, E e2, E e3);ImmutableSortedMultiset copyOf(E[] elements);@throws;;;always;true
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset of(E e1, E e2, E e3, E e4);ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5);Whole;;;Not supported. <b>You are attempting to create a multiset that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedMultiset}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset of(E e1, E e2, E e3, E e4);ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);Whole;;;Not supported. <b>You are attempting to create a multiset that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedMultiset}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset of(E e1, E e2, E e3, E e4);ImmutableSortedMultiset copyOf(E[] elements);@throws;;;always;true
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5);ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);Whole;;;Not supported. <b>You are attempting to create a multiset that may contain a non-{@code Comparable} element.</b> Proper calls will resolve to the version in {@code ImmutableSortedMultiset}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5);ImmutableSortedMultiset copyOf(E[] elements);@throws;;;always;true
com.google.common.collect.ImmutableSortedMultisetFauxverideShim;ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);ImmutableSortedMultiset copyOf(E[] elements);@throws;;;always;true
com.google.common.collect.Queues;LinkedBlockingDeque newLinkedBlockingDeque(int capacity);LinkedBlockingQueue newLinkedBlockingQueue(int capacity);@throws;;;if capacity is less than 1;true
com.google.common.collect.Queues;int drain(BlockingQueue q, Collection buffer, int numElements, long timeout, TimeUnit unit);int drainUninterruptibly(BlockingQueue q, Collection buffer, int numElements, long timeout, TimeUnit unit);@return;;;the number of elements transferred;false
com.google.common.collect.Queues;int drain(BlockingQueue q, Collection buffer, int numElements, long timeout, TimeUnit unit);int drainUninterruptibly(BlockingQueue q, Collection buffer, int numElements, long timeout, TimeUnit unit);@param;BlockingQueue<E> q;BlockingQueue<E> q;the blocking queue to be drained;true
com.google.common.collect.Queues;int drain(BlockingQueue q, Collection buffer, int numElements, long timeout, TimeUnit unit);int drainUninterruptibly(BlockingQueue q, Collection buffer, int numElements, long timeout, TimeUnit unit);@param;Collection<? super E> buffer;Collection<? super E> buffer;where to add the transferred elements;true
com.google.common.collect.Queues;int drain(BlockingQueue q, Collection buffer, int numElements, long timeout, TimeUnit unit);int drainUninterruptibly(BlockingQueue q, Collection buffer, int numElements, long timeout, TimeUnit unit);@param;int numElements;int numElements;the number of elements to be waited for;true
com.google.common.collect.Queues;int drain(BlockingQueue q, Collection buffer, int numElements, long timeout, TimeUnit unit);int drainUninterruptibly(BlockingQueue q, Collection buffer, int numElements, long timeout, TimeUnit unit);@param;long timeout;long timeout;how long to wait before giving up, in units of unit;true
com.google.common.collect.Queues;int drain(BlockingQueue q, Collection buffer, int numElements, long timeout, TimeUnit unit);int drainUninterruptibly(BlockingQueue q, Collection buffer, int numElements, long timeout, TimeUnit unit);@param;TimeUnit unit;TimeUnit unit;a TimeUnit determining how to interpret the timeout parameter;true
com.google.common.collect.Table;boolean contains(Object rowKey, Object columnKey);boolean containsRow(Object rowKey);@param;Object rowKey;Object rowKey;key of row to search for;true
com.google.common.collect.Table;boolean contains(Object rowKey, Object columnKey);boolean containsColumn(Object columnKey);@param;Object columnKey;Object columnKey;key of column to search for;true
com.google.common.collect.Table;boolean contains(Object rowKey, Object columnKey);V get(Object rowKey, Object columnKey);@param;Object rowKey;Object rowKey;key of row to search for;true
com.google.common.collect.Table;boolean contains(Object rowKey, Object columnKey);V get(Object rowKey, Object columnKey);@param;Object columnKey;Object columnKey;key of column to search for;true
com.google.common.collect.Table;boolean containsRow(Object rowKey);V get(Object rowKey, Object columnKey);@param;Object rowKey;Object rowKey;key of row to search for;true
com.google.common.collect.Table;boolean containsColumn(Object columnKey);V get(Object rowKey, Object columnKey);@param;Object columnKey;Object columnKey;key of column to search for;true
com.google.common.collect.ObjectArrays;T[] newArray(Class type, int length);T[] newArray(T[] reference, int length);@param;int length;int length;the length of the new array;true
com.google.common.collect.ObjectArrays;T[] toArrayImpl(Collection c, T[] array);Object[] toArrayImpl(Collection c);@param;Collection<?> c;Collection<?> c;the collection for which to return an array of elements;true
com.google.common.collect.ArrayTable;ArrayTable create(Table table);void putAll(Table table);@throws;;;if table has a null key;true
com.google.common.collect.ArrayTable;V at(int rowIndex, int columnIndex);V set(int rowIndex, int columnIndex, V value);@param;int rowIndex;int rowIndex;position of the row key in rowKeyList();true
com.google.common.collect.ArrayTable;V at(int rowIndex, int columnIndex);V set(int rowIndex, int columnIndex, V value);@param;int columnIndex;int columnIndex;position of the row key in columnKeyList();true
com.google.common.collect.ArrayTable;V at(int rowIndex, int columnIndex);V set(int rowIndex, int columnIndex, V value);@throws;;;if either index is negative, rowIndex is greater then or equal to the number of allowed row keys, or columnIndex is greater then or equal to the number of allowed column keys;true
com.google.common.collect.ArrayTable;void clear();V remove(Object rowKey, Object columnKey);@throws;;;always;true
com.google.common.collect.Lists;List asList(E first, E[] rest);List asList(E first, E second, E[] rest);@return;;;an unmodifiable list containing the specified elements;true
com.google.common.collect.Lists;List asList(E first, E[] rest);List asList(E first, E second, E[] rest);@param;E first;E first;the first element;true
com.google.common.collect.Lists;List asList(E first, E[] rest);List asList(E first, E second, E[] rest);@param;E[] rest;E[] rest;an array of additional elements, possibly empty;true
com.google.common.collect.Lists;List cartesianProduct(List lists);List cartesianProduct(List lists);Whole;;;Returns every possible list that can be formed by choosing one element from each of the given lists in order, the "n-ary <a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian product</a>" of the lists. For example: <pre>   {@code   Lists.cartesianProduct(ImmutableList.of(       ImmutableList.of(1, 2),       ImmutableList.of("A", "B", "C")))}</pre> <p>returns a list containing six lists in the following order: <ul> <li>{@code ImmutableList.of(1, "A")} <li>{@code ImmutableList.of(1, "B")} <li>{@code ImmutableList.of(1, "C")} <li>{@code ImmutableList.of(2, "A")} <li>{@code ImmutableList.of(2, "B")} <li>{@code ImmutableList.of(2, "C")} </ul> <p>The result is guaranteed to be in the "traditional", lexicographical order for Cartesian products that you would get from nesting for loops: <pre>   {@code   for (B b0 : lists.get(0)) {     for (B b1 : lists.get(1)) {       ...       ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...),       // operate on tuple     }   }}</pre> <p>Note that if any input list is empty, the Cartesian product will also be empty. If no lists at all are provided (an empty list), the resulting Cartesian product has one element, an empty list (counter-intuitive, but mathematically consistent). <p><i>Performance notes:</i> while the cartesian product of lists of size {@code m, n, p} is a list of size {@code m x n x p}, its actual memory consumption is much smaller. When the cartesian product is constructed, the input lists are merely copied. Only as the resulting list is iterated are the individual lists created, and these are not retained after iteration.  @param the lists to choose elements from, in the order that the elements chosen from those lists should appear in the resulting lists @return the Cartesian product, as an immutable list containing immutable lists @throws if the size of the cartesian product would be greater than Integer#MAX_VALUE@throws if lists, any one of the lists, or any element of a provided list is null;false
com.google.common.collect.EvictingQueue;boolean offer(E e);boolean add(E e);Whole;;;Adds the given element to this queue. If the queue is currently full, the element at the head of the queue is evicted to make room.   @return true always ;false
com.google.common.collect.MapMakerInternalMap;boolean isExpired(ReferenceEntry entry);boolean isExpired(ReferenceEntry entry, long now);Whole;;;Returns {@code true} if the entry has expired.    ;false
com.google.common.collect.AbstractIndexedListIterator; AbstractIndexedListIterator(int size); AbstractIndexedListIterator(int size, int position);@throws;;;if size is negative;true
com.google.common.collect.Multisets;Multiset unmodifiableMultiset(Multiset multiset);SortedMultiset unmodifiableSortedMultiset(SortedMultiset sortedMultiset);@return;;;an unmodifiable view of the multiset;false
com.google.common.collect.Multisets;boolean retainOccurrences(Multiset multisetToModify, Multiset multisetToRetain);boolean removeOccurrences(Multiset multisetToModify, Iterable occurrencesToRemove);@return;;;true if multisetToModify was changed as a result of this operation;false
com.google.common.collect.Multisets;boolean retainOccurrences(Multiset multisetToModify, Multiset multisetToRetain);boolean removeOccurrences(Multiset multisetToModify, Multiset occurrencesToRemove);@return;;;true if multisetToModify was changed as a result of this operation;false
com.google.common.collect.Multisets;boolean removeOccurrences(Multiset multisetToModify, Iterable occurrencesToRemove);boolean removeOccurrences(Multiset multisetToModify, Multiset occurrencesToRemove);@return;;;true if multisetToModify was changed as a result of this operation;true
com.google.common.collect.ImmutableTable;void clear();V put(R rowKey, C columnKey, V value);Whole;;;Guaranteed to throw an exception and leave the table unmodified.    @throws always;false
com.google.common.collect.ImmutableTable;void clear();void putAll(Table table);Whole;;;Guaranteed to throw an exception and leave the table unmodified.    @throws always;false
com.google.common.collect.ImmutableTable;void clear();V remove(Object rowKey, Object columnKey);Whole;;;Guaranteed to throw an exception and leave the table unmodified.    @throws always;false
com.google.common.collect.ImmutableTable;V put(R rowKey, C columnKey, V value);void putAll(Table table);Whole;;;Guaranteed to throw an exception and leave the table unmodified.    @throws always;false
com.google.common.collect.ImmutableTable;V put(R rowKey, C columnKey, V value);V remove(Object rowKey, Object columnKey);Whole;;;Guaranteed to throw an exception and leave the table unmodified.    @throws always;false
com.google.common.collect.ImmutableTable;void putAll(Table table);V remove(Object rowKey, Object columnKey);Whole;;;Guaranteed to throw an exception and leave the table unmodified.    @throws always;false
com.google.common.collect.Tables;Table unmodifiableTable(Table table);RowSortedTable unmodifiableRowSortedTable(RowSortedTable table);@return;;;an unmodifiable view of the specified table;false
com.google.common.collect.ListMultimap;List get(K key);List removeAll(Object key);Whole;;;{@inheritDoc} <p>Because the values for a given key may have duplicates and follow the insertion ordering, this method returns a {@link List}, instead of the {@link java.util.Collection} specified in the {@link Multimap} interface.    ;false
com.google.common.collect.ListMultimap;List get(K key);List replaceValues(K key, Iterable values);Whole;;;{@inheritDoc} <p>Because the values for a given key may have duplicates and follow the insertion ordering, this method returns a {@link List}, instead of the {@link java.util.Collection} specified in the {@link Multimap} interface.    ;false
com.google.common.collect.ListMultimap;List removeAll(Object key);List replaceValues(K key, Iterable values);Whole;;;{@inheritDoc} <p>Because the values for a given key may have duplicates and follow the insertion ordering, this method returns a {@link List}, instead of the {@link java.util.Collection} specified in the {@link Multimap} interface.    ;false
com.google.common.collect.Multimaps;Multimap newMultimap(Map map, Supplier factory);ListMultimap newListMultimap(Map map, Supplier factory);@param;Map<K,Collection<V>> map;Map<K,Collection<V>> map;place to store the mapping from each key to its corresponding values;true
com.google.common.collect.Multimaps;Multimap newMultimap(Map map, Supplier factory);ListMultimap newListMultimap(Map map, Supplier factory);@throws;;;if map is not empty;true
com.google.common.collect.Multimaps;Multimap newMultimap(Map map, Supplier factory);SetMultimap newSetMultimap(Map map, Supplier factory);@param;Map<K,Collection<V>> map;Map<K,Collection<V>> map;place to store the mapping from each key to its corresponding values;true
com.google.common.collect.Multimaps;Multimap newMultimap(Map map, Supplier factory);SetMultimap newSetMultimap(Map map, Supplier factory);@throws;;;if map is not empty;true
com.google.common.collect.Multimaps;Multimap newMultimap(Map map, Supplier factory);SortedSetMultimap newSortedSetMultimap(Map map, Supplier factory);@param;Map<K,Collection<V>> map;Map<K,Collection<V>> map;place to store the mapping from each key to its corresponding values;true
com.google.common.collect.Multimaps;Multimap newMultimap(Map map, Supplier factory);SortedSetMultimap newSortedSetMultimap(Map map, Supplier factory);@throws;;;if map is not empty;true
com.google.common.collect.Multimaps;ListMultimap newListMultimap(Map map, Supplier factory);SetMultimap newSetMultimap(Map map, Supplier factory);@param;Map<K,Collection<V>> map;Map<K,Collection<V>> map;place to store the mapping from each key to its corresponding values;true
com.google.common.collect.Multimaps;ListMultimap newListMultimap(Map map, Supplier factory);SetMultimap newSetMultimap(Map map, Supplier factory);@throws;;;if map is not empty;true
com.google.common.collect.Multimaps;ListMultimap newListMultimap(Map map, Supplier factory);SortedSetMultimap newSortedSetMultimap(Map map, Supplier factory);@param;Map<K,Collection<V>> map;Map<K,Collection<V>> map;place to store the mapping from each key to its corresponding values;true
com.google.common.collect.Multimaps;ListMultimap newListMultimap(Map map, Supplier factory);SortedSetMultimap newSortedSetMultimap(Map map, Supplier factory);@throws;;;if map is not empty;true
com.google.common.collect.Multimaps;SetMultimap newSetMultimap(Map map, Supplier factory);SortedSetMultimap newSortedSetMultimap(Map map, Supplier factory);@param;Map<K,Collection<V>> map;Map<K,Collection<V>> map;place to store the mapping from each key to its corresponding values;true
com.google.common.collect.Multimaps;SetMultimap newSetMultimap(Map map, Supplier factory);SortedSetMultimap newSortedSetMultimap(Map map, Supplier factory);@throws;;;if map is not empty;true
com.google.common.collect.Multimaps;Multimap synchronizedMultimap(Multimap multimap);SetMultimap synchronizedSetMultimap(SetMultimap multimap);@return;;;a synchronized view of the specified multimap;false
com.google.common.collect.Multimaps;Multimap synchronizedMultimap(Multimap multimap);SortedSetMultimap synchronizedSortedSetMultimap(SortedSetMultimap multimap);@return;;;a synchronized view of the specified multimap;false
com.google.common.collect.Multimaps;Multimap synchronizedMultimap(Multimap multimap);ListMultimap synchronizedListMultimap(ListMultimap multimap);@return;;;a synchronized view of the specified multimap;false
com.google.common.collect.Multimaps;Multimap unmodifiableMultimap(Multimap delegate);SetMultimap unmodifiableSetMultimap(SetMultimap delegate);@return;;;an unmodifiable view of the specified multimap;false
com.google.common.collect.Multimaps;Multimap unmodifiableMultimap(Multimap delegate);SetMultimap unmodifiableSetMultimap(SetMultimap delegate);@param;Multimap<K,V> delegate;SetMultimap<K,V> delegate;the multimap for which an unmodifiable view is to be returned;true
com.google.common.collect.Multimaps;Multimap unmodifiableMultimap(Multimap delegate);SortedSetMultimap unmodifiableSortedSetMultimap(SortedSetMultimap delegate);@return;;;an unmodifiable view of the specified multimap;false
com.google.common.collect.Multimaps;Multimap unmodifiableMultimap(Multimap delegate);SortedSetMultimap unmodifiableSortedSetMultimap(SortedSetMultimap delegate);@param;Multimap<K,V> delegate;SortedSetMultimap<K,V> delegate;the multimap for which an unmodifiable view is to be returned;true
com.google.common.collect.Multimaps;Multimap unmodifiableMultimap(Multimap delegate);ListMultimap unmodifiableListMultimap(ListMultimap delegate);@return;;;an unmodifiable view of the specified multimap;false
com.google.common.collect.Multimaps;Multimap unmodifiableMultimap(Multimap delegate);ListMultimap unmodifiableListMultimap(ListMultimap delegate);@param;Multimap<K,V> delegate;ListMultimap<K,V> delegate;the multimap for which an unmodifiable view is to be returned;true
com.google.common.collect.Multimaps;Multimap unmodifiableMultimap(ImmutableMultimap delegate);SetMultimap unmodifiableSetMultimap(ImmutableSetMultimap delegate);Whole;;;Simply returns its argument. @deprecated no need to use this    ;false
com.google.common.collect.Multimaps;Multimap unmodifiableMultimap(ImmutableMultimap delegate);ListMultimap unmodifiableListMultimap(ImmutableListMultimap delegate);Whole;;;Simply returns its argument. @deprecated no need to use this    ;false
com.google.common.collect.Multimaps;SetMultimap synchronizedSetMultimap(SetMultimap multimap);SortedSetMultimap synchronizedSortedSetMultimap(SortedSetMultimap multimap);@return;;;a synchronized view of the specified multimap;false
com.google.common.collect.Multimaps;SetMultimap synchronizedSetMultimap(SetMultimap multimap);SortedSetMultimap synchronizedSortedSetMultimap(SortedSetMultimap multimap);@param;SetMultimap<K,V> multimap;SortedSetMultimap<K,V> multimap;the multimap to be wrapped;true
com.google.common.collect.Multimaps;SetMultimap synchronizedSetMultimap(SetMultimap multimap);ListMultimap synchronizedListMultimap(ListMultimap multimap);@return;;;a synchronized view of the specified multimap;false
com.google.common.collect.Multimaps;SetMultimap synchronizedSetMultimap(SetMultimap multimap);ListMultimap synchronizedListMultimap(ListMultimap multimap);@param;SetMultimap<K,V> multimap;ListMultimap<K,V> multimap;the multimap to be wrapped;true
com.google.common.collect.Multimaps;SetMultimap unmodifiableSetMultimap(SetMultimap delegate);SortedSetMultimap unmodifiableSortedSetMultimap(SortedSetMultimap delegate);@return;;;an unmodifiable view of the specified multimap;false
com.google.common.collect.Multimaps;SetMultimap unmodifiableSetMultimap(SetMultimap delegate);SortedSetMultimap unmodifiableSortedSetMultimap(SortedSetMultimap delegate);@param;SetMultimap<K,V> delegate;SortedSetMultimap<K,V> delegate;the multimap for which an unmodifiable view is to be returned;true
com.google.common.collect.Multimaps;SetMultimap unmodifiableSetMultimap(SetMultimap delegate);ListMultimap unmodifiableListMultimap(ListMultimap delegate);@return;;;an unmodifiable view of the specified multimap;false
com.google.common.collect.Multimaps;SetMultimap unmodifiableSetMultimap(SetMultimap delegate);ListMultimap unmodifiableListMultimap(ListMultimap delegate);@param;SetMultimap<K,V> delegate;ListMultimap<K,V> delegate;the multimap for which an unmodifiable view is to be returned;true
com.google.common.collect.Multimaps;SetMultimap unmodifiableSetMultimap(ImmutableSetMultimap delegate);ListMultimap unmodifiableListMultimap(ImmutableListMultimap delegate);Whole;;;Simply returns its argument. @deprecated no need to use this    ;false
com.google.common.collect.Multimaps;SortedSetMultimap synchronizedSortedSetMultimap(SortedSetMultimap multimap);ListMultimap synchronizedListMultimap(ListMultimap multimap);@return;;;a synchronized view of the specified multimap;false
com.google.common.collect.Multimaps;SortedSetMultimap synchronizedSortedSetMultimap(SortedSetMultimap multimap);ListMultimap synchronizedListMultimap(ListMultimap multimap);@param;SortedSetMultimap<K,V> multimap;ListMultimap<K,V> multimap;the multimap to be wrapped;true
com.google.common.collect.Multimaps;SortedSetMultimap unmodifiableSortedSetMultimap(SortedSetMultimap delegate);ListMultimap unmodifiableListMultimap(ListMultimap delegate);@return;;;an unmodifiable view of the specified multimap;false
com.google.common.collect.Multimaps;SortedSetMultimap unmodifiableSortedSetMultimap(SortedSetMultimap delegate);ListMultimap unmodifiableListMultimap(ListMultimap delegate);@param;SortedSetMultimap<K,V> delegate;ListMultimap<K,V> delegate;the multimap for which an unmodifiable view is to be returned;true
com.google.common.collect.Multimaps;ImmutableListMultimap index(Iterable values, Function keyFunction);ImmutableListMultimap index(Iterator values, Function keyFunction);@return;;;ImmutableListMultimap mapping the result of evaluating the function keyFunction on each value in the input collection to that value;true
com.google.common.collect.Multimaps;ImmutableListMultimap index(Iterable values, Function keyFunction);ImmutableListMultimap index(Iterator values, Function keyFunction);@param;Iterable<V> values;Iterator<V> values;the values to use when constructing the ImmutableListMultimap;true
com.google.common.collect.Multimaps;ImmutableListMultimap index(Iterable values, Function keyFunction);ImmutableListMultimap index(Iterator values, Function keyFunction);@param;Function<? super V,K> keyFunction;Function<? super V,K> keyFunction;the function used to produce the key for each value;true
com.google.common.collect.Multimaps;ImmutableListMultimap index(Iterable values, Function keyFunction);ImmutableListMultimap index(Iterator values, Function keyFunction);@throws;;;if any of the following cases is true:  <li>values is null <li>keyFunction is null <li>An element in values is null <li>keyFunction returns null for any element of values;true
com.google.common.collect.Multimaps;Multimap filterKeys(Multimap unfiltered, Predicate keyPredicate);SetMultimap filterKeys(SetMultimap unfiltered, Predicate keyPredicate);Whole;;;Returns a multimap containing the mappings in {@code unfiltered} whose keys satisfy a predicate. The returned multimap is a live view of {@code unfiltered}, changes to one affect the other. <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all other methods are supported by the multimap and its views. When adding a key that doesn't satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()} methods throw an {@link IllegalArgumentException}. <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered multimap or its views, only mappings whose keys satisfy the filter will be removed from the underlying multimap. <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is. <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every key/value mapping in the underlying multimap and determine which satisfy the filter. When a live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the copy. <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at {@link Predicate#apply}. Do not provide a predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.    ;false
com.google.common.collect.Multimaps;Multimap filterKeys(Multimap unfiltered, Predicate keyPredicate);ListMultimap filterKeys(ListMultimap unfiltered, Predicate keyPredicate);Whole;;;Returns a multimap containing the mappings in {@code unfiltered} whose keys satisfy a predicate. The returned multimap is a live view of {@code unfiltered}, changes to one affect the other. <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all other methods are supported by the multimap and its views. When adding a key that doesn't satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()} methods throw an {@link IllegalArgumentException}. <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered multimap or its views, only mappings whose keys satisfy the filter will be removed from the underlying multimap. <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is. <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every key/value mapping in the underlying multimap and determine which satisfy the filter. When a live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the copy. <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at {@link Predicate#apply}. Do not provide a predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.    ;false
com.google.common.collect.Multimaps;SetMultimap filterKeys(SetMultimap unfiltered, Predicate keyPredicate);ListMultimap filterKeys(ListMultimap unfiltered, Predicate keyPredicate);Whole;;;Returns a multimap containing the mappings in {@code unfiltered} whose keys satisfy a predicate. The returned multimap is a live view of {@code unfiltered}, changes to one affect the other. <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all other methods are supported by the multimap and its views. When adding a key that doesn't satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()} methods throw an {@link IllegalArgumentException}. <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered multimap or its views, only mappings whose keys satisfy the filter will be removed from the underlying multimap. <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is. <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every key/value mapping in the underlying multimap and determine which satisfy the filter. When a live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the copy. <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at {@link Predicate#apply}. Do not provide a predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.    ;false
com.google.common.collect.Multimaps;Multimap filterValues(Multimap unfiltered, Predicate valuePredicate);SetMultimap filterValues(SetMultimap unfiltered, Predicate valuePredicate);Whole;;;Returns a multimap containing the mappings in {@code unfiltered} whose values satisfy a predicate. The returned multimap is a live view of {@code unfiltered}, changes to one affect the other. <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all other methods are supported by the multimap and its views. When adding a value that doesn't satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()} methods throw an {@link IllegalArgumentException}. <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered multimap or its views, only mappings whose value satisfy the filter will be removed from the underlying multimap. <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is. <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every key/value mapping in the underlying multimap and determine which satisfy the filter. When a live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the copy. <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with equals</i>, as documented at {@link Predicate#apply}. Do not provide a predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.    ;false
com.google.common.collect.Multimaps;Multimap filterEntries(Multimap unfiltered, Predicate entryPredicate);SetMultimap filterEntries(SetMultimap unfiltered, Predicate entryPredicate);Whole;;;Returns a multimap containing the mappings in {@code unfiltered} that satisfy a predicate. The returned multimap is a live view of {@code unfiltered}, changes to one affect the other. <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all other methods are supported by the multimap and its views. When adding a key/value pair that doesn't satisfy the predicate, multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()} methods throw an {@link IllegalArgumentException}. <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered multimap or its views, only mappings whose keys satisfy the filter will be removed from the underlying multimap. <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is. <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every key/value mapping in the underlying multimap and determine which satisfy the filter. When a live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the copy. <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals</i>, as documented at {@link Predicate#apply}.    ;false
com.google.common.collect.MinMaxPriorityQueue;boolean add(E element);boolean offer(E element);Free text;;;Adds the given element to this queue. If this queue has a maximum size, after adding {@code element} the queue will automatically evict its greatest element (according to its comparator), which may be {@code element} itself. ;false
com.google.common.collect.MinMaxPriorityQueue;E removeFirst();E removeLast();@throws;;;if the queue is empty;true
com.google.common.collect.ImmutableSortedMapFauxverideShim;ImmutableSortedMap.Builder builder();ImmutableSortedMap of(K k1, V v1);@throws;;;always;true
com.google.common.collect.ImmutableSortedMapFauxverideShim;ImmutableSortedMap.Builder builder();ImmutableSortedMap of(K k1, V v1, K k2, V v2);@throws;;;always;true
com.google.common.collect.ImmutableSortedMapFauxverideShim;ImmutableSortedMap.Builder builder();ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3);@throws;;;always;true
com.google.common.collect.ImmutableSortedMapFauxverideShim;ImmutableSortedMap.Builder builder();ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);@throws;;;always;true
com.google.common.collect.ImmutableSortedMapFauxverideShim;ImmutableSortedMap.Builder builder();ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);@throws;;;always;true
com.google.common.collect.ImmutableSortedMapFauxverideShim;ImmutableSortedMap of(K k1, V v1);ImmutableSortedMap of(K k1, V v1, K k2, V v2);@throws;;;always;true
com.google.common.collect.ImmutableSortedMapFauxverideShim;ImmutableSortedMap of(K k1, V v1);ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3);@throws;;;always;true
com.google.common.collect.ImmutableSortedMapFauxverideShim;ImmutableSortedMap of(K k1, V v1);ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);@throws;;;always;true
com.google.common.collect.ImmutableSortedMapFauxverideShim;ImmutableSortedMap of(K k1, V v1);ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);@throws;;;always;true
com.google.common.collect.ImmutableSortedMapFauxverideShim;ImmutableSortedMap of(K k1, V v1, K k2, V v2);ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3);@throws;;;always;true
com.google.common.collect.ImmutableSortedMapFauxverideShim;ImmutableSortedMap of(K k1, V v1, K k2, V v2);ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);Whole;;;Not supported. <b>You are attempting to create a map that may contain non-{@code Comparable} keys.</b> Proper calls will resolve to the version in {@code ImmutableSortedMap}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedMapFauxverideShim;ImmutableSortedMap of(K k1, V v1, K k2, V v2);ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);Whole;;;Not supported. <b>You are attempting to create a map that may contain non-{@code Comparable} keys.</b> Proper calls will resolve to the version in {@code ImmutableSortedMap}, not this dummy version.    @throws always;false
com.google.common.collect.ImmutableSortedMapFauxverideShim;ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3);ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);@throws;;;always;true
com.google.common.collect.ImmutableSortedMapFauxverideShim;ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3);ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);@throws;;;always;true
com.google.common.collect.ImmutableSortedMapFauxverideShim;ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);ImmutableSortedMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);Whole;;;Not supported. <b>You are attempting to create a map that may contain non-{@code Comparable} keys.</b> Proper calls will resolve to the version in {@code ImmutableSortedMap}, not this dummy version.    @throws always;false
com.google.common.collect.SetMultimap;Set get(K key);Set removeAll(Object key);Whole;;;{@inheritDoc} <p>Because a {@code SetMultimap} has unique values for a given key, this method returns a {@link Set}, instead of the {@link java.util.Collection} specified in the {@link Multimap} interface.    ;false
com.google.common.collect.SetMultimap;Set get(K key);Set entries();Whole;;;{@inheritDoc} <p>Because a {@code SetMultimap} has unique values for a given key, this method returns a {@link Set}, instead of the {@link java.util.Collection} specified in the {@link Multimap} interface.    ;false
com.google.common.collect.SetMultimap;Set removeAll(Object key);Set entries();Whole;;;{@inheritDoc} <p>Because a {@code SetMultimap} has unique values for a given key, this method returns a {@link Set}, instead of the {@link java.util.Collection} specified in the {@link Multimap} interface.    ;false
com.google.common.collect.Range;Range closed(C lower, C upper);Range closedOpen(C lower, C upper);@throws;;;if lower is greater than upper;true
com.google.common.collect.Range;Range closed(C lower, C upper);Range openClosed(C lower, C upper);@throws;;;if lower is greater than upper;true
com.google.common.collect.Range;Range closed(C lower, C upper);Range range(C lower, BoundType lowerType, C upper, BoundType upperType);@throws;;;if lower is greater than upper;true
com.google.common.collect.Range;Range closedOpen(C lower, C upper);Range openClosed(C lower, C upper);@throws;;;if lower is greater than upper;true
com.google.common.collect.Range;Range closedOpen(C lower, C upper);Range range(C lower, BoundType lowerType, C upper, BoundType upperType);@throws;;;if lower is greater than upper;true
com.google.common.collect.Range;Range openClosed(C lower, C upper);Range range(C lower, BoundType lowerType, C upper, BoundType upperType);@throws;;;if lower is greater than upper;true
com.google.common.collect.Range;C lowerEndpoint();BoundType lowerBoundType();@throws;;;if this range is unbounded below (that is, hasLowerBound() returns false);true
com.google.common.collect.Range;C upperEndpoint();BoundType upperBoundType();@throws;;;if this range is unbounded above (that is, hasUpperBound() returns false);true
com.google.common.collect.FluentIterable;ImmutableList toSortedList(Comparator comparator);ImmutableSortedSet toSortedSet(Comparator comparator);@throws;;;if any element is null;true
com.google.common.collect.FluentIterable;ImmutableListMultimap index(Function keyFunction);ImmutableMap uniqueIndex(Function keyFunction);@param;Function<? super E,K> keyFunction;Function<? super E,K> keyFunction;the function used to produce the key for each value;true
com.google.common.collect.UnmodifiableListIterator;void add(E e);void set(E e);Whole;;;Guaranteed to throw an exception and leave the underlying data unmodified.    @throws always;false
com.google.common.collect.AbstractListMultimap;List get(K key);List removeAll(Object key);Whole;;;{@inheritDoc} <p>Because the values for a given key may have duplicates and follow the insertion ordering, this method returns a {@link List}, instead of the {@link Collection} specified in the {@link Multimap} interface.    ;false
com.google.common.collect.AbstractListMultimap;List get(K key);List replaceValues(K key, Iterable values);Whole;;;{@inheritDoc} <p>Because the values for a given key may have duplicates and follow the insertion ordering, this method returns a {@link List}, instead of the {@link Collection} specified in the {@link Multimap} interface.    ;false
com.google.common.collect.AbstractListMultimap;List removeAll(Object key);List replaceValues(K key, Iterable values);Whole;;;{@inheritDoc} <p>Because the values for a given key may have duplicates and follow the insertion ordering, this method returns a {@link List}, instead of the {@link Collection} specified in the {@link Multimap} interface.    ;false
com.google.common.collect.Ordering;Ordering explicit(List valuesInOrder);Ordering explicit(T leastValue, T remainingValuesInOrder);@return;;;the comparator described above;true
com.google.common.collect.Ordering;Ordering explicit(List valuesInOrder);Ordering explicit(T leastValue, T remainingValuesInOrder);@throws;;;if any of the provided values is null;true
com.google.common.collect.Ordering;E min(Iterator iterator);E min(Iterable iterable);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E min(Iterator iterator);E min(E a, E b);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E min(Iterator iterator);E min(E a, E b, E c, E rest);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E min(Iterator iterator);E max(Iterator iterator);@throws;;;if iterator is empty;true
com.google.common.collect.Ordering;E min(Iterator iterator);E max(Iterator iterator);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E min(Iterator iterator);E max(Iterable iterable);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E min(Iterator iterator);E max(E a, E b);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E min(Iterator iterator);E max(E a, E b, E c, E rest);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E min(Iterable iterable);E min(E a, E b);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E min(Iterable iterable);E min(E a, E b, E c, E rest);Free text;;;Returns the least of the specified values according to this ordering. If there are multiple least values, the first of those is returned. ;true
com.google.common.collect.Ordering;E min(Iterable iterable);E min(E a, E b, E c, E rest);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E min(Iterable iterable);E max(Iterator iterator);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E min(Iterable iterable);E max(Iterable iterable);@throws;;;if iterable is empty;true
com.google.common.collect.Ordering;E min(Iterable iterable);E max(Iterable iterable);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E min(Iterable iterable);E max(E a, E b);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E min(Iterable iterable);E max(E a, E b, E c, E rest);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E min(E a, E b);E min(E a, E b, E c, E rest);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E min(E a, E b);E max(Iterator iterator);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E min(E a, E b);E max(Iterable iterable);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E min(E a, E b);E max(E a, E b);@param;E b;E b;value to compare.;true
com.google.common.collect.Ordering;E min(E a, E b);E max(E a, E b);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E min(E a, E b);E max(E a, E b, E c, E rest);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E min(E a, E b, E c, E rest);E max(Iterator iterator);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E min(E a, E b, E c, E rest);E max(Iterable iterable);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E min(E a, E b, E c, E rest);E max(E a, E b);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E min(E a, E b, E c, E rest);E max(E a, E b, E c, E rest);@param;E b;E b;value to compare;true
com.google.common.collect.Ordering;E min(E a, E b, E c, E rest);E max(E a, E b, E c, E rest);@param;E b;E c;value to compare;false
com.google.common.collect.Ordering;E min(E a, E b, E c, E rest);E max(E a, E b, E c, E rest);@param;E c;E b;value to compare;false
com.google.common.collect.Ordering;E min(E a, E b, E c, E rest);E max(E a, E b, E c, E rest);@param;E c;E c;value to compare;true
com.google.common.collect.Ordering;E min(E a, E b, E c, E rest);E max(E a, E b, E c, E rest);@param;E rest;E rest;values to compare;true
com.google.common.collect.Ordering;E min(E a, E b, E c, E rest);E max(E a, E b, E c, E rest);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E max(Iterator iterator);E max(Iterable iterable);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E max(Iterator iterator);E max(E a, E b);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E max(Iterator iterator);E max(E a, E b, E c, E rest);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E max(Iterable iterable);E max(E a, E b);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E max(Iterable iterable);E max(E a, E b, E c, E rest);Free text;;;Returns the greatest of the specified values according to this ordering. If there are multiple greatest values, the first of those is returned. ;true
com.google.common.collect.Ordering;E max(Iterable iterable);E max(E a, E b, E c, E rest);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;E max(E a, E b);E max(E a, E b, E c, E rest);@throws;;;if the parameters are not mutually comparable under this ordering.;true
com.google.common.collect.Ordering;List leastOf(Iterable iterable, int k);List leastOf(Iterator elements, int k);@return;;;an immutable RandomAccess list of the k least elements in ascending order;true
com.google.common.collect.Ordering;List leastOf(Iterable iterable, int k);List leastOf(Iterator elements, int k);@throws;;;if k is negative;true
com.google.common.collect.Ordering;List leastOf(Iterable iterable, int k);List greatestOf(Iterable iterable, int k);@throws;;;if k is negative;true
com.google.common.collect.Ordering;List leastOf(Iterable iterable, int k);List greatestOf(Iterator iterator, int k);@throws;;;if k is negative;true
com.google.common.collect.Ordering;List leastOf(Iterator elements, int k);List greatestOf(Iterable iterable, int k);@throws;;;if k is negative;true
com.google.common.collect.Ordering;List leastOf(Iterator elements, int k);List greatestOf(Iterator iterator, int k);@throws;;;if k is negative;true
com.google.common.collect.Ordering;List greatestOf(Iterable iterable, int k);List greatestOf(Iterator iterator, int k);@return;;;an immutable RandomAccess list of the k greatest elements in descending order;true
com.google.common.collect.Ordering;List greatestOf(Iterable iterable, int k);List greatestOf(Iterator iterator, int k);@throws;;;if k is negative;true
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2);ImmutableList of(E e1, E e2, E e3);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2);ImmutableList of(E e1, E e2, E e3, E e4);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2);ImmutableList of(E e1, E e2, E e3, E e4, E e5);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E others);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2);ImmutableList copyOf(Iterator elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2);ImmutableList copyOf(E[] elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3);ImmutableList of(E e1, E e2, E e3, E e4);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3);ImmutableList of(E e1, E e2, E e3, E e4, E e5);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E others);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3);ImmutableList copyOf(Iterator elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3);ImmutableList copyOf(E[] elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4);ImmutableList of(E e1, E e2, E e3, E e4, E e5);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E others);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4);ImmutableList copyOf(Iterator elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4);ImmutableList copyOf(E[] elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E others);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5);ImmutableList copyOf(Iterator elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5);ImmutableList copyOf(E[] elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E others);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6);ImmutableList copyOf(Iterator elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6);ImmutableList copyOf(E[] elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E others);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7);ImmutableList copyOf(Iterator elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7);ImmutableList copyOf(E[] elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E others);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8);ImmutableList copyOf(Iterator elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8);ImmutableList copyOf(E[] elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E others);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9);ImmutableList copyOf(Iterator elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9);ImmutableList copyOf(E[] elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E others);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10);ImmutableList copyOf(Iterator elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10);ImmutableList copyOf(E[] elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11);ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E others);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any element is null;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11);ImmutableList copyOf(Iterator elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11);ImmutableList copyOf(E[] elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E others);ImmutableList copyOf(Iterator elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E others);ImmutableList copyOf(E[] elements);Free text;;;Returns an immutable list containing the given elements, in order. ;false
com.google.common.collect.ImmutableList;ImmutableList copyOf(Iterable elements);ImmutableList copyOf(Collection elements);@throws;;;if any of elements is null;true
com.google.common.collect.ImmutableList;ImmutableList copyOf(Iterable elements);ImmutableList copyOf(Iterator elements);@throws;;;if any of elements is null;true
com.google.common.collect.ImmutableList;ImmutableList copyOf(Iterable elements);ImmutableList copyOf(E[] elements);@throws;;;if any of elements is null;true
com.google.common.collect.ImmutableList;ImmutableList copyOf(Collection elements);ImmutableList copyOf(Iterator elements);@throws;;;if any of elements is null;true
com.google.common.collect.ImmutableList;ImmutableList copyOf(Collection elements);ImmutableList copyOf(E[] elements);@throws;;;if any of elements is null;true
com.google.common.collect.ImmutableList;ImmutableList copyOf(Iterator elements);ImmutableList copyOf(E[] elements);Whole;;;Returns an immutable list containing the given elements, in order.    @throws if any of elements is null;false
com.google.common.collect.ImmutableList;boolean addAll(int index, Collection newElements);E set(int index, E element);Whole;;;Guaranteed to throw an exception and leave the list unmodified.    @throws always;false
com.google.common.collect.ImmutableList;boolean addAll(int index, Collection newElements);void add(int index, E element);Whole;;;Guaranteed to throw an exception and leave the list unmodified.    @throws always;false
com.google.common.collect.ImmutableList;boolean addAll(int index, Collection newElements);E remove(int index);Whole;;;Guaranteed to throw an exception and leave the list unmodified.    @throws always;false
com.google.common.collect.ImmutableList;E set(int index, E element);void add(int index, E element);Whole;;;Guaranteed to throw an exception and leave the list unmodified.    @throws always;false
com.google.common.collect.ImmutableList;E set(int index, E element);E remove(int index);Whole;;;Guaranteed to throw an exception and leave the list unmodified.    @throws always;false
com.google.common.collect.ImmutableList;void add(int index, E element);E remove(int index);Whole;;;Guaranteed to throw an exception and leave the list unmodified.    @throws always;false
com.google.common.collect.ImmutableMap;ImmutableMap of(K k1, V v1, K k2, V v2);ImmutableMap of(K k1, V v1, K k2, V v2, K k3, V v3);Whole;;;Returns an immutable map containing the given entries, in order.    @throws if duplicate keys are provided;false
com.google.common.collect.ImmutableMap;ImmutableMap of(K k1, V v1, K k2, V v2);ImmutableMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);Whole;;;Returns an immutable map containing the given entries, in order.    @throws if duplicate keys are provided;false
com.google.common.collect.ImmutableMap;ImmutableMap of(K k1, V v1, K k2, V v2);ImmutableMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);Whole;;;Returns an immutable map containing the given entries, in order.    @throws if duplicate keys are provided;false
com.google.common.collect.ImmutableMap;ImmutableMap of(K k1, V v1, K k2, V v2, K k3, V v3);ImmutableMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);Whole;;;Returns an immutable map containing the given entries, in order.    @throws if duplicate keys are provided;false
com.google.common.collect.ImmutableMap;ImmutableMap of(K k1, V v1, K k2, V v2, K k3, V v3);ImmutableMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);Whole;;;Returns an immutable map containing the given entries, in order.    @throws if duplicate keys are provided;false
com.google.common.collect.ImmutableMap;ImmutableMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);ImmutableMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);Whole;;;Returns an immutable map containing the given entries, in order.    @throws if duplicate keys are provided;false
com.google.common.collect.ImmutableMap;V put(K k, V v);V remove(Object o);Whole;;;Guaranteed to throw an exception and leave the map unmodified.    @throws always;false
com.google.common.collect.ImmutableMap;V put(K k, V v);void putAll(Map map);Whole;;;Guaranteed to throw an exception and leave the map unmodified.    @throws always;false
com.google.common.collect.ImmutableMap;V put(K k, V v);void clear();Whole;;;Guaranteed to throw an exception and leave the map unmodified.    @throws always;false
com.google.common.collect.ImmutableMap;V remove(Object o);void putAll(Map map);Whole;;;Guaranteed to throw an exception and leave the map unmodified.    @throws always;false
com.google.common.collect.ImmutableMap;V remove(Object o);void clear();Whole;;;Guaranteed to throw an exception and leave the map unmodified.    @throws always;false
com.google.common.collect.ImmutableMap;void putAll(Map map);void clear();Whole;;;Guaranteed to throw an exception and leave the map unmodified.    @throws always;false
com.google.common.collect.ImmutableCollection;boolean add(E e);boolean remove(Object object);Whole;;;Guaranteed to throw an exception and leave the collection unmodified.    @throws always;false
com.google.common.collect.ImmutableCollection;boolean add(E e);boolean addAll(Collection newElements);Whole;;;Guaranteed to throw an exception and leave the collection unmodified.    @throws always;false
com.google.common.collect.ImmutableCollection;boolean add(E e);boolean removeAll(Collection oldElements);Whole;;;Guaranteed to throw an exception and leave the collection unmodified.    @throws always;false
com.google.common.collect.ImmutableCollection;boolean add(E e);boolean retainAll(Collection elementsToKeep);Whole;;;Guaranteed to throw an exception and leave the collection unmodified.    @throws always;false
com.google.common.collect.ImmutableCollection;boolean add(E e);void clear();Whole;;;Guaranteed to throw an exception and leave the collection unmodified.    @throws always;false
com.google.common.collect.ImmutableCollection;boolean remove(Object object);boolean addAll(Collection newElements);Whole;;;Guaranteed to throw an exception and leave the collection unmodified.    @throws always;false
com.google.common.collect.ImmutableCollection;boolean remove(Object object);boolean removeAll(Collection oldElements);Whole;;;Guaranteed to throw an exception and leave the collection unmodified.    @throws always;false
com.google.common.collect.ImmutableCollection;boolean remove(Object object);boolean retainAll(Collection elementsToKeep);Whole;;;Guaranteed to throw an exception and leave the collection unmodified.    @throws always;false
com.google.common.collect.ImmutableCollection;boolean remove(Object object);void clear();Whole;;;Guaranteed to throw an exception and leave the collection unmodified.    @throws always;false
com.google.common.collect.ImmutableCollection;boolean addAll(Collection newElements);boolean removeAll(Collection oldElements);Whole;;;Guaranteed to throw an exception and leave the collection unmodified.    @throws always;false
com.google.common.collect.ImmutableCollection;boolean addAll(Collection newElements);boolean retainAll(Collection elementsToKeep);Whole;;;Guaranteed to throw an exception and leave the collection unmodified.    @throws always;false
com.google.common.collect.ImmutableCollection;boolean addAll(Collection newElements);void clear();Whole;;;Guaranteed to throw an exception and leave the collection unmodified.    @throws always;false
com.google.common.collect.ImmutableCollection;boolean removeAll(Collection oldElements);boolean retainAll(Collection elementsToKeep);Whole;;;Guaranteed to throw an exception and leave the collection unmodified.    @throws always;false
com.google.common.collect.ImmutableCollection;boolean removeAll(Collection oldElements);void clear();Whole;;;Guaranteed to throw an exception and leave the collection unmodified.    @throws always;false
com.google.common.collect.ImmutableCollection;boolean retainAll(Collection elementsToKeep);void clear();Whole;;;Guaranteed to throw an exception and leave the collection unmodified.    @throws always;false
com.google.common.collect.ImmutableListMultimap;ImmutableListMultimap of(K k1, V v1, K k2, V v2);ImmutableListMultimap of(K k1, V v1, K k2, V v2, K k3, V v3);Whole;;;Returns an immutable multimap containing the given entries, in order.    ;false
com.google.common.collect.ImmutableListMultimap;ImmutableListMultimap of(K k1, V v1, K k2, V v2);ImmutableListMultimap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);Whole;;;Returns an immutable multimap containing the given entries, in order.    ;false
com.google.common.collect.ImmutableListMultimap;ImmutableListMultimap of(K k1, V v1, K k2, V v2);ImmutableListMultimap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);Whole;;;Returns an immutable multimap containing the given entries, in order.    ;false
com.google.common.collect.ImmutableListMultimap;ImmutableListMultimap of(K k1, V v1, K k2, V v2, K k3, V v3);ImmutableListMultimap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);Whole;;;Returns an immutable multimap containing the given entries, in order.    ;false
com.google.common.collect.ImmutableListMultimap;ImmutableListMultimap of(K k1, V v1, K k2, V v2, K k3, V v3);ImmutableListMultimap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);Whole;;;Returns an immutable multimap containing the given entries, in order.    ;false
com.google.common.collect.ImmutableListMultimap;ImmutableListMultimap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);ImmutableListMultimap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);Whole;;;Returns an immutable multimap containing the given entries, in order.    ;false
com.google.common.collect.ImmutableListMultimap;ImmutableList removeAll(Object key);ImmutableList replaceValues(K key, Iterable values);Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultimap;ImmutableMultimap of(K k1, V v1, K k2, V v2, K k3, V v3);ImmutableMultimap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);Whole;;;Returns an immutable multimap containing the given entries, in the "key-grouped" insertion order described in the <a href="#iteration">class documentation</a>.    ;false
com.google.common.collect.ImmutableMultimap;ImmutableMultimap of(K k1, V v1, K k2, V v2, K k3, V v3);ImmutableMultimap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);Whole;;;Returns an immutable multimap containing the given entries, in the "key-grouped" insertion order described in the <a href="#iteration">class documentation</a>.    ;false
com.google.common.collect.ImmutableMultimap;ImmutableMultimap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4);ImmutableMultimap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5);Whole;;;Returns an immutable multimap containing the given entries, in the "key-grouped" insertion order described in the <a href="#iteration">class documentation</a>.    ;false
com.google.common.collect.ImmutableMultimap;ImmutableCollection removeAll(Object key);ImmutableCollection replaceValues(K key, Iterable values);Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultimap;ImmutableCollection removeAll(Object key);void clear();Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultimap;ImmutableCollection removeAll(Object key);boolean put(K key, V value);Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultimap;ImmutableCollection removeAll(Object key);boolean putAll(K key, Iterable values);Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultimap;ImmutableCollection removeAll(Object key);boolean putAll(Multimap multimap);Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultimap;ImmutableCollection removeAll(Object key);boolean remove(Object key, Object value);Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultimap;ImmutableCollection replaceValues(K key, Iterable values);void clear();Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultimap;ImmutableCollection replaceValues(K key, Iterable values);boolean put(K key, V value);Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultimap;ImmutableCollection replaceValues(K key, Iterable values);boolean putAll(K key, Iterable values);Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultimap;ImmutableCollection replaceValues(K key, Iterable values);boolean putAll(Multimap multimap);Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultimap;ImmutableCollection replaceValues(K key, Iterable values);boolean remove(Object key, Object value);Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultimap;void clear();boolean put(K key, V value);Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultimap;void clear();boolean putAll(K key, Iterable values);Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultimap;void clear();boolean putAll(Multimap multimap);Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultimap;void clear();boolean remove(Object key, Object value);Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultimap;boolean put(K key, V value);boolean putAll(K key, Iterable values);Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultimap;boolean put(K key, V value);boolean putAll(Multimap multimap);Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultimap;boolean put(K key, V value);boolean remove(Object key, Object value);Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultimap;boolean putAll(K key, Iterable values);boolean putAll(Multimap multimap);Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultimap;boolean putAll(K key, Iterable values);boolean remove(Object key, Object value);Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableMultimap;boolean putAll(Multimap multimap);boolean remove(Object key, Object value);Whole;;;Guaranteed to throw an exception and leave the multimap unmodified.    @throws always;false
com.google.common.collect.ImmutableSortedMultiset;ImmutableSortedMultiset of(E e1, E e2);ImmutableSortedMultiset of(E e1, E e2, E e3);Whole;;;Returns an immutable sorted multiset containing the given elements sorted by their natural ordering.    @throws if any element is null;false
com.google.common.collect.ImmutableSortedMultiset;ImmutableSortedMultiset of(E e1, E e2);ImmutableSortedMultiset of(E e1, E e2, E e3, E e4);Whole;;;Returns an immutable sorted multiset containing the given elements sorted by their natural ordering.    @throws if any element is null;false
com.google.common.collect.ImmutableSortedMultiset;ImmutableSortedMultiset of(E e1, E e2);ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5);Whole;;;Returns an immutable sorted multiset containing the given elements sorted by their natural ordering.    @throws if any element is null;false
com.google.common.collect.ImmutableSortedMultiset;ImmutableSortedMultiset of(E e1, E e2);ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);Whole;;;Returns an immutable sorted multiset containing the given elements sorted by their natural ordering.    @throws if any element is null;false
com.google.common.collect.ImmutableSortedMultiset;ImmutableSortedMultiset of(E e1, E e2);ImmutableSortedMultiset copyOf(E[] elements);Free text;;;Returns an immutable sorted multiset containing the given elements sorted by their natural ordering. ;false
com.google.common.collect.ImmutableSortedMultiset;ImmutableSortedMultiset of(E e1, E e2, E e3);ImmutableSortedMultiset of(E e1, E e2, E e3, E e4);Whole;;;Returns an immutable sorted multiset containing the given elements sorted by their natural ordering.    @throws if any element is null;false
com.google.common.collect.ImmutableSortedMultiset;ImmutableSortedMultiset of(E e1, E e2, E e3);ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5);Whole;;;Returns an immutable sorted multiset containing the given elements sorted by their natural ordering.    @throws if any element is null;false
com.google.common.collect.ImmutableSortedMultiset;ImmutableSortedMultiset of(E e1, E e2, E e3);ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);Whole;;;Returns an immutable sorted multiset containing the given elements sorted by their natural ordering.    @throws if any element is null;false
com.google.common.collect.ImmutableSortedMultiset;ImmutableSortedMultiset of(E e1, E e2, E e3);ImmutableSortedMultiset copyOf(E[] elements);Free text;;;Returns an immutable sorted multiset containing the given elements sorted by their natural ordering. ;false
com.google.common.collect.ImmutableSortedMultiset;ImmutableSortedMultiset of(E e1, E e2, E e3, E e4);ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5);Whole;;;Returns an immutable sorted multiset containing the given elements sorted by their natural ordering.    @throws if any element is null;false
com.google.common.collect.ImmutableSortedMultiset;ImmutableSortedMultiset of(E e1, E e2, E e3, E e4);ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);Whole;;;Returns an immutable sorted multiset containing the given elements sorted by their natural ordering.    @throws if any element is null;false
com.google.common.collect.ImmutableSortedMultiset;ImmutableSortedMultiset of(E e1, E e2, E e3, E e4);ImmutableSortedMultiset copyOf(E[] elements);Free text;;;Returns an immutable sorted multiset containing the given elements sorted by their natural ordering. ;false
com.google.common.collect.ImmutableSortedMultiset;ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5);ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);Whole;;;Returns an immutable sorted multiset containing the given elements sorted by their natural ordering.    @throws if any element is null;false
com.google.common.collect.ImmutableSortedMultiset;ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5);ImmutableSortedMultiset copyOf(E[] elements);Free text;;;Returns an immutable sorted multiset containing the given elements sorted by their natural ordering. ;false
com.google.common.collect.ImmutableSortedMultiset;ImmutableSortedMultiset of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);ImmutableSortedMultiset copyOf(E[] elements);Free text;;;Returns an immutable sorted multiset containing the given elements sorted by their natural ordering. ;false
com.google.common.collect.ImmutableSortedMultiset;ImmutableSortedMultiset copyOf(E[] elements);ImmutableSortedMultiset copyOf(Iterable elements);@throws;;;if any of elements is null;true
com.google.common.collect.ImmutableSortedMultiset;ImmutableSortedMultiset copyOf(E[] elements);ImmutableSortedMultiset copyOf(Iterator elements);@throws;;;if any of elements is null;true
com.google.common.collect.ImmutableSortedMultiset;ImmutableSortedMultiset copyOf(Iterable elements);ImmutableSortedMultiset copyOf(Iterator elements);@throws;;;if the elements are not mutually comparable;true
com.google.common.collect.ImmutableSortedMultiset;ImmutableSortedMultiset copyOf(Iterable elements);ImmutableSortedMultiset copyOf(Iterator elements);@throws;;;if any of elements is null;true
com.google.common.collect.ImmutableSortedMultiset;ImmutableSortedMultiset copyOf(Comparator comparator, Iterator elements);ImmutableSortedMultiset copyOf(Comparator comparator, Iterable elements);@throws;;;if comparator or any of elements is null;true
com.google.common.collect.ImmutableSortedMultiset;Entry pollFirstEntry();Entry pollLastEntry();Whole;;;{@inheritDoc} <p>This implementation is guaranteed to throw an {@link UnsupportedOperationException}.    @throws always;false
com.google.common.collect.Multimap;boolean remove(Object key, Object value);boolean putAll(K key, Iterable values);@return;;;true if the multimap changed;false
com.google.common.collect.Multimap;boolean remove(Object key, Object value);boolean putAll(Multimap multimap);@return;;;true if the multimap changed;false
com.google.common.collect.Multimap;boolean putAll(K key, Iterable values);boolean putAll(Multimap multimap);@return;;;true if the multimap changed;true
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet of(E e1, E e2);ImmutableSortedSet of(E e1, E e2, E e3);Whole;;;Returns an immutable sorted set containing the given elements sorted by their natural ordering. When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first one specified is included.    @throws if any element is null;false
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet of(E e1, E e2);ImmutableSortedSet of(E e1, E e2, E e3, E e4);Whole;;;Returns an immutable sorted set containing the given elements sorted by their natural ordering. When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first one specified is included.    @throws if any element is null;false
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet of(E e1, E e2);ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5);Whole;;;Returns an immutable sorted set containing the given elements sorted by their natural ordering. When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first one specified is included.    @throws if any element is null;false
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet of(E e1, E e2);ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);Whole;;;Returns an immutable sorted set containing the given elements sorted by their natural ordering. When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first one specified is included.    @throws if any element is null;false
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet of(E e1, E e2);ImmutableSortedSet copyOf(E[] elements);Free text;;;Returns an immutable sorted set containing the given elements sorted by their natural ordering. When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first one specified is included. ;false
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet of(E e1, E e2, E e3);ImmutableSortedSet of(E e1, E e2, E e3, E e4);Whole;;;Returns an immutable sorted set containing the given elements sorted by their natural ordering. When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first one specified is included.    @throws if any element is null;false
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet of(E e1, E e2, E e3);ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5);Whole;;;Returns an immutable sorted set containing the given elements sorted by their natural ordering. When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first one specified is included.    @throws if any element is null;false
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet of(E e1, E e2, E e3);ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);Whole;;;Returns an immutable sorted set containing the given elements sorted by their natural ordering. When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first one specified is included.    @throws if any element is null;false
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet of(E e1, E e2, E e3);ImmutableSortedSet copyOf(E[] elements);Free text;;;Returns an immutable sorted set containing the given elements sorted by their natural ordering. When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first one specified is included. ;false
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet of(E e1, E e2, E e3, E e4);ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5);Whole;;;Returns an immutable sorted set containing the given elements sorted by their natural ordering. When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first one specified is included.    @throws if any element is null;false
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet of(E e1, E e2, E e3, E e4);ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);Whole;;;Returns an immutable sorted set containing the given elements sorted by their natural ordering. When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first one specified is included.    @throws if any element is null;false
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet of(E e1, E e2, E e3, E e4);ImmutableSortedSet copyOf(E[] elements);Free text;;;Returns an immutable sorted set containing the given elements sorted by their natural ordering. When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first one specified is included. ;false
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5);ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);Whole;;;Returns an immutable sorted set containing the given elements sorted by their natural ordering. When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first one specified is included.    @throws if any element is null;false
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5);ImmutableSortedSet copyOf(E[] elements);Free text;;;Returns an immutable sorted set containing the given elements sorted by their natural ordering. When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first one specified is included. ;false
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet of(E e1, E e2, E e3, E e4, E e5, E e6, E remaining);ImmutableSortedSet copyOf(E[] elements);Free text;;;Returns an immutable sorted set containing the given elements sorted by their natural ordering. When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first one specified is included. ;false
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet copyOf(E[] elements);ImmutableSortedSet copyOf(Iterable elements);@throws;;;if any of elements is null;true
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet copyOf(E[] elements);ImmutableSortedSet copyOf(Collection elements);@throws;;;if any of elements is null;true
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet copyOf(E[] elements);ImmutableSortedSet copyOf(Iterator elements);@throws;;;if any of elements is null;true
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet copyOf(Iterable elements);ImmutableSortedSet copyOf(Collection elements);@throws;;;if the elements are not mutually comparable;true
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet copyOf(Iterable elements);ImmutableSortedSet copyOf(Collection elements);@throws;;;if any of elements is null;true
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet copyOf(Iterable elements);ImmutableSortedSet copyOf(Iterator elements);@throws;;;if the elements are not mutually comparable;true
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet copyOf(Iterable elements);ImmutableSortedSet copyOf(Iterator elements);@throws;;;if any of elements is null;true
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet copyOf(Collection elements);ImmutableSortedSet copyOf(Iterator elements);@throws;;;if the elements are not mutually comparable;true
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet copyOf(Collection elements);ImmutableSortedSet copyOf(Iterator elements);@throws;;;if any of elements is null;true
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet copyOf(Comparator comparator, Iterator elements);ImmutableSortedSet copyOf(Comparator comparator, Iterable elements);@throws;;;if comparator or any of elements is null;true
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet copyOf(Comparator comparator, Iterator elements);ImmutableSortedSet copyOf(Comparator comparator, Collection elements);@throws;;;if comparator or any of elements is null;true
com.google.common.collect.ImmutableSortedSet;ImmutableSortedSet copyOf(Comparator comparator, Iterable elements);ImmutableSortedSet copyOf(Comparator comparator, Collection elements);@throws;;;if comparator or any of elements is null;true
com.google.common.collect.ImmutableSortedSet;E pollFirst();E pollLast();Whole;;;Guaranteed to throw an exception and leave the set unmodified.    @throws always;false
com.google.common.collect.MapMaker;MapMaker weakValues();MapMaker softValues();@throws;;;if the value strength was already set;true
com.google.common.collect.MapMaker;MapMaker expireAfterWrite(long duration, TimeUnit unit);MapMaker expireAfterAccess(long duration, TimeUnit unit);@param;TimeUnit unit;TimeUnit unit;the unit that duration is expressed in;true
com.google.common.collect.MapMaker;MapMaker expireAfterWrite(long duration, TimeUnit unit);MapMaker expireAfterAccess(long duration, TimeUnit unit);@throws;;;if duration is negative;true
com.google.common.collect.MapMaker;ConcurrentMap makeMap();ConcurrentMap makeComputingMap(Function computingFunction);@return;;;a serializable concurrent map having the requested features;false
com.google.common.collect.AbstractMapBasedMultimap;Collection createCollection();Collection createCollection(K key);@return;;;an empty collection of values;true
com.google.common.collect.AbstractMapBasedMultimap;Collection replaceValues(K key, Iterable values);Collection removeAll(Object key);Whole;;;{@inheritDoc} <p>The returned collection is immutable.    ;false
com.google.common.eventbus.AsyncEventBus; AsyncEventBus(String identifier, Executor executor); AsyncEventBus(Executor executor, SubscriberExceptionHandler subscriberExceptionHandler);@param;Executor executor;Executor executor;Executor to use to dispatch events. It is the caller's responsibility to shut down the executor after the last event has been posted to this event bus.;true
com.google.common.eventbus.AsyncEventBus; AsyncEventBus(String identifier, Executor executor); AsyncEventBus(Executor executor);@param;Executor executor;Executor executor;Executor to use to dispatch events. It is the caller's responsibility to shut down the executor after the last event has been posted to this event bus.;true
com.google.common.eventbus.AsyncEventBus; AsyncEventBus(Executor executor, SubscriberExceptionHandler subscriberExceptionHandler); AsyncEventBus(Executor executor);Free text;;;Creates a new AsyncEventBus that will use {@code executor} to dispatch events. ;true
com.google.common.eventbus.AsyncEventBus; AsyncEventBus(Executor executor, SubscriberExceptionHandler subscriberExceptionHandler); AsyncEventBus(Executor executor);@param;Executor executor;Executor executor;Executor to use to dispatch events. It is the caller's responsibility to shut down the executor after the last event has been posted to this event bus.;true
com.google.common.net.MediaType;MediaType createApplicationType(String subtype);MediaType createAudioType(String subtype);@throws;;;if subtype is invalid;true
com.google.common.net.MediaType;MediaType createApplicationType(String subtype);MediaType createImageType(String subtype);@throws;;;if subtype is invalid;true
com.google.common.net.MediaType;MediaType createApplicationType(String subtype);MediaType createTextType(String subtype);@throws;;;if subtype is invalid;true
com.google.common.net.MediaType;MediaType createApplicationType(String subtype);MediaType createVideoType(String subtype);@throws;;;if subtype is invalid;true
com.google.common.net.MediaType;MediaType createAudioType(String subtype);MediaType createImageType(String subtype);@throws;;;if subtype is invalid;true
com.google.common.net.MediaType;MediaType createAudioType(String subtype);MediaType createTextType(String subtype);@throws;;;if subtype is invalid;true
com.google.common.net.MediaType;MediaType createAudioType(String subtype);MediaType createVideoType(String subtype);@throws;;;if subtype is invalid;true
com.google.common.net.MediaType;MediaType createImageType(String subtype);MediaType createTextType(String subtype);@throws;;;if subtype is invalid;true
com.google.common.net.MediaType;MediaType createImageType(String subtype);MediaType createVideoType(String subtype);@throws;;;if subtype is invalid;true
com.google.common.net.MediaType;MediaType createTextType(String subtype);MediaType createVideoType(String subtype);@throws;;;if subtype is invalid;true
com.google.common.net.InetAddresses;boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip);Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip);@param;Inet6Address ip;Inet6Address ip;Inet6Address to be examined for embedded IPv4 client address;true
com.google.common.net.HostAndPort;HostAndPort fromParts(String host, int port);HostAndPort fromHost(String host);@return;;;if parsing was successful, a populated HostAndPort object.;false
com.google.common.net.HostAndPort;HostAndPort fromParts(String host, int port);HostAndPort fromString(String hostPortString);@return;;;if parsing was successful, a populated HostAndPort object.;false
com.google.common.net.HostAndPort;HostAndPort fromHost(String host);HostAndPort fromString(String hostPortString);@return;;;if parsing was successful, a populated HostAndPort object.;false
com.google.common.net.HostSpecifier;HostSpecifier fromValid(String specifier);HostSpecifier from(String specifier);@throws;;;if the specifier is not valid.;false
com.google.common.cache.LongAdder;long sum();long sumThenReset();@return;;;the sum;false
com.google.common.cache.LongAdder;long sum();long longValue();@return;;;the sum;false
com.google.common.cache.LongAdder;long sumThenReset();long longValue();@return;;;the sum;false
com.google.common.cache.LoadingCache;V get(K key);V getUnchecked(K key);@throws;;;if an error was thrown while loading the value;true
com.google.common.cache.LoadingCache;V get(K key);ImmutableMap getAll(Iterable keys);@throws;;;if a checked exception was thrown while loading the value. (ExecutionException is thrown even if computation was interrupted by an InterruptedException.);true
com.google.common.cache.CacheLoader;V load(K key);ListenableFuture reload(K key, V oldValue);@param;K key;K key;the non-null key whose value should be loaded;true
com.google.common.cache.CacheLoader;V load(K key);ListenableFuture reload(K key, V oldValue);@throws;;;if this method is interrupted. InterruptedException is treated like any other Exception in all respects except that, when it is caught, the thread's interrupt status is set;true
com.google.common.cache.CacheLoader;V load(K key);Map loadAll(Iterable keys);@throws;;;if unable to load the result;true
com.google.common.cache.CacheLoader;V load(K key);Map loadAll(Iterable keys);@throws;;;if this method is interrupted. InterruptedException is treated like any other Exception in all respects except that, when it is caught, the thread's interrupt status is set;true
com.google.common.cache.CacheLoader;ListenableFuture reload(K key, V oldValue);Map loadAll(Iterable keys);@throws;;;if this method is interrupted. InterruptedException is treated like any other Exception in all respects except that, when it is caught, the thread's interrupt status is set;true
com.google.common.cache.CacheBuilder;CacheBuilder maximumSize(long size);CacheBuilder weigher(Weigher weigher);@throws;;;if size is negative;true
com.google.common.cache.CacheBuilder;CacheBuilder weakValues();CacheBuilder softValues();@throws;;;if the value strength was already set;true
com.google.common.cache.CacheBuilder;CacheBuilder expireAfterWrite(long duration, TimeUnit unit);CacheBuilder expireAfterAccess(long duration, TimeUnit unit);@param;TimeUnit unit;TimeUnit unit;the unit that duration is expressed in;true
com.google.common.cache.CacheBuilder;CacheBuilder expireAfterWrite(long duration, TimeUnit unit);CacheBuilder expireAfterAccess(long duration, TimeUnit unit);@throws;;;if duration is negative;true
com.google.common.cache.CacheBuilder;CacheBuilder expireAfterWrite(long duration, TimeUnit unit);CacheBuilder refreshAfterWrite(long duration, TimeUnit unit);@param;TimeUnit unit;TimeUnit unit;the unit that duration is expressed in;true
com.google.common.cache.CacheBuilder;CacheBuilder expireAfterWrite(long duration, TimeUnit unit);CacheBuilder refreshAfterWrite(long duration, TimeUnit unit);@throws;;;if duration is negative;true
com.google.common.cache.CacheBuilder;CacheBuilder expireAfterAccess(long duration, TimeUnit unit);CacheBuilder refreshAfterWrite(long duration, TimeUnit unit);@param;TimeUnit unit;TimeUnit unit;the unit that duration is expressed in;true
com.google.common.cache.CacheBuilder;CacheBuilder expireAfterAccess(long duration, TimeUnit unit);CacheBuilder refreshAfterWrite(long duration, TimeUnit unit);@throws;;;if duration is negative;true
com.google.common.cache.CacheBuilder;LoadingCache build(CacheLoader loader);Cache build();@return;;;a cache having the requested features;true
com.google.common.util.concurrent.AtomicDoubleArray;double get(int i);void set(int i, double newValue);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;double get(int i);void lazySet(int i, double newValue);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;double get(int i);double getAndSet(int i, double newValue);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;double get(int i);boolean compareAndSet(int i, double expect, double update);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;double get(int i);boolean weakCompareAndSet(int i, double expect, double update);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;double get(int i);double getAndAdd(int i, double delta);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;double get(int i);double addAndGet(int i, double delta);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;void set(int i, double newValue);void lazySet(int i, double newValue);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;void set(int i, double newValue);void lazySet(int i, double newValue);@param;double newValue;double newValue;the new value;true
com.google.common.util.concurrent.AtomicDoubleArray;void set(int i, double newValue);double getAndSet(int i, double newValue);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;void set(int i, double newValue);double getAndSet(int i, double newValue);@param;double newValue;double newValue;the new value;true
com.google.common.util.concurrent.AtomicDoubleArray;void set(int i, double newValue);boolean compareAndSet(int i, double expect, double update);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;void set(int i, double newValue);boolean compareAndSet(int i, double expect, double update);@param;double newValue;double update;the new value;false
com.google.common.util.concurrent.AtomicDoubleArray;void set(int i, double newValue);boolean weakCompareAndSet(int i, double expect, double update);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;void set(int i, double newValue);boolean weakCompareAndSet(int i, double expect, double update);@param;double newValue;double update;the new value;false
com.google.common.util.concurrent.AtomicDoubleArray;void set(int i, double newValue);double getAndAdd(int i, double delta);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;void set(int i, double newValue);double addAndGet(int i, double delta);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;void lazySet(int i, double newValue);double getAndSet(int i, double newValue);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;void lazySet(int i, double newValue);double getAndSet(int i, double newValue);@param;double newValue;double newValue;the new value;true
com.google.common.util.concurrent.AtomicDoubleArray;void lazySet(int i, double newValue);boolean compareAndSet(int i, double expect, double update);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;void lazySet(int i, double newValue);boolean compareAndSet(int i, double expect, double update);@param;double newValue;double update;the new value;false
com.google.common.util.concurrent.AtomicDoubleArray;void lazySet(int i, double newValue);boolean weakCompareAndSet(int i, double expect, double update);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;void lazySet(int i, double newValue);boolean weakCompareAndSet(int i, double expect, double update);@param;double newValue;double update;the new value;false
com.google.common.util.concurrent.AtomicDoubleArray;void lazySet(int i, double newValue);double getAndAdd(int i, double delta);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;void lazySet(int i, double newValue);double addAndGet(int i, double delta);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;double getAndSet(int i, double newValue);boolean compareAndSet(int i, double expect, double update);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;double getAndSet(int i, double newValue);boolean compareAndSet(int i, double expect, double update);@param;double newValue;double update;the new value;false
com.google.common.util.concurrent.AtomicDoubleArray;double getAndSet(int i, double newValue);boolean weakCompareAndSet(int i, double expect, double update);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;double getAndSet(int i, double newValue);boolean weakCompareAndSet(int i, double expect, double update);@param;double newValue;double update;the new value;false
com.google.common.util.concurrent.AtomicDoubleArray;double getAndSet(int i, double newValue);double getAndAdd(int i, double delta);@return;;;the previous value;false
com.google.common.util.concurrent.AtomicDoubleArray;double getAndSet(int i, double newValue);double getAndAdd(int i, double delta);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;double getAndSet(int i, double newValue);double addAndGet(int i, double delta);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;boolean compareAndSet(int i, double expect, double update);boolean weakCompareAndSet(int i, double expect, double update);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;boolean compareAndSet(int i, double expect, double update);boolean weakCompareAndSet(int i, double expect, double update);@param;double expect;double expect;the expected value;true
com.google.common.util.concurrent.AtomicDoubleArray;boolean compareAndSet(int i, double expect, double update);boolean weakCompareAndSet(int i, double expect, double update);@param;double update;double update;the new value;true
com.google.common.util.concurrent.AtomicDoubleArray;boolean compareAndSet(int i, double expect, double update);double getAndAdd(int i, double delta);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;boolean compareAndSet(int i, double expect, double update);double addAndGet(int i, double delta);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;boolean weakCompareAndSet(int i, double expect, double update);double getAndAdd(int i, double delta);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;boolean weakCompareAndSet(int i, double expect, double update);double addAndGet(int i, double delta);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;double getAndAdd(int i, double delta);double addAndGet(int i, double delta);Free text;;;Atomically adds the given value to the element at index {@code i}. ;false
com.google.common.util.concurrent.AtomicDoubleArray;double getAndAdd(int i, double delta);double addAndGet(int i, double delta);@param;int i;int i;the index;true
com.google.common.util.concurrent.AtomicDoubleArray;double getAndAdd(int i, double delta);double addAndGet(int i, double delta);@param;double delta;double delta;the value to add;true
com.google.common.util.concurrent.MoreExecutors;ExecutorService getExitingExecutorService(ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit);ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit);@return;;;an unmodifiable version of the input which will not hang the JVM;false
com.google.common.util.concurrent.MoreExecutors;ExecutorService getExitingExecutorService(ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit);ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit);@param;ThreadPoolExecutor executor;ScheduledThreadPoolExecutor executor;the executor to modify to make sure it exits when the application is finished;true
com.google.common.util.concurrent.MoreExecutors;ExecutorService getExitingExecutorService(ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit);ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit);@param;long terminationTimeout;long terminationTimeout;how long to wait for the executor to finish before terminating the JVM;true
com.google.common.util.concurrent.MoreExecutors;ExecutorService getExitingExecutorService(ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit);ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit);@param;TimeUnit timeUnit;TimeUnit timeUnit;unit of time for the time parameter;true
com.google.common.util.concurrent.MoreExecutors;ExecutorService getExitingExecutorService(ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit);void addDelayedShutdownHook(ExecutorService service, long terminationTimeout, TimeUnit timeUnit);@param;long terminationTimeout;long terminationTimeout;how long to wait for the executor to finish before terminating the JVM;true
com.google.common.util.concurrent.MoreExecutors;ExecutorService getExitingExecutorService(ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit);void addDelayedShutdownHook(ExecutorService service, long terminationTimeout, TimeUnit timeUnit);@param;TimeUnit timeUnit;TimeUnit timeUnit;unit of time for the time parameter;true
com.google.common.util.concurrent.MoreExecutors;ExecutorService getExitingExecutorService(ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit);ExecutorService getExitingExecutorService(ThreadPoolExecutor executor);@return;;;an unmodifiable version of the input which will not hang the JVM;true
com.google.common.util.concurrent.MoreExecutors;ExecutorService getExitingExecutorService(ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit);ExecutorService getExitingExecutorService(ThreadPoolExecutor executor);@param;ThreadPoolExecutor executor;ThreadPoolExecutor executor;the executor to modify to make sure it exits when the application is finished;true
com.google.common.util.concurrent.MoreExecutors;ExecutorService getExitingExecutorService(ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit);ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor);@return;;;an unmodifiable version of the input which will not hang the JVM;false
com.google.common.util.concurrent.MoreExecutors;ExecutorService getExitingExecutorService(ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit);ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor);@param;ThreadPoolExecutor executor;ScheduledThreadPoolExecutor executor;the executor to modify to make sure it exits when the application is finished;true
com.google.common.util.concurrent.MoreExecutors;ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit);void addDelayedShutdownHook(ExecutorService service, long terminationTimeout, TimeUnit timeUnit);@param;long terminationTimeout;long terminationTimeout;how long to wait for the executor to finish before terminating the JVM;true
com.google.common.util.concurrent.MoreExecutors;ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit);void addDelayedShutdownHook(ExecutorService service, long terminationTimeout, TimeUnit timeUnit);@param;TimeUnit timeUnit;TimeUnit timeUnit;unit of time for the time parameter;true
com.google.common.util.concurrent.MoreExecutors;ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit);ExecutorService getExitingExecutorService(ThreadPoolExecutor executor);@return;;;an unmodifiable version of the input which will not hang the JVM;false
com.google.common.util.concurrent.MoreExecutors;ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit);ExecutorService getExitingExecutorService(ThreadPoolExecutor executor);@param;ScheduledThreadPoolExecutor executor;ThreadPoolExecutor executor;the executor to modify to make sure it exits when the application is finished;true
com.google.common.util.concurrent.MoreExecutors;ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit);ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor);@return;;;an unmodifiable version of the input which will not hang the JVM;true
com.google.common.util.concurrent.MoreExecutors;ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit);ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor);@param;ScheduledThreadPoolExecutor executor;ScheduledThreadPoolExecutor executor;the executor to modify to make sure it exits when the application is finished;true
com.google.common.util.concurrent.MoreExecutors;ExecutorService getExitingExecutorService(ThreadPoolExecutor executor);ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor);@return;;;an unmodifiable version of the input which will not hang the JVM;false
com.google.common.util.concurrent.MoreExecutors;ExecutorService getExitingExecutorService(ThreadPoolExecutor executor);ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor);@param;ThreadPoolExecutor executor;ScheduledThreadPoolExecutor executor;the executor to modify to make sure it exits when the application is finished;true
com.google.common.util.concurrent.MoreExecutors;Executor renamingDecorator(Executor executor, Supplier nameSupplier);ExecutorService renamingDecorator(ExecutorService service, Supplier nameSupplier);@param;Executor executor;ExecutorService service;The executor to decorate;true
com.google.common.util.concurrent.MoreExecutors;Executor renamingDecorator(Executor executor, Supplier nameSupplier);ExecutorService renamingDecorator(ExecutorService service, Supplier nameSupplier);@param;Supplier<String> nameSupplier;Supplier<String> nameSupplier;The source of names for each task;true
com.google.common.util.concurrent.MoreExecutors;Executor renamingDecorator(Executor executor, Supplier nameSupplier);ScheduledExecutorService renamingDecorator(ScheduledExecutorService service, Supplier nameSupplier);@param;Executor executor;ScheduledExecutorService service;The executor to decorate;true
com.google.common.util.concurrent.MoreExecutors;Executor renamingDecorator(Executor executor, Supplier nameSupplier);ScheduledExecutorService renamingDecorator(ScheduledExecutorService service, Supplier nameSupplier);@param;Supplier<String> nameSupplier;Supplier<String> nameSupplier;The source of names for each task;true
com.google.common.util.concurrent.MoreExecutors;ExecutorService renamingDecorator(ExecutorService service, Supplier nameSupplier);ScheduledExecutorService renamingDecorator(ScheduledExecutorService service, Supplier nameSupplier);@param;ExecutorService service;ScheduledExecutorService service;The executor to decorate;true
com.google.common.util.concurrent.MoreExecutors;ExecutorService renamingDecorator(ExecutorService service, Supplier nameSupplier);ScheduledExecutorService renamingDecorator(ScheduledExecutorService service, Supplier nameSupplier);@param;Supplier<String> nameSupplier;Supplier<String> nameSupplier;The source of names for each task;true
com.google.common.util.concurrent.ServiceManager;void addListener(Listener listener, Executor executor);void addListener(Listener listener);@param;Listener listener;Listener listener;the listener to run when the manager changes state;true
com.google.common.util.concurrent.ServiceManager;ServiceManager startAsync();ServiceManager stopAsync();@return;;;this;false
com.google.common.util.concurrent.ServiceManager;void awaitHealthy();void awaitHealthy(long timeout, TimeUnit unit);@throws;;;if the service manager reaches a state from which it cannot become {@linkplain #isHealthy() healthy}.;true
com.google.common.util.concurrent.ServiceManager;void awaitHealthy(long timeout, TimeUnit unit);void awaitStopped(long timeout, TimeUnit unit);@param;long timeout;long timeout;the maximum time to wait;true
com.google.common.util.concurrent.ServiceManager;void awaitHealthy(long timeout, TimeUnit unit);void awaitStopped(long timeout, TimeUnit unit);@param;TimeUnit unit;TimeUnit unit;the time unit of the timeout argument;true
com.google.common.util.concurrent.AtomicDouble;void set(double newValue);void lazySet(double newValue);@param;double newValue;double newValue;the new value;true
com.google.common.util.concurrent.AtomicDouble;void set(double newValue);double getAndSet(double newValue);@param;double newValue;double newValue;the new value;true
com.google.common.util.concurrent.AtomicDouble;void set(double newValue);boolean compareAndSet(double expect, double update);@param;double newValue;double update;the new value;false
com.google.common.util.concurrent.AtomicDouble;void set(double newValue);boolean weakCompareAndSet(double expect, double update);@param;double newValue;double update;the new value;false
com.google.common.util.concurrent.AtomicDouble;void lazySet(double newValue);double getAndSet(double newValue);@param;double newValue;double newValue;the new value;true
com.google.common.util.concurrent.AtomicDouble;void lazySet(double newValue);boolean compareAndSet(double expect, double update);@param;double newValue;double update;the new value;false
com.google.common.util.concurrent.AtomicDouble;void lazySet(double newValue);boolean weakCompareAndSet(double expect, double update);@param;double newValue;double update;the new value;false
com.google.common.util.concurrent.AtomicDouble;double getAndSet(double newValue);boolean compareAndSet(double expect, double update);@param;double newValue;double update;the new value;false
com.google.common.util.concurrent.AtomicDouble;double getAndSet(double newValue);boolean weakCompareAndSet(double expect, double update);@param;double newValue;double update;the new value;false
com.google.common.util.concurrent.AtomicDouble;double getAndSet(double newValue);double getAndAdd(double delta);@return;;;the previous value;false
com.google.common.util.concurrent.AtomicDouble;boolean compareAndSet(double expect, double update);boolean weakCompareAndSet(double expect, double update);@param;double expect;double expect;the expected value;true
com.google.common.util.concurrent.AtomicDouble;boolean compareAndSet(double expect, double update);boolean weakCompareAndSet(double expect, double update);@param;double update;double update;the new value;true
com.google.common.util.concurrent.AtomicDouble;double getAndAdd(double delta);double addAndGet(double delta);Free text;;;Atomically adds the given value to the current value. ;false
com.google.common.util.concurrent.AtomicDouble;double getAndAdd(double delta);double addAndGet(double delta);@param;double delta;double delta;the value to add;true
com.google.common.util.concurrent.AbstractCheckedFuture;V checkedGet();V checkedGet(long timeout, TimeUnit unit);@throws;;;if get() throws an InterruptedException, CancellationException, or ExecutionException;true
com.google.common.util.concurrent.Uninterruptibles;V getUninterruptibly(Future future);V getUninterruptibly(Future future, long timeout, TimeUnit unit);@throws;;;if the computation threw an exception;true
com.google.common.util.concurrent.Uninterruptibles;V getUninterruptibly(Future future);V getUninterruptibly(Future future, long timeout, TimeUnit unit);@throws;;;if the computation was cancelled;true
com.google.common.util.concurrent.AbstractFuture;V get(long timeout, TimeUnit unit);V get();Whole;;;{@inheritDoc} <p>The default {@link AbstractFuture} implementation throws {@code InterruptedException} if the current thread is interrupted before or during the call, even if the value is already available.    @throws if the current thread was interrupted before or during the call (optional but recommended).@throws {@inheritDoc};false
com.google.common.util.concurrent.AbstractFuture;boolean set(V value);boolean setException(Throwable throwable);@return;;;true if the attempt was accepted, completing the Future;false
com.google.common.util.concurrent.RateLimiter;double acquire();double acquire(int permits);@return;;;time spent sleeping to enforce rate, in seconds, 0.0 if not rate-limited;true
com.google.common.util.concurrent.RateLimiter;double acquire(int permits);boolean tryAcquire(long timeout, TimeUnit unit);@throws;;;if the requested number of permits is negative or zero;true
com.google.common.util.concurrent.RateLimiter;double acquire(int permits);boolean tryAcquire(int permits);@param;int permits;int permits;the number of permits to acquire;true
com.google.common.util.concurrent.RateLimiter;double acquire(int permits);boolean tryAcquire(int permits);@throws;;;if the requested number of permits is negative or zero;true
com.google.common.util.concurrent.RateLimiter;double acquire(int permits);boolean tryAcquire(int permits, long timeout, TimeUnit unit);@param;int permits;int permits;the number of permits to acquire;true
com.google.common.util.concurrent.RateLimiter;double acquire(int permits);boolean tryAcquire(int permits, long timeout, TimeUnit unit);@throws;;;if the requested number of permits is negative or zero;true
com.google.common.util.concurrent.RateLimiter;boolean tryAcquire(long timeout, TimeUnit unit);boolean tryAcquire(int permits);@throws;;;if the requested number of permits is negative or zero;true
com.google.common.util.concurrent.RateLimiter;boolean tryAcquire(long timeout, TimeUnit unit);boolean tryAcquire();@return;;;true if the permit was acquired, false otherwise;true
com.google.common.util.concurrent.RateLimiter;boolean tryAcquire(long timeout, TimeUnit unit);boolean tryAcquire(int permits, long timeout, TimeUnit unit);@param;TimeUnit unit;TimeUnit unit;the time unit of the timeout argument;true
com.google.common.util.concurrent.RateLimiter;boolean tryAcquire(long timeout, TimeUnit unit);boolean tryAcquire(int permits, long timeout, TimeUnit unit);@throws;;;if the requested number of permits is negative or zero;true
com.google.common.util.concurrent.RateLimiter;boolean tryAcquire(int permits);boolean tryAcquire(int permits, long timeout, TimeUnit unit);@return;;;true if the permits were acquired, false otherwise;true
com.google.common.util.concurrent.RateLimiter;boolean tryAcquire(int permits);boolean tryAcquire(int permits, long timeout, TimeUnit unit);@param;int permits;int permits;the number of permits to acquire;true
com.google.common.util.concurrent.RateLimiter;boolean tryAcquire(int permits);boolean tryAcquire(int permits, long timeout, TimeUnit unit);@throws;;;if the requested number of permits is negative or zero;true
com.google.common.util.concurrent.ThreadFactoryBuilder;ThreadFactoryBuilder setNameFormat(String nameFormat);ThreadFactoryBuilder setDaemon(boolean daemon);@return;;;this for the builder pattern;false
com.google.common.util.concurrent.ThreadFactoryBuilder;ThreadFactoryBuilder setNameFormat(String nameFormat);ThreadFactoryBuilder setPriority(int priority);@return;;;this for the builder pattern;false
com.google.common.util.concurrent.ThreadFactoryBuilder;ThreadFactoryBuilder setNameFormat(String nameFormat);ThreadFactoryBuilder setUncaughtExceptionHandler(UncaughtExceptionHandler uncaughtExceptionHandler);@return;;;this for the builder pattern;false
com.google.common.util.concurrent.ThreadFactoryBuilder;ThreadFactoryBuilder setNameFormat(String nameFormat);ThreadFactoryBuilder setThreadFactory(ThreadFactory backingThreadFactory);@return;;;this for the builder pattern;false
com.google.common.util.concurrent.ThreadFactoryBuilder;ThreadFactoryBuilder setDaemon(boolean daemon);ThreadFactoryBuilder setPriority(int priority);@return;;;this for the builder pattern;false
com.google.common.util.concurrent.ThreadFactoryBuilder;ThreadFactoryBuilder setDaemon(boolean daemon);ThreadFactoryBuilder setUncaughtExceptionHandler(UncaughtExceptionHandler uncaughtExceptionHandler);@return;;;this for the builder pattern;false
com.google.common.util.concurrent.ThreadFactoryBuilder;ThreadFactoryBuilder setDaemon(boolean daemon);ThreadFactoryBuilder setThreadFactory(ThreadFactory backingThreadFactory);@return;;;this for the builder pattern;false
com.google.common.util.concurrent.ThreadFactoryBuilder;ThreadFactoryBuilder setPriority(int priority);ThreadFactoryBuilder setUncaughtExceptionHandler(UncaughtExceptionHandler uncaughtExceptionHandler);@return;;;this for the builder pattern;false
com.google.common.util.concurrent.ThreadFactoryBuilder;ThreadFactoryBuilder setPriority(int priority);ThreadFactoryBuilder setThreadFactory(ThreadFactory backingThreadFactory);@return;;;this for the builder pattern;false
com.google.common.util.concurrent.ThreadFactoryBuilder;ThreadFactoryBuilder setUncaughtExceptionHandler(UncaughtExceptionHandler uncaughtExceptionHandler);ThreadFactoryBuilder setThreadFactory(ThreadFactory backingThreadFactory);@return;;;this for the builder pattern;false
com.google.common.util.concurrent.Service;Service startAsync();Service stopAsync();@return;;;this;false
com.google.common.util.concurrent.Service;void awaitRunning(long timeout, TimeUnit unit);void awaitTerminated(long timeout, TimeUnit unit);@param;long timeout;long timeout;the maximum time to wait;true
com.google.common.util.concurrent.Service;void awaitRunning(long timeout, TimeUnit unit);void awaitTerminated(long timeout, TimeUnit unit);@param;TimeUnit unit;TimeUnit unit;the time unit of the timeout argument;true
com.google.common.util.concurrent.Service;void awaitRunning(long timeout, TimeUnit unit);void awaitTerminated(long timeout, TimeUnit unit);@throws;;;if the service has not reached the given state within the deadline;true
com.google.common.util.concurrent.Service;void awaitTerminated();void awaitTerminated(long timeout, TimeUnit unit);@throws;;;if the service {@linkplain State#FAILED fails}.;true
com.google.common.util.concurrent.Callables;Callable threadRenaming(Callable callable, Supplier nameSupplier);Runnable threadRenaming(Runnable task, Supplier nameSupplier);@param;Supplier<String> nameSupplier;Supplier<String> nameSupplier;The supplier of thread names, Supplier#get get will be called once for each invocation of the wrapped callable.;true
com.google.common.util.concurrent.Striped;Striped lock(int stripes);Striped lazyWeakLock(int stripes);@return;;;a new Striped<Lock>;false
com.google.common.util.concurrent.Striped;Striped lock(int stripes);Striped lazyWeakLock(int stripes);@param;int stripes;int stripes;the minimum number of stripes (locks) required;true
com.google.common.util.concurrent.Striped;Striped lock(int stripes);Striped readWriteLock(int stripes);@param;int stripes;int stripes;the minimum number of stripes (locks) required;true
com.google.common.util.concurrent.Striped;Striped lock(int stripes);Striped lazyWeakReadWriteLock(int stripes);@param;int stripes;int stripes;the minimum number of stripes (locks) required;true
com.google.common.util.concurrent.Striped;Striped lazyWeakLock(int stripes);Striped readWriteLock(int stripes);@param;int stripes;int stripes;the minimum number of stripes (locks) required;true
com.google.common.util.concurrent.Striped;Striped lazyWeakLock(int stripes);Striped lazyWeakReadWriteLock(int stripes);@param;int stripes;int stripes;the minimum number of stripes (locks) required;true
com.google.common.util.concurrent.Striped;Striped semaphore(int stripes, int permits);Striped lazyWeakSemaphore(int stripes, int permits);@return;;;a new Striped<Semaphore>;false
com.google.common.util.concurrent.Striped;Striped semaphore(int stripes, int permits);Striped lazyWeakSemaphore(int stripes, int permits);@param;int stripes;int stripes;the minimum number of stripes (semaphores) required;true
com.google.common.util.concurrent.Striped;Striped semaphore(int stripes, int permits);Striped lazyWeakSemaphore(int stripes, int permits);@param;int permits;int permits;the number of permits in each semaphore;true
com.google.common.util.concurrent.Striped;Striped readWriteLock(int stripes);Striped lazyWeakReadWriteLock(int stripes);@return;;;a new Striped<ReadWriteLock>;false
com.google.common.util.concurrent.Striped;Striped readWriteLock(int stripes);Striped lazyWeakReadWriteLock(int stripes);@param;int stripes;int stripes;the minimum number of stripes (locks) required;true
com.google.common.util.concurrent.Futures;ListenableFuture withFallback(ListenableFuture input, FutureFallback fallback);ListenableFuture withFallback(ListenableFuture input, FutureFallback fallback, Executor executor);@param;ListenableFuture<? extends V> input;ListenableFuture<? extends V> input;the primary input Future;true
com.google.common.util.concurrent.Futures;ListenableFuture withFallback(ListenableFuture input, FutureFallback fallback);ListenableFuture withFallback(ListenableFuture input, FutureFallback fallback, Executor executor);@param;FutureFallback<? extends V> fallback;FutureFallback<? extends V> fallback;the FutureFallback implementation to be called if input fails;true
com.google.common.util.concurrent.Futures;ListenableFuture withFallback(ListenableFuture input, FutureFallback fallback);ListenableFuture catching(ListenableFuture input, Class exceptionType, Function fallback);@param;ListenableFuture<? extends V> input;ListenableFuture<? extends V> input;the primary input Future;true
com.google.common.util.concurrent.Futures;ListenableFuture withFallback(ListenableFuture input, FutureFallback fallback);ListenableFuture catching(ListenableFuture input, Class exceptionType, Function fallback, Executor executor);@param;ListenableFuture<? extends V> input;ListenableFuture<? extends V> input;the primary input Future;true
com.google.common.util.concurrent.Futures;ListenableFuture withFallback(ListenableFuture input, FutureFallback fallback);ListenableFuture catchingAsync(ListenableFuture input, Class exceptionType, AsyncFunction fallback);@param;ListenableFuture<? extends V> input;ListenableFuture<? extends V> input;the primary input Future;true
com.google.common.util.concurrent.Futures;ListenableFuture withFallback(ListenableFuture input, FutureFallback fallback);ListenableFuture catchingAsync(ListenableFuture input, Class exceptionType, AsyncFunction fallback, Executor executor);@param;ListenableFuture<? extends V> input;ListenableFuture<? extends V> input;the primary input Future;true
com.google.common.util.concurrent.Futures;ListenableFuture withFallback(ListenableFuture input, FutureFallback fallback, Executor executor);ListenableFuture catching(ListenableFuture input, Class exceptionType, Function fallback);@param;ListenableFuture<? extends V> input;ListenableFuture<? extends V> input;the primary input Future;true
com.google.common.util.concurrent.Futures;ListenableFuture withFallback(ListenableFuture input, FutureFallback fallback, Executor executor);ListenableFuture catching(ListenableFuture input, Class exceptionType, Function fallback, Executor executor);@param;ListenableFuture<? extends V> input;ListenableFuture<? extends V> input;the primary input Future;true
com.google.common.util.concurrent.Futures;ListenableFuture withFallback(ListenableFuture input, FutureFallback fallback, Executor executor);ListenableFuture catching(ListenableFuture input, Class exceptionType, Function fallback, Executor executor);@param;Executor executor;Executor executor;the executor that runs fallback if input fails;true
com.google.common.util.concurrent.Futures;ListenableFuture withFallback(ListenableFuture input, FutureFallback fallback, Executor executor);ListenableFuture catchingAsync(ListenableFuture input, Class exceptionType, AsyncFunction fallback);@param;ListenableFuture<? extends V> input;ListenableFuture<? extends V> input;the primary input Future;true
com.google.common.util.concurrent.Futures;ListenableFuture withFallback(ListenableFuture input, FutureFallback fallback, Executor executor);ListenableFuture catchingAsync(ListenableFuture input, Class exceptionType, AsyncFunction fallback, Executor executor);@param;ListenableFuture<? extends V> input;ListenableFuture<? extends V> input;the primary input Future;true
com.google.common.util.concurrent.Futures;ListenableFuture withFallback(ListenableFuture input, FutureFallback fallback, Executor executor);ListenableFuture catchingAsync(ListenableFuture input, Class exceptionType, AsyncFunction fallback, Executor executor);@param;Executor executor;Executor executor;the executor that runs fallback if input fails;true
com.google.common.util.concurrent.Futures;ListenableFuture catching(ListenableFuture input, Class exceptionType, Function fallback);ListenableFuture catching(ListenableFuture input, Class exceptionType, Function fallback, Executor executor);@param;ListenableFuture<? extends V> input;ListenableFuture<? extends V> input;the primary input Future;true
com.google.common.util.concurrent.Futures;ListenableFuture catching(ListenableFuture input, Class exceptionType, Function fallback);ListenableFuture catching(ListenableFuture input, Class exceptionType, Function fallback, Executor executor);@param;Class<X> exceptionType;Class<X> exceptionType;the exception type that triggers use of fallback. To avoid hiding bugs and other unrecoverable errors, callers should prefer more specific types, avoiding Throwable.class in particular.;true
com.google.common.util.concurrent.Futures;ListenableFuture catching(ListenableFuture input, Class exceptionType, Function fallback);ListenableFuture catching(ListenableFuture input, Class exceptionType, Function fallback, Executor executor);@param;Function<? super X,? extends V> fallback;Function<? super X,? extends V> fallback;the Function implementation to be called if input fails with the expected exception type;true
com.google.common.util.concurrent.Futures;ListenableFuture catching(ListenableFuture input, Class exceptionType, Function fallback);ListenableFuture catchingAsync(ListenableFuture input, Class exceptionType, AsyncFunction fallback);@param;ListenableFuture<? extends V> input;ListenableFuture<? extends V> input;the primary input Future;true
com.google.common.util.concurrent.Futures;ListenableFuture catching(ListenableFuture input, Class exceptionType, Function fallback);ListenableFuture catchingAsync(ListenableFuture input, Class exceptionType, AsyncFunction fallback);@param;Class<X> exceptionType;Class<X> exceptionType;the exception type that triggers use of fallback. To avoid hiding bugs and other unrecoverable errors, callers should prefer more specific types, avoiding Throwable.class in particular.;true
com.google.common.util.concurrent.Futures;ListenableFuture catching(ListenableFuture input, Class exceptionType, Function fallback);ListenableFuture catchingAsync(ListenableFuture input, Class exceptionType, AsyncFunction fallback, Executor executor);@param;ListenableFuture<? extends V> input;ListenableFuture<? extends V> input;the primary input Future;true
com.google.common.util.concurrent.Futures;ListenableFuture catching(ListenableFuture input, Class exceptionType, Function fallback);ListenableFuture catchingAsync(ListenableFuture input, Class exceptionType, AsyncFunction fallback, Executor executor);@param;Class<X> exceptionType;Class<X> exceptionType;the exception type that triggers use of fallback. To avoid hiding bugs and other unrecoverable errors, callers should prefer more specific types, avoiding Throwable.class in particular.;true
com.google.common.util.concurrent.Futures;ListenableFuture catching(ListenableFuture input, Class exceptionType, Function fallback, Executor executor);ListenableFuture catchingAsync(ListenableFuture input, Class exceptionType, AsyncFunction fallback);@param;ListenableFuture<? extends V> input;ListenableFuture<? extends V> input;the primary input Future;true
com.google.common.util.concurrent.Futures;ListenableFuture catching(ListenableFuture input, Class exceptionType, Function fallback, Executor executor);ListenableFuture catchingAsync(ListenableFuture input, Class exceptionType, AsyncFunction fallback);@param;Class<X> exceptionType;Class<X> exceptionType;the exception type that triggers use of fallback. To avoid hiding bugs and other unrecoverable errors, callers should prefer more specific types, avoiding Throwable.class in particular.;true
com.google.common.util.concurrent.Futures;ListenableFuture catching(ListenableFuture input, Class exceptionType, Function fallback, Executor executor);ListenableFuture catchingAsync(ListenableFuture input, Class exceptionType, AsyncFunction fallback, Executor executor);@param;ListenableFuture<? extends V> input;ListenableFuture<? extends V> input;the primary input Future;true
com.google.common.util.concurrent.Futures;ListenableFuture catching(ListenableFuture input, Class exceptionType, Function fallback, Executor executor);ListenableFuture catchingAsync(ListenableFuture input, Class exceptionType, AsyncFunction fallback, Executor executor);@param;Class<X> exceptionType;Class<X> exceptionType;the exception type that triggers use of fallback. To avoid hiding bugs and other unrecoverable errors, callers should prefer more specific types, avoiding Throwable.class in particular.;true
com.google.common.util.concurrent.Futures;ListenableFuture catching(ListenableFuture input, Class exceptionType, Function fallback, Executor executor);ListenableFuture catchingAsync(ListenableFuture input, Class exceptionType, AsyncFunction fallback, Executor executor);@param;Executor executor;Executor executor;the executor that runs fallback if input fails;true
com.google.common.util.concurrent.Futures;ListenableFuture catchingAsync(ListenableFuture input, Class exceptionType, AsyncFunction fallback);ListenableFuture catchingAsync(ListenableFuture input, Class exceptionType, AsyncFunction fallback, Executor executor);@param;ListenableFuture<? extends V> input;ListenableFuture<? extends V> input;the primary input Future;true
com.google.common.util.concurrent.Futures;ListenableFuture catchingAsync(ListenableFuture input, Class exceptionType, AsyncFunction fallback);ListenableFuture catchingAsync(ListenableFuture input, Class exceptionType, AsyncFunction fallback, Executor executor);@param;Class<X> exceptionType;Class<X> exceptionType;the exception type that triggers use of fallback. To avoid hiding bugs and other unrecoverable errors, callers should prefer more specific types, avoiding Throwable.class in particular.;true
com.google.common.util.concurrent.Futures;ListenableFuture catchingAsync(ListenableFuture input, Class exceptionType, AsyncFunction fallback);ListenableFuture catchingAsync(ListenableFuture input, Class exceptionType, AsyncFunction fallback, Executor executor);@param;AsyncFunction<? super X,? extends V> fallback;AsyncFunction<? super X,? extends V> fallback;the AsyncFunction implementation to be called if input fails with the expected exception type;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function);ListenableFuture transform(ListenableFuture input, AsyncFunction function, Executor executor);@return;;;A future that holds result of the function (if the input succeeded) or the original input's failure (if not);true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function);ListenableFuture transform(ListenableFuture input, AsyncFunction function, Executor executor);@param;ListenableFuture<I> input;ListenableFuture<I> input;The future to transform;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function);ListenableFuture transform(ListenableFuture input, AsyncFunction function, Executor executor);@param;AsyncFunction<? super I,? extends O> function;AsyncFunction<? super I,? extends O> function;A function to transform the result of the input future to the result of the output future;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function);ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function);@return;;;A future that holds result of the function (if the input succeeded) or the original input's failure (if not);false
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function);ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function);@param;ListenableFuture<I> input;ListenableFuture<I> input;The future to transform;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function);ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function);@param;AsyncFunction<? super I,? extends O> function;AsyncFunction<? super I,? extends O> function;A function to transform the result of the input future to the result of the output future;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function);ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function, Executor executor);@return;;;A future that holds result of the function (if the input succeeded) or the original input's failure (if not);false
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function);ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function, Executor executor);@param;ListenableFuture<I> input;ListenableFuture<I> input;The future to transform;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function);ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function, Executor executor);@param;AsyncFunction<? super I,? extends O> function;AsyncFunction<? super I,? extends O> function;A function to transform the result of the input future to the result of the output future;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function);ListenableFuture transform(ListenableFuture input, Function function);@param;ListenableFuture<I> input;ListenableFuture<I> input;The future to transform;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function);ListenableFuture transform(ListenableFuture input, Function function, Executor executor);@param;ListenableFuture<I> input;ListenableFuture<I> input;The future to transform;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function);Future lazyTransform(Future input, Function function);@param;ListenableFuture<I> input;Future<I> input;The future to transform;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function, Executor executor);ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function);@return;;;A future that holds result of the function (if the input succeeded) or the original input's failure (if not);false
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function, Executor executor);ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function);@param;ListenableFuture<I> input;ListenableFuture<I> input;The future to transform;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function, Executor executor);ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function);@param;AsyncFunction<? super I,? extends O> function;AsyncFunction<? super I,? extends O> function;A function to transform the result of the input future to the result of the output future;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function, Executor executor);ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function, Executor executor);@return;;;A future that holds result of the function (if the input succeeded) or the original input's failure (if not);false
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function, Executor executor);ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function, Executor executor);@param;ListenableFuture<I> input;ListenableFuture<I> input;The future to transform;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function, Executor executor);ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function, Executor executor);@param;AsyncFunction<? super I,? extends O> function;AsyncFunction<? super I,? extends O> function;A function to transform the result of the input future to the result of the output future;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function, Executor executor);ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function, Executor executor);@param;Executor executor;Executor executor;Executor to run the function in.;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function, Executor executor);ListenableFuture transform(ListenableFuture input, Function function);@param;ListenableFuture<I> input;ListenableFuture<I> input;The future to transform;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function, Executor executor);ListenableFuture transform(ListenableFuture input, Function function, Executor executor);@param;ListenableFuture<I> input;ListenableFuture<I> input;The future to transform;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function, Executor executor);ListenableFuture transform(ListenableFuture input, Function function, Executor executor);@param;Executor executor;Executor executor;Executor to run the function in.;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, AsyncFunction function, Executor executor);Future lazyTransform(Future input, Function function);@param;ListenableFuture<I> input;Future<I> input;The future to transform;true
com.google.common.util.concurrent.Futures;ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function);ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function, Executor executor);@return;;;A future that holds result of the function (if the input succeeded) or the original input's failure (if not);true
com.google.common.util.concurrent.Futures;ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function);ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function, Executor executor);@param;ListenableFuture<I> input;ListenableFuture<I> input;The future to transform;true
com.google.common.util.concurrent.Futures;ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function);ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function, Executor executor);@param;AsyncFunction<? super I,? extends O> function;AsyncFunction<? super I,? extends O> function;A function to transform the result of the input future to the result of the output future;true
com.google.common.util.concurrent.Futures;ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function);ListenableFuture transform(ListenableFuture input, Function function);@param;ListenableFuture<I> input;ListenableFuture<I> input;The future to transform;true
com.google.common.util.concurrent.Futures;ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function);ListenableFuture transform(ListenableFuture input, Function function, Executor executor);@param;ListenableFuture<I> input;ListenableFuture<I> input;The future to transform;true
com.google.common.util.concurrent.Futures;ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function);Future lazyTransform(Future input, Function function);@param;ListenableFuture<I> input;Future<I> input;The future to transform;true
com.google.common.util.concurrent.Futures;ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function, Executor executor);ListenableFuture transform(ListenableFuture input, Function function);@param;ListenableFuture<I> input;ListenableFuture<I> input;The future to transform;true
com.google.common.util.concurrent.Futures;ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function, Executor executor);ListenableFuture transform(ListenableFuture input, Function function, Executor executor);@param;ListenableFuture<I> input;ListenableFuture<I> input;The future to transform;true
com.google.common.util.concurrent.Futures;ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function, Executor executor);ListenableFuture transform(ListenableFuture input, Function function, Executor executor);@param;Executor executor;Executor executor;Executor to run the function in.;true
com.google.common.util.concurrent.Futures;ListenableFuture transformAsync(ListenableFuture input, AsyncFunction function, Executor executor);Future lazyTransform(Future input, Function function);@param;ListenableFuture<I> input;Future<I> input;The future to transform;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, Function function);ListenableFuture transform(ListenableFuture input, Function function, Executor executor);@return;;;A future that holds result of the transformation.;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, Function function);ListenableFuture transform(ListenableFuture input, Function function, Executor executor);@param;ListenableFuture<I> input;ListenableFuture<I> input;The future to transform;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, Function function);Future lazyTransform(Future input, Function function);@param;ListenableFuture<I> input;Future<I> input;The future to transform;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, Function function, Executor executor);Future lazyTransform(Future input, Function function);@param;ListenableFuture<I> input;Future<I> input;The future to transform;true
com.google.common.util.concurrent.Futures;ListenableFuture transform(ListenableFuture input, Function function, Executor executor);Future lazyTransform(Future input, Function function);@param;Function<? super I,? extends O> function;Function<? super I,? extends O> function;A Function to transform the results of the provided future to the results of the returned future.;true
com.google.common.util.concurrent.Futures;ListenableFuture allAsList(ListenableFuture futures);ListenableFuture allAsList(Iterable futures);Whole;;;Creates a new {@code ListenableFuture} whose value is a list containing the values of all its input futures, if all succeed. If any input fails, the returned future fails immediately. <p>The list of results is in the same order as the input list. <p>Canceling this future will attempt to cancel all the component futures, and if any of the provided futures fails or is canceled, this one is, too.  @param futures to combine @return a future that provides a list of the results of the component futures ;false
com.google.common.util.concurrent.Futures;ListenableFuture allAsList(ListenableFuture futures);ListenableFuture successfulAsList(ListenableFuture futures);@return;;;a future that provides a list of the results of the component futures;false
com.google.common.util.concurrent.Futures;ListenableFuture allAsList(ListenableFuture futures);ListenableFuture successfulAsList(ListenableFuture futures);@param;ListenableFuture<? extends V> futures;ListenableFuture<? extends V> futures;futures to combine;true
com.google.common.util.concurrent.Futures;ListenableFuture allAsList(ListenableFuture futures);ListenableFuture successfulAsList(Iterable futures);@return;;;a future that provides a list of the results of the component futures;false
com.google.common.util.concurrent.Futures;ListenableFuture allAsList(ListenableFuture futures);ListenableFuture successfulAsList(Iterable futures);@param;ListenableFuture<? extends V> futures;Iterable<? extends ListenableFuture<? extends V>> futures;futures to combine;true
com.google.common.util.concurrent.Futures;ListenableFuture allAsList(Iterable futures);ListenableFuture successfulAsList(ListenableFuture futures);@return;;;a future that provides a list of the results of the component futures;false
com.google.common.util.concurrent.Futures;ListenableFuture allAsList(Iterable futures);ListenableFuture successfulAsList(ListenableFuture futures);@param;Iterable<? extends ListenableFuture<? extends V>> futures;ListenableFuture<? extends V> futures;futures to combine;true
com.google.common.util.concurrent.Futures;ListenableFuture allAsList(Iterable futures);ListenableFuture successfulAsList(Iterable futures);@return;;;a future that provides a list of the results of the component futures;false
com.google.common.util.concurrent.Futures;ListenableFuture allAsList(Iterable futures);ListenableFuture successfulAsList(Iterable futures);@param;Iterable<? extends ListenableFuture<? extends V>> futures;Iterable<? extends ListenableFuture<? extends V>> futures;futures to combine;true
com.google.common.util.concurrent.Futures;ListenableFuture successfulAsList(ListenableFuture futures);ListenableFuture successfulAsList(Iterable futures);Whole;;;Creates a new {@code ListenableFuture} whose value is a list containing the values of all its successful input futures. The list of results is in the same order as the input list, and if any of the provided futures fails or is canceled, its corresponding position will contain {@code null} (which is indistinguishable from the future having a successful value of {@code null}). <p>Canceling this future will attempt to cancel all the component futures.  @param futures to combine @return a future that provides a list of the results of the component futures ;false
com.google.common.util.concurrent.Futures;void addCallback(ListenableFuture future, FutureCallback callback);void addCallback(ListenableFuture future, FutureCallback callback, Executor executor);@param;ListenableFuture<V> future;ListenableFuture<V> future;The future attach the callback to.;true
com.google.common.util.concurrent.Futures;void addCallback(ListenableFuture future, FutureCallback callback);void addCallback(ListenableFuture future, FutureCallback callback, Executor executor);@param;FutureCallback<? super V> callback;FutureCallback<? super V> callback;The callback to invoke when future is completed.;true
com.google.common.util.concurrent.Futures;V get(Future future, Class exceptionClass);V get(Future future, long timeout, TimeUnit unit, Class exceptionClass);@throws;;;if get throws any checked exception except for an ExecutionException whose cause is not itself a checked exception;true
com.google.common.util.concurrent.Futures;V get(Future future, Class exceptionClass);V get(Future future, long timeout, TimeUnit unit, Class exceptionClass);@throws;;;if get throws an ExecutionException with a RuntimeException as its cause;true
com.google.common.util.concurrent.Futures;V get(Future future, Class exceptionClass);V get(Future future, long timeout, TimeUnit unit, Class exceptionClass);@throws;;;if get throws an ExecutionException with an Error as its cause;true
com.google.common.util.concurrent.Futures;V get(Future future, Class exceptionClass);V get(Future future, long timeout, TimeUnit unit, Class exceptionClass);@throws;;;if get throws a CancellationException;true
com.google.common.util.concurrent.Futures;V get(Future future, Class exceptionClass);V get(Future future, long timeout, TimeUnit unit, Class exceptionClass);@throws;;;if exceptionClass extends RuntimeException or does not have a suitable constructor;true
com.google.common.util.concurrent.Futures;V get(Future future, Class exceptionClass);V getChecked(Future future, Class exceptionClass);Whole;;;Returns the result of {@link Future#get()}, converting most exceptions to a new instance of the given checked exception type. This reduces boilerplate for a common use of {@code Future} in which it is unnecessary to programmatically distinguish between exception types or to extract other information from the exception instance. <p>Exceptions from {@code Future.get} are treated as follows: <ul> <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an     {@code X} if the cause is a checked exception, an {@link     UncheckedExecutionException} if the cause is a {@code     RuntimeException}, or an {@link ExecutionError} if the cause is an     {@code Error}. <li>Any {@link InterruptedException} is wrapped in an {@code X} (after     restoring the interrupt). <li>Any {@link CancellationException} is propagated untouched, as is any     other {@link RuntimeException} (though {@code get} implementations are     discouraged from throwing such exceptions). </ul> <p>The overall principle is to continue to treat every checked exception as a checked exception, every unchecked exception as an unchecked exception, and every error as an error. In addition, the cause of any {@code ExecutionException} is wrapped in order to ensure that the new stack trace matches that of the current thread. <p>Instances of {@code exceptionClass} are created by choosing an arbitrary public constructor that accepts zero or more arguments, all of type {@code String} or {@code Throwable} (preferring constructors with at least one {@code String}) and calling the constructor via reflection. If the exception did not already have a cause, one is set by calling {@link Throwable#initCause(Throwable)} on it. If no such constructor exists, an {@code IllegalArgumentException} is thrown.    @throws if get throws any checked exception except for an ExecutionException whose cause is not itself a checked exception@throws if get throws an ExecutionException with a RuntimeException as its cause@throws if get throws an ExecutionException with an Error as its cause@throws if get throws a CancellationException@throws if exceptionClass extends RuntimeException or does not have a suitable constructor;false
com.google.common.util.concurrent.Futures;V get(Future future, Class exceptionClass);V getChecked(Future future, Class exceptionClass, long timeout, TimeUnit unit);@throws;;;if get throws any checked exception except for an ExecutionException whose cause is not itself a checked exception;true
com.google.common.util.concurrent.Futures;V get(Future future, Class exceptionClass);V getChecked(Future future, Class exceptionClass, long timeout, TimeUnit unit);@throws;;;if get throws an ExecutionException with a RuntimeException as its cause;true
com.google.common.util.concurrent.Futures;V get(Future future, Class exceptionClass);V getChecked(Future future, Class exceptionClass, long timeout, TimeUnit unit);@throws;;;if get throws an ExecutionException with an Error as its cause;true
com.google.common.util.concurrent.Futures;V get(Future future, Class exceptionClass);V getChecked(Future future, Class exceptionClass, long timeout, TimeUnit unit);@throws;;;if get throws a CancellationException;true
com.google.common.util.concurrent.Futures;V get(Future future, Class exceptionClass);V getChecked(Future future, Class exceptionClass, long timeout, TimeUnit unit);@throws;;;if exceptionClass extends RuntimeException or does not have a suitable constructor;true
com.google.common.util.concurrent.Futures;V get(Future future, Class exceptionClass);V getUnchecked(Future future);@throws;;;if get throws an ExecutionException with an Error as its cause;true
com.google.common.util.concurrent.Futures;V get(Future future, Class exceptionClass);V getUnchecked(Future future);@throws;;;if get throws a CancellationException;true
com.google.common.util.concurrent.Futures;V get(Future future, long timeout, TimeUnit unit, Class exceptionClass);V getChecked(Future future, Class exceptionClass);@throws;;;if get throws any checked exception except for an ExecutionException whose cause is not itself a checked exception;true
com.google.common.util.concurrent.Futures;V get(Future future, long timeout, TimeUnit unit, Class exceptionClass);V getChecked(Future future, Class exceptionClass);@throws;;;if get throws an ExecutionException with a RuntimeException as its cause;true
com.google.common.util.concurrent.Futures;V get(Future future, long timeout, TimeUnit unit, Class exceptionClass);V getChecked(Future future, Class exceptionClass);@throws;;;if get throws an ExecutionException with an Error as its cause;true
com.google.common.util.concurrent.Futures;V get(Future future, long timeout, TimeUnit unit, Class exceptionClass);V getChecked(Future future, Class exceptionClass);@throws;;;if get throws a CancellationException;true
com.google.common.util.concurrent.Futures;V get(Future future, long timeout, TimeUnit unit, Class exceptionClass);V getChecked(Future future, Class exceptionClass);@throws;;;if exceptionClass extends RuntimeException or does not have a suitable constructor;true
com.google.common.util.concurrent.Futures;V get(Future future, long timeout, TimeUnit unit, Class exceptionClass);V getChecked(Future future, Class exceptionClass, long timeout, TimeUnit unit);Whole;;;Returns the result of {@link Future#get(long, TimeUnit)}, converting most exceptions to a new instance of the given checked exception type. This reduces boilerplate for a common use of {@code Future} in which it is unnecessary to programmatically distinguish between exception types or to extract other information from the exception instance. <p>Exceptions from {@code Future.get} are treated as follows: <ul> <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an     {@code X} if the cause is a checked exception, an {@link     UncheckedExecutionException} if the cause is a {@code     RuntimeException}, or an {@link ExecutionError} if the cause is an     {@code Error}. <li>Any {@link InterruptedException} is wrapped in an {@code X} (after     restoring the interrupt). <li>Any {@link TimeoutException} is wrapped in an {@code X}. <li>Any {@link CancellationException} is propagated untouched, as is any     other {@link RuntimeException} (though {@code get} implementations are     discouraged from throwing such exceptions). </ul> <p>The overall principle is to continue to treat every checked exception as a checked exception, every unchecked exception as an unchecked exception, and every error as an error. In addition, the cause of any {@code ExecutionException} is wrapped in order to ensure that the new stack trace matches that of the current thread. <p>Instances of {@code exceptionClass} are created by choosing an arbitrary public constructor that accepts zero or more arguments, all of type {@code String} or {@code Throwable} (preferring constructors with at least one {@code String}) and calling the constructor via reflection. If the exception did not already have a cause, one is set by calling {@link Throwable#initCause(Throwable)} on it. If no such constructor exists, an {@code IllegalArgumentException} is thrown.    @throws if get throws any checked exception except for an ExecutionException whose cause is not itself a checked exception@throws if get throws an ExecutionException with a RuntimeException as its cause@throws if get throws an ExecutionException with an Error as its cause@throws if get throws a CancellationException@throws if exceptionClass extends RuntimeException or does not have a suitable constructor;false
com.google.common.util.concurrent.Futures;V get(Future future, long timeout, TimeUnit unit, Class exceptionClass);V getUnchecked(Future future);@throws;;;if get throws an ExecutionException with an Error as its cause;true
com.google.common.util.concurrent.Futures;V get(Future future, long timeout, TimeUnit unit, Class exceptionClass);V getUnchecked(Future future);@throws;;;if get throws a CancellationException;true
com.google.common.util.concurrent.Futures;V getChecked(Future future, Class exceptionClass);V getChecked(Future future, Class exceptionClass, long timeout, TimeUnit unit);@throws;;;if get throws any checked exception except for an ExecutionException whose cause is not itself a checked exception;true
com.google.common.util.concurrent.Futures;V getChecked(Future future, Class exceptionClass);V getChecked(Future future, Class exceptionClass, long timeout, TimeUnit unit);@throws;;;if get throws an ExecutionException with a RuntimeException as its cause;true
com.google.common.util.concurrent.Futures;V getChecked(Future future, Class exceptionClass);V getChecked(Future future, Class exceptionClass, long timeout, TimeUnit unit);@throws;;;if get throws an ExecutionException with an Error as its cause;true
com.google.common.util.concurrent.Futures;V getChecked(Future future, Class exceptionClass);V getChecked(Future future, Class exceptionClass, long timeout, TimeUnit unit);@throws;;;if get throws a CancellationException;true
com.google.common.util.concurrent.Futures;V getChecked(Future future, Class exceptionClass);V getChecked(Future future, Class exceptionClass, long timeout, TimeUnit unit);@throws;;;if exceptionClass extends RuntimeException or does not have a suitable constructor;true
com.google.common.util.concurrent.Futures;V getChecked(Future future, Class exceptionClass);V getUnchecked(Future future);@throws;;;if get throws an ExecutionException with an Error as its cause;true
com.google.common.util.concurrent.Futures;V getChecked(Future future, Class exceptionClass);V getUnchecked(Future future);@throws;;;if get throws a CancellationException;true
com.google.common.util.concurrent.Futures;V getChecked(Future future, Class exceptionClass, long timeout, TimeUnit unit);V getUnchecked(Future future);@throws;;;if get throws an ExecutionException with an Error as its cause;true
com.google.common.util.concurrent.Futures;V getChecked(Future future, Class exceptionClass, long timeout, TimeUnit unit);V getUnchecked(Future future);@throws;;;if get throws a CancellationException;true
com.google.common.util.concurrent.Monitor;void enterInterruptibly();boolean enterInterruptibly(long time, TimeUnit unit);@throws;;;if interrupted while waiting;true
com.google.common.util.concurrent.Monitor;void enterInterruptibly();void enterWhen(Guard guard);@throws;;;if interrupted while waiting;true
com.google.common.util.concurrent.Monitor;void enterInterruptibly();boolean enterWhen(Guard guard, long time, TimeUnit unit);@throws;;;if interrupted while waiting;true
com.google.common.util.concurrent.Monitor;void enterInterruptibly();boolean enterIfInterruptibly(Guard guard);@throws;;;if interrupted while waiting;true
com.google.common.util.concurrent.Monitor;void enterInterruptibly();void waitFor(Guard guard);@throws;;;if interrupted while waiting;true
com.google.common.util.concurrent.Monitor;void enterInterruptibly();boolean waitFor(Guard guard, long time, TimeUnit unit);@throws;;;if interrupted while waiting;true
com.google.common.util.concurrent.Monitor;boolean enter(long time, TimeUnit unit);boolean enterInterruptibly(long time, TimeUnit unit);@return;;;whether the monitor was entered;false
com.google.common.util.concurrent.Monitor;boolean enter(long time, TimeUnit unit);boolean tryEnter();@return;;;whether the monitor was entered;false
com.google.common.util.concurrent.Monitor;boolean enterInterruptibly(long time, TimeUnit unit);boolean tryEnter();@return;;;whether the monitor was entered;false
com.google.common.util.concurrent.Monitor;boolean enterInterruptibly(long time, TimeUnit unit);void enterWhen(Guard guard);@throws;;;if interrupted while waiting;true
com.google.common.util.concurrent.Monitor;boolean enterInterruptibly(long time, TimeUnit unit);boolean enterWhen(Guard guard, long time, TimeUnit unit);@throws;;;if interrupted while waiting;true
com.google.common.util.concurrent.Monitor;boolean enterInterruptibly(long time, TimeUnit unit);boolean enterIfInterruptibly(Guard guard);@throws;;;if interrupted while waiting;true
com.google.common.util.concurrent.Monitor;boolean enterInterruptibly(long time, TimeUnit unit);void waitFor(Guard guard);@throws;;;if interrupted while waiting;true
com.google.common.util.concurrent.Monitor;boolean enterInterruptibly(long time, TimeUnit unit);boolean waitFor(Guard guard, long time, TimeUnit unit);@throws;;;if interrupted while waiting;true
com.google.common.util.concurrent.Monitor;void enterWhen(Guard guard);boolean enterWhen(Guard guard, long time, TimeUnit unit);@throws;;;if interrupted while waiting;true
com.google.common.util.concurrent.Monitor;void enterWhen(Guard guard);boolean enterIfInterruptibly(Guard guard);@throws;;;if interrupted while waiting;true
com.google.common.util.concurrent.Monitor;void enterWhen(Guard guard);void waitFor(Guard guard);@throws;;;if interrupted while waiting;true
com.google.common.util.concurrent.Monitor;void enterWhen(Guard guard);boolean waitFor(Guard guard, long time, TimeUnit unit);@throws;;;if interrupted while waiting;true
com.google.common.util.concurrent.Monitor;boolean enterWhen(Guard guard, long time, TimeUnit unit);boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit);@return;;;whether the monitor was entered, which guarantees that the guard is now satisfied;false
com.google.common.util.concurrent.Monitor;boolean enterWhen(Guard guard, long time, TimeUnit unit);boolean enterIf(Guard guard);@return;;;whether the monitor was entered, which guarantees that the guard is now satisfied;false
com.google.common.util.concurrent.Monitor;boolean enterWhen(Guard guard, long time, TimeUnit unit);boolean enterIfInterruptibly(Guard guard);@return;;;whether the monitor was entered, which guarantees that the guard is now satisfied;false
com.google.common.util.concurrent.Monitor;boolean enterWhen(Guard guard, long time, TimeUnit unit);boolean enterIfInterruptibly(Guard guard);@throws;;;if interrupted while waiting;true
com.google.common.util.concurrent.Monitor;boolean enterWhen(Guard guard, long time, TimeUnit unit);boolean enterIf(Guard guard, long time, TimeUnit unit);@return;;;whether the monitor was entered, which guarantees that the guard is now satisfied;false
com.google.common.util.concurrent.Monitor;boolean enterWhen(Guard guard, long time, TimeUnit unit);boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit);@return;;;whether the monitor was entered, which guarantees that the guard is now satisfied;false
com.google.common.util.concurrent.Monitor;boolean enterWhen(Guard guard, long time, TimeUnit unit);boolean tryEnterIf(Guard guard);@return;;;whether the monitor was entered, which guarantees that the guard is now satisfied;false
com.google.common.util.concurrent.Monitor;boolean enterWhen(Guard guard, long time, TimeUnit unit);void waitFor(Guard guard);@throws;;;if interrupted while waiting;true
com.google.common.util.concurrent.Monitor;boolean enterWhen(Guard guard, long time, TimeUnit unit);boolean waitFor(Guard guard, long time, TimeUnit unit);@throws;;;if interrupted while waiting;true
com.google.common.util.concurrent.Monitor;boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit);boolean enterIf(Guard guard);@return;;;whether the monitor was entered, which guarantees that the guard is now satisfied;false
com.google.common.util.concurrent.Monitor;boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit);boolean enterIfInterruptibly(Guard guard);@return;;;whether the monitor was entered, which guarantees that the guard is now satisfied;false
com.google.common.util.concurrent.Monitor;boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit);boolean enterIf(Guard guard, long time, TimeUnit unit);@return;;;whether the monitor was entered, which guarantees that the guard is now satisfied;false
com.google.common.util.concurrent.Monitor;boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit);boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit);@return;;;whether the monitor was entered, which guarantees that the guard is now satisfied;false
com.google.common.util.concurrent.Monitor;boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit);boolean tryEnterIf(Guard guard);@return;;;whether the monitor was entered, which guarantees that the guard is now satisfied;false
com.google.common.util.concurrent.Monitor;boolean enterIf(Guard guard);boolean enterIfInterruptibly(Guard guard);@return;;;whether the monitor was entered, which guarantees that the guard is now satisfied;false
com.google.common.util.concurrent.Monitor;boolean enterIf(Guard guard);boolean enterIf(Guard guard, long time, TimeUnit unit);@return;;;whether the monitor was entered, which guarantees that the guard is now satisfied;true
com.google.common.util.concurrent.Monitor;boolean enterIf(Guard guard);boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit);@return;;;whether the monitor was entered, which guarantees that the guard is now satisfied;false
com.google.common.util.concurrent.Monitor;boolean enterIf(Guard guard);boolean tryEnterIf(Guard guard);@return;;;whether the monitor was entered, which guarantees that the guard is now satisfied;false
com.google.common.util.concurrent.Monitor;boolean enterIfInterruptibly(Guard guard);boolean enterIf(Guard guard, long time, TimeUnit unit);@return;;;whether the monitor was entered, which guarantees that the guard is now satisfied;false
com.google.common.util.concurrent.Monitor;boolean enterIfInterruptibly(Guard guard);boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit);@return;;;whether the monitor was entered, which guarantees that the guard is now satisfied;true
com.google.common.util.concurrent.Monitor;boolean enterIfInterruptibly(Guard guard);boolean tryEnterIf(Guard guard);@return;;;whether the monitor was entered, which guarantees that the guard is now satisfied;false
com.google.common.util.concurrent.Monitor;boolean enterIfInterruptibly(Guard guard);void waitFor(Guard guard);@throws;;;if interrupted while waiting;true
com.google.common.util.concurrent.Monitor;boolean enterIfInterruptibly(Guard guard);boolean waitFor(Guard guard, long time, TimeUnit unit);@throws;;;if interrupted while waiting;true
com.google.common.util.concurrent.Monitor;boolean enterIf(Guard guard, long time, TimeUnit unit);boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit);@return;;;whether the monitor was entered, which guarantees that the guard is now satisfied;false
com.google.common.util.concurrent.Monitor;boolean enterIf(Guard guard, long time, TimeUnit unit);boolean tryEnterIf(Guard guard);@return;;;whether the monitor was entered, which guarantees that the guard is now satisfied;false
com.google.common.util.concurrent.Monitor;boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit);boolean tryEnterIf(Guard guard);@return;;;whether the monitor was entered, which guarantees that the guard is now satisfied;false
com.google.common.util.concurrent.Monitor;void waitFor(Guard guard);boolean waitFor(Guard guard, long time, TimeUnit unit);@throws;;;if interrupted while waiting;true
com.google.common.util.concurrent.Monitor;boolean waitFor(Guard guard, long time, TimeUnit unit);boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit);@return;;;whether the guard is now satisfied;false
com.google.common.util.concurrent.ListeningExecutorService;ListenableFuture submit(Callable task);ListenableFuture submit(Runnable task);Whole;;;  @return a ListenableFuture representing pending completion of the task @throws {@inheritDoc};false
com.google.common.util.concurrent.ListeningExecutorService;ListenableFuture submit(Callable task);ListenableFuture submit(Runnable task, T result);Whole;;;  @return a ListenableFuture representing pending completion of the task @throws {@inheritDoc};false
com.google.common.util.concurrent.ListeningExecutorService;ListenableFuture submit(Callable task);List invokeAll(Collection tasks);@throws;;;{@inheritDoc};true
com.google.common.util.concurrent.ListeningExecutorService;ListenableFuture submit(Callable task);List invokeAll(Collection tasks, long timeout, TimeUnit unit);@throws;;;{@inheritDoc};true
com.google.common.util.concurrent.ListeningExecutorService;ListenableFuture submit(Runnable task);ListenableFuture submit(Runnable task, T result);Whole;;;  @return a ListenableFuture representing pending completion of the task @throws {@inheritDoc};false
com.google.common.util.concurrent.ListeningExecutorService;ListenableFuture submit(Runnable task);List invokeAll(Collection tasks);@throws;;;{@inheritDoc};true
com.google.common.util.concurrent.ListeningExecutorService;ListenableFuture submit(Runnable task);List invokeAll(Collection tasks, long timeout, TimeUnit unit);@throws;;;{@inheritDoc};true
com.google.common.util.concurrent.ListeningExecutorService;ListenableFuture submit(Runnable task, T result);List invokeAll(Collection tasks);@throws;;;{@inheritDoc};true
com.google.common.util.concurrent.ListeningExecutorService;ListenableFuture submit(Runnable task, T result);List invokeAll(Collection tasks, long timeout, TimeUnit unit);@throws;;;{@inheritDoc};true
com.google.common.util.concurrent.ListeningExecutorService;List invokeAll(Collection tasks);List invokeAll(Collection tasks, long timeout, TimeUnit unit);@throws;;;{@inheritDoc};true
com.google.common.util.concurrent.ListeningExecutorService;List invokeAll(Collection tasks);List invokeAll(Collection tasks, long timeout, TimeUnit unit);@throws;;;if any task is null;true
com.google.common.util.concurrent.CheckedFuture;V checkedGet();V checkedGet(long timeout, TimeUnit unit);@return;;;the result of executing the future.;true
com.google.common.util.concurrent.CheckedFuture;V checkedGet();V checkedGet(long timeout, TimeUnit unit);@throws;;;on interruption, cancellation or execution exceptions.;true
com.google.common.hash.Hashing;HashCode combineOrdered(Iterable hashCodes);HashCode combineUnordered(Iterable hashCodes);@throws;;;if hashCodes is empty, or the hash codes do not all have the same bit length;true
com.google.common.hash.Hashing;HashFunction concatenating(HashFunction first, HashFunction second, HashFunction rest);HashFunction concatenating(Iterable hashFunctions);Whole;;;Returns a hash function which computes its hash code by concatenating the hash codes of the underlying hash functions together. This can be useful if you need to generate hash codes of a specific length. <p>For example, if you need 1024-bit hash codes, you could join two {@link Hashing#sha512} hash functions together: {@code Hashing.concatenating(Hashing.sha512(), Hashing.sha512())}.    ;false
com.google.common.hash.PrimitiveSink;PrimitiveSink putByte(byte b);PrimitiveSink putBytes(byte[] bytes);@return;;;this instance;false
com.google.common.hash.PrimitiveSink;PrimitiveSink putByte(byte b);PrimitiveSink putBytes(byte[] bytes, int off, int len);@return;;;this instance;false
com.google.common.hash.PrimitiveSink;PrimitiveSink putBytes(byte[] bytes);PrimitiveSink putBytes(byte[] bytes, int off, int len);@return;;;this instance;true
com.google.common.hash.PrimitiveSink;PrimitiveSink putBytes(byte[] bytes);PrimitiveSink putBytes(byte[] bytes, int off, int len);@param;byte[] bytes;byte[] bytes;a byte array;true
com.google.common.hash.BloomFilter;BloomFilter create(Funnel funnel, int expectedInsertions, double fpp);BloomFilter create(Funnel funnel, long expectedInsertions, double fpp);Whole;;;Creates a {@link BloomFilter BloomFilter<T>} with the expected number of insertions and expected false positive probability. <p>Note that overflowing a {@code BloomFilter} with significantly more elements than specified, will result in its saturation, and a sharp deterioration of its false positive probability. <p>The constructed {@code BloomFilter<T>} will be serializable if the provided {@code Funnel<T>} is. <p>It is recommended that the funnel be implemented as a Java enum. This has the benefit of ensuring proper serialization and deserialization, which is important since {@link #equals} also relies on object identity of funnels.  @param the funnel of T's that the constructed BloomFilter<T> will use@param the number of expected insertions to the constructed BloomFilter<T>, must be positive@param the desired false positive probability (must be positive and less than 1.0) @return a BloomFilter ;false
com.google.common.hash.BloomFilter;BloomFilter create(Funnel funnel, int expectedInsertions, double fpp);BloomFilter create(Funnel funnel, int expectedInsertions);@return;;;a BloomFilter;true
com.google.common.hash.BloomFilter;BloomFilter create(Funnel funnel, int expectedInsertions, double fpp);BloomFilter create(Funnel funnel, int expectedInsertions);@param;Funnel<? super T> funnel;Funnel<? super T> funnel;the funnel of T's that the constructed BloomFilter<T> will use;true
com.google.common.hash.BloomFilter;BloomFilter create(Funnel funnel, int expectedInsertions, double fpp);BloomFilter create(Funnel funnel, int expectedInsertions);@param;int expectedInsertions;int expectedInsertions;the number of expected insertions to the constructed BloomFilter<T>, must be positive;true
com.google.common.hash.BloomFilter;BloomFilter create(Funnel funnel, int expectedInsertions, double fpp);BloomFilter create(Funnel funnel, long expectedInsertions);@return;;;a BloomFilter;true
com.google.common.hash.BloomFilter;BloomFilter create(Funnel funnel, int expectedInsertions, double fpp);BloomFilter create(Funnel funnel, long expectedInsertions);@param;Funnel<? super T> funnel;Funnel<? super T> funnel;the funnel of T's that the constructed BloomFilter<T> will use;true
com.google.common.hash.BloomFilter;BloomFilter create(Funnel funnel, int expectedInsertions, double fpp);BloomFilter create(Funnel funnel, long expectedInsertions);@param;int expectedInsertions;long expectedInsertions;the number of expected insertions to the constructed BloomFilter<T>, must be positive;true
com.google.common.hash.BloomFilter;BloomFilter create(Funnel funnel, long expectedInsertions, double fpp);BloomFilter create(Funnel funnel, int expectedInsertions);@return;;;a BloomFilter;true
com.google.common.hash.BloomFilter;BloomFilter create(Funnel funnel, long expectedInsertions, double fpp);BloomFilter create(Funnel funnel, int expectedInsertions);@param;Funnel<? super T> funnel;Funnel<? super T> funnel;the funnel of T's that the constructed BloomFilter<T> will use;true
com.google.common.hash.BloomFilter;BloomFilter create(Funnel funnel, long expectedInsertions, double fpp);BloomFilter create(Funnel funnel, int expectedInsertions);@param;long expectedInsertions;int expectedInsertions;the number of expected insertions to the constructed BloomFilter<T>, must be positive;true
com.google.common.hash.BloomFilter;BloomFilter create(Funnel funnel, long expectedInsertions, double fpp);BloomFilter create(Funnel funnel, long expectedInsertions);@return;;;a BloomFilter;true
com.google.common.hash.BloomFilter;BloomFilter create(Funnel funnel, long expectedInsertions, double fpp);BloomFilter create(Funnel funnel, long expectedInsertions);@param;Funnel<? super T> funnel;Funnel<? super T> funnel;the funnel of T's that the constructed BloomFilter<T> will use;true
com.google.common.hash.BloomFilter;BloomFilter create(Funnel funnel, long expectedInsertions, double fpp);BloomFilter create(Funnel funnel, long expectedInsertions);@param;long expectedInsertions;long expectedInsertions;the number of expected insertions to the constructed BloomFilter<T>, must be positive;true
com.google.common.hash.BloomFilter;BloomFilter create(Funnel funnel, int expectedInsertions);BloomFilter create(Funnel funnel, long expectedInsertions);Whole;;;Creates a {@link BloomFilter BloomFilter<T>} with the expected number of insertions and a default expected false positive probability of 3%. <p>Note that overflowing a {@code BloomFilter} with significantly more elements than specified, will result in its saturation, and a sharp deterioration of its false positive probability. <p>The constructed {@code BloomFilter<T>} will be serializable if the provided {@code Funnel<T>} is. <p>It is recommended that the funnel be implemented as a Java enum. This has the benefit of ensuring proper serialization and deserialization, which is important since {@link #equals} also relies on object identity of funnels.  @param the funnel of T's that the constructed BloomFilter<T> will use@param the number of expected insertions to the constructed BloomFilter<T>, must be positive @return a BloomFilter ;false
com.google.common.hash.BloomFilter;int optimalNumOfHashFunctions(long n, long m);long optimalNumOfBits(long n, double p);@param;long n;long n;expected insertions (must be positive);true
com.google.common.hash.HashingInputStream;boolean markSupported();void mark(int readlimit);Free text;;;mark() is not supported for HashingInputStream ;false
com.google.common.reflect.ImmutableTypeToInstanceMap;T putInstance(TypeToken type, T value);T putInstance(Class type, T value);Whole;;;Guaranteed to throw an exception and leave the map unmodified.    @throws always;false
com.google.common.reflect.TypeToken;TypeToken where(TypeParameter typeParam, TypeToken typeArg);TypeToken where(TypeParameter typeParam, Class typeArg);@param;TypeParameter<X> typeParam;TypeParameter<X> typeParam;the parameter type variable;true
com.google.common.reflect.TypeToken;TypeToken where(TypeParameter typeParam, TypeToken typeArg);TypeToken where(TypeParameter typeParam, Class typeArg);@param;TypeToken<X> typeArg;Class<X> typeArg;the actual type to substitute;true
com.google.common.reflect.TypeToken;boolean isSupertypeOf(TypeToken type);boolean isSupertypeOf(Type type);Whole;;;Returns true if this type is a supertype of the given {@code type}. "Supertype" is defined according to <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1" >the rules for type arguments</a> introduced with Java generics.    ;false
com.google.common.reflect.TypeToken;boolean isSubtypeOf(TypeToken type);boolean isSubtypeOf(Type supertype);Whole;;;Returns true if this type is a subtype of the given {@code type}. "Subtype" is defined according to <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1" >the rules for type arguments</a> introduced with Java generics.    ;false
com.google.common.io.CharSource;Reader openStream();BufferedReader openBufferedStream();@throws;;;if an I/O error occurs in the process of opening the reader;true
com.google.common.io.CharSource;String read();String readFirstLine();@throws;;;if an I/O error occurs in the process of reading from this source;true
com.google.common.io.CharSource;String read();ImmutableList readLines();@throws;;;if an I/O error occurs in the process of reading from this source;true
com.google.common.io.CharSource;String readFirstLine();ImmutableList readLines();@throws;;;if an I/O error occurs in the process of reading from this source;true
com.google.common.io.CharSource;CharSource concat(Iterable sources);CharSource concat(Iterator sources);@return;;;a CharSource containing the concatenated data;true
com.google.common.io.CharSource;CharSource concat(Iterable sources);CharSource concat(Iterator sources);@param;Iterable<? extends CharSource> sources;Iterator<? extends CharSource> sources;the sources to concatenate;true
com.google.common.io.CharSource;CharSource concat(Iterable sources);CharSource concat(CharSource sources);@return;;;a CharSource containing the concatenated data;true
com.google.common.io.CharSource;CharSource concat(Iterable sources);CharSource concat(CharSource sources);@param;Iterable<? extends CharSource> sources;CharSource sources;the sources to concatenate;true
com.google.common.io.CharSource;CharSource concat(Iterator sources);CharSource concat(CharSource sources);@return;;;a CharSource containing the concatenated data;true
com.google.common.io.CharSource;CharSource concat(Iterator sources);CharSource concat(CharSource sources);@param;Iterator<? extends CharSource> sources;CharSource sources;the sources to concatenate;true
com.google.common.io.CharSource;CharSource concat(Iterator sources);CharSource concat(CharSource sources);@throws;;;if any of sources is null;true
com.google.common.io.CharSink;Writer openStream();Writer openBufferedStream();@throws;;;if an I/O error occurs in the process of opening the writer;true
com.google.common.io.CharSink;void writeLines(Iterable lines);void writeLines(Iterable lines, String lineSeparator);@throws;;;if an I/O error occurs in the process of writing to this sink;true
com.google.common.io.ByteSink;OutputStream openStream();OutputStream openBufferedStream();@throws;;;if an I/O error occurs in the process of opening the stream;true
com.google.common.io.Closer;RuntimeException rethrow(Throwable e);RuntimeException rethrow(Throwable e, Class declaredType);@return;;;this method does not return, it always throws;true
com.google.common.io.Closer;RuntimeException rethrow(Throwable e);RuntimeException rethrow(Throwable e, Class declaredType);@throws;;;when the given throwable is an IOException;true
com.google.common.io.Closer;RuntimeException rethrow(Throwable e);RuntimeException rethrow(Throwable e, Class declaredType1, Class declaredType2);@return;;;this method does not return, it always throws;true
com.google.common.io.Closer;RuntimeException rethrow(Throwable e);RuntimeException rethrow(Throwable e, Class declaredType1, Class declaredType2);@throws;;;when the given throwable is an IOException;true
com.google.common.io.Closer;RuntimeException rethrow(Throwable e, Class declaredType);RuntimeException rethrow(Throwable e, Class declaredType1, Class declaredType2);@return;;;this method does not return, it always throws;true
com.google.common.io.Closer;RuntimeException rethrow(Throwable e, Class declaredType);RuntimeException rethrow(Throwable e, Class declaredType1, Class declaredType2);@throws;;;when the given throwable is an IOException;true
com.google.common.io.PatternFilenameFilter; PatternFilenameFilter(String patternStr); PatternFilenameFilter(Pattern pattern);Free text;;;Constructs a pattern file name filter object. ;true
com.google.common.io.BaseEncoding;byte[] decode(CharSequence chars);byte[] decodeChecked(CharSequence chars);Whole;;;Decodes the specified character sequence, and returns the resulting {@code byte[]}. This is the inverse operation to {@link #encode(byte[])}.    @throws if the input is not a valid encoded string according to this encoding.;false
com.google.common.io.BaseEncoding;BaseEncoding upperCase();BaseEncoding lowerCase();@throws;;;if the alphabet used by this encoding contains mixed upper- and lower-case characters;true
com.google.common.io.LineBuffer;void add(char[] cbuf, int off, int len);void finish();@throws;;;if an I/O error occurs;true
com.google.common.io.LineBuffer;void add(char[] cbuf, int off, int len);void handleLine(String line, String end);@throws;;;if an I/O error occurs;true
com.google.common.io.LineBuffer;void finish();void handleLine(String line, String end);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;BufferedReader newReader(File file, Charset charset);byte[] toByteArray(File file);@param;File file;File file;the file to read from;true
com.google.common.io.Files;BufferedReader newReader(File file, Charset charset);String toString(File file, Charset charset);@param;File file;File file;the file to read from;true
com.google.common.io.Files;BufferedReader newReader(File file, Charset charset);String toString(File file, Charset charset);@param;Charset charset;Charset charset;the charset used to decode the input stream, see Charsets for helpful predefined constants;true
com.google.common.io.Files;BufferedReader newReader(File file, Charset charset);void copy(File from, Charset charset, Appendable to);@param;Charset charset;Charset charset;the charset used to decode the input stream, see Charsets for helpful predefined constants;true
com.google.common.io.Files;BufferedReader newReader(File file, Charset charset);String readFirstLine(File file, Charset charset);@param;File file;File file;the file to read from;true
com.google.common.io.Files;BufferedReader newReader(File file, Charset charset);String readFirstLine(File file, Charset charset);@param;Charset charset;Charset charset;the charset used to decode the input stream, see Charsets for helpful predefined constants;true
com.google.common.io.Files;BufferedReader newReader(File file, Charset charset);List readLines(File file, Charset charset);@param;File file;File file;the file to read from;true
com.google.common.io.Files;BufferedReader newReader(File file, Charset charset);List readLines(File file, Charset charset);@param;Charset charset;Charset charset;the charset used to decode the input stream, see Charsets for helpful predefined constants;true
com.google.common.io.Files;BufferedReader newReader(File file, Charset charset);T readLines(File file, Charset charset, LineProcessor callback);@param;File file;File file;the file to read from;true
com.google.common.io.Files;BufferedReader newReader(File file, Charset charset);T readLines(File file, Charset charset, LineProcessor callback);@param;Charset charset;Charset charset;the charset used to decode the input stream, see Charsets for helpful predefined constants;true
com.google.common.io.Files;BufferedWriter newWriter(File file, Charset charset);void write(CharSequence from, File to, Charset charset);@param;Charset charset;Charset charset;the charset used to encode the output stream, see Charsets for helpful predefined constants;true
com.google.common.io.Files;BufferedWriter newWriter(File file, Charset charset);void append(CharSequence from, File to, Charset charset);@param;Charset charset;Charset charset;the charset used to encode the output stream, see Charsets for helpful predefined constants;true
com.google.common.io.Files;byte[] toByteArray(File file);String toString(File file, Charset charset);@param;File file;File file;the file to read from;true
com.google.common.io.Files;byte[] toByteArray(File file);String toString(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;byte[] toByteArray(File file);void write(byte[] from, File to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;byte[] toByteArray(File file);void copy(File from, OutputStream to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;byte[] toByteArray(File file);void copy(File from, File to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;byte[] toByteArray(File file);void write(CharSequence from, File to, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;byte[] toByteArray(File file);void append(CharSequence from, File to, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;byte[] toByteArray(File file);void copy(File from, Charset charset, Appendable to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;byte[] toByteArray(File file);boolean equal(File file1, File file2);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;byte[] toByteArray(File file);void touch(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;byte[] toByteArray(File file);void move(File from, File to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;byte[] toByteArray(File file);String readFirstLine(File file, Charset charset);@param;File file;File file;the file to read from;true
com.google.common.io.Files;byte[] toByteArray(File file);String readFirstLine(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;byte[] toByteArray(File file);List readLines(File file, Charset charset);@param;File file;File file;the file to read from;true
com.google.common.io.Files;byte[] toByteArray(File file);List readLines(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;byte[] toByteArray(File file);T readLines(File file, Charset charset, LineProcessor callback);@param;File file;File file;the file to read from;true
com.google.common.io.Files;byte[] toByteArray(File file);T readLines(File file, Charset charset, LineProcessor callback);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;byte[] toByteArray(File file);T readBytes(File file, ByteProcessor processor);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;byte[] toByteArray(File file);HashCode hash(File file, HashFunction hashFunction);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;byte[] toByteArray(File file);MappedByteBuffer map(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;byte[] toByteArray(File file);MappedByteBuffer map(File file, MapMode mode);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;byte[] toByteArray(File file);MappedByteBuffer map(File file, MapMode mode, long size);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String toString(File file, Charset charset);void write(byte[] from, File to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String toString(File file, Charset charset);void copy(File from, OutputStream to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String toString(File file, Charset charset);void copy(File from, File to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String toString(File file, Charset charset);void write(CharSequence from, File to, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String toString(File file, Charset charset);void append(CharSequence from, File to, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String toString(File file, Charset charset);void copy(File from, Charset charset, Appendable to);@param;Charset charset;Charset charset;the charset used to decode the input stream, see Charsets for helpful predefined constants;true
com.google.common.io.Files;String toString(File file, Charset charset);void copy(File from, Charset charset, Appendable to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String toString(File file, Charset charset);boolean equal(File file1, File file2);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String toString(File file, Charset charset);void touch(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String toString(File file, Charset charset);void move(File from, File to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String toString(File file, Charset charset);String readFirstLine(File file, Charset charset);@param;File file;File file;the file to read from;true
com.google.common.io.Files;String toString(File file, Charset charset);String readFirstLine(File file, Charset charset);@param;Charset charset;Charset charset;the charset used to decode the input stream, see Charsets for helpful predefined constants;true
com.google.common.io.Files;String toString(File file, Charset charset);String readFirstLine(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String toString(File file, Charset charset);List readLines(File file, Charset charset);@param;File file;File file;the file to read from;true
com.google.common.io.Files;String toString(File file, Charset charset);List readLines(File file, Charset charset);@param;Charset charset;Charset charset;the charset used to decode the input stream, see Charsets for helpful predefined constants;true
com.google.common.io.Files;String toString(File file, Charset charset);List readLines(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String toString(File file, Charset charset);T readLines(File file, Charset charset, LineProcessor callback);@param;File file;File file;the file to read from;true
com.google.common.io.Files;String toString(File file, Charset charset);T readLines(File file, Charset charset, LineProcessor callback);@param;Charset charset;Charset charset;the charset used to decode the input stream, see Charsets for helpful predefined constants;true
com.google.common.io.Files;String toString(File file, Charset charset);T readLines(File file, Charset charset, LineProcessor callback);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String toString(File file, Charset charset);T readBytes(File file, ByteProcessor processor);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String toString(File file, Charset charset);HashCode hash(File file, HashFunction hashFunction);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String toString(File file, Charset charset);MappedByteBuffer map(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String toString(File file, Charset charset);MappedByteBuffer map(File file, MapMode mode);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String toString(File file, Charset charset);MappedByteBuffer map(File file, MapMode mode, long size);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(byte[] from, File to);void copy(File from, OutputStream to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(byte[] from, File to);void copy(File from, File to);@param;File to;File to;the destination file;true
com.google.common.io.Files;void write(byte[] from, File to);void copy(File from, File to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(byte[] from, File to);void write(CharSequence from, File to, Charset charset);@param;File to;File to;the destination file;true
com.google.common.io.Files;void write(byte[] from, File to);void write(CharSequence from, File to, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(byte[] from, File to);void append(CharSequence from, File to, Charset charset);@param;File to;File to;the destination file;true
com.google.common.io.Files;void write(byte[] from, File to);void append(CharSequence from, File to, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(byte[] from, File to);void copy(File from, Charset charset, Appendable to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(byte[] from, File to);boolean equal(File file1, File file2);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(byte[] from, File to);void touch(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(byte[] from, File to);void move(File from, File to);@param;File to;File to;the destination file;true
com.google.common.io.Files;void write(byte[] from, File to);void move(File from, File to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(byte[] from, File to);String readFirstLine(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(byte[] from, File to);List readLines(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(byte[] from, File to);T readLines(File file, Charset charset, LineProcessor callback);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(byte[] from, File to);T readBytes(File file, ByteProcessor processor);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(byte[] from, File to);HashCode hash(File file, HashFunction hashFunction);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(byte[] from, File to);MappedByteBuffer map(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(byte[] from, File to);MappedByteBuffer map(File file, MapMode mode);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(byte[] from, File to);MappedByteBuffer map(File file, MapMode mode, long size);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, OutputStream to);void copy(File from, File to);@param;File from;File from;the source file;true
com.google.common.io.Files;void copy(File from, OutputStream to);void copy(File from, File to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, OutputStream to);void write(CharSequence from, File to, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, OutputStream to);void append(CharSequence from, File to, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, OutputStream to);void copy(File from, Charset charset, Appendable to);@param;File from;File from;the source file;true
com.google.common.io.Files;void copy(File from, OutputStream to);void copy(File from, Charset charset, Appendable to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, OutputStream to);boolean equal(File file1, File file2);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, OutputStream to);void touch(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, OutputStream to);void move(File from, File to);@param;File from;File from;the source file;true
com.google.common.io.Files;void copy(File from, OutputStream to);void move(File from, File to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, OutputStream to);String readFirstLine(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, OutputStream to);List readLines(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, OutputStream to);T readLines(File file, Charset charset, LineProcessor callback);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, OutputStream to);T readBytes(File file, ByteProcessor processor);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, OutputStream to);HashCode hash(File file, HashFunction hashFunction);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, OutputStream to);MappedByteBuffer map(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, OutputStream to);MappedByteBuffer map(File file, MapMode mode);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, OutputStream to);MappedByteBuffer map(File file, MapMode mode, long size);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, File to);void write(CharSequence from, File to, Charset charset);@param;File to;File to;the destination file;true
com.google.common.io.Files;void copy(File from, File to);void write(CharSequence from, File to, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, File to);void append(CharSequence from, File to, Charset charset);@param;File to;File to;the destination file;true
com.google.common.io.Files;void copy(File from, File to);void append(CharSequence from, File to, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, File to);void copy(File from, Charset charset, Appendable to);@param;File from;File from;the source file;true
com.google.common.io.Files;void copy(File from, File to);void copy(File from, Charset charset, Appendable to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, File to);boolean equal(File file1, File file2);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, File to);void touch(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, File to);void move(File from, File to);@param;File from;File from;the source file;true
com.google.common.io.Files;void copy(File from, File to);void move(File from, File to);@param;File to;File to;the destination file;true
com.google.common.io.Files;void copy(File from, File to);void move(File from, File to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, File to);void move(File from, File to);@throws;;;if from.equals(to);true
com.google.common.io.Files;void copy(File from, File to);String readFirstLine(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, File to);List readLines(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, File to);T readLines(File file, Charset charset, LineProcessor callback);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, File to);T readBytes(File file, ByteProcessor processor);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, File to);HashCode hash(File file, HashFunction hashFunction);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, File to);MappedByteBuffer map(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, File to);MappedByteBuffer map(File file, MapMode mode);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, File to);MappedByteBuffer map(File file, MapMode mode, long size);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(CharSequence from, File to, Charset charset);void append(CharSequence from, File to, Charset charset);@param;File to;File to;the destination file;true
com.google.common.io.Files;void write(CharSequence from, File to, Charset charset);void append(CharSequence from, File to, Charset charset);@param;Charset charset;Charset charset;the charset used to encode the output stream, see Charsets for helpful predefined constants;true
com.google.common.io.Files;void write(CharSequence from, File to, Charset charset);void append(CharSequence from, File to, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(CharSequence from, File to, Charset charset);void copy(File from, Charset charset, Appendable to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(CharSequence from, File to, Charset charset);boolean equal(File file1, File file2);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(CharSequence from, File to, Charset charset);void touch(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(CharSequence from, File to, Charset charset);void move(File from, File to);@param;File to;File to;the destination file;true
com.google.common.io.Files;void write(CharSequence from, File to, Charset charset);void move(File from, File to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(CharSequence from, File to, Charset charset);String readFirstLine(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(CharSequence from, File to, Charset charset);List readLines(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(CharSequence from, File to, Charset charset);T readLines(File file, Charset charset, LineProcessor callback);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(CharSequence from, File to, Charset charset);T readBytes(File file, ByteProcessor processor);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(CharSequence from, File to, Charset charset);HashCode hash(File file, HashFunction hashFunction);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(CharSequence from, File to, Charset charset);MappedByteBuffer map(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(CharSequence from, File to, Charset charset);MappedByteBuffer map(File file, MapMode mode);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void write(CharSequence from, File to, Charset charset);MappedByteBuffer map(File file, MapMode mode, long size);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void append(CharSequence from, File to, Charset charset);void copy(File from, Charset charset, Appendable to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void append(CharSequence from, File to, Charset charset);boolean equal(File file1, File file2);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void append(CharSequence from, File to, Charset charset);void touch(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void append(CharSequence from, File to, Charset charset);void move(File from, File to);@param;File to;File to;the destination file;true
com.google.common.io.Files;void append(CharSequence from, File to, Charset charset);void move(File from, File to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void append(CharSequence from, File to, Charset charset);String readFirstLine(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void append(CharSequence from, File to, Charset charset);List readLines(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void append(CharSequence from, File to, Charset charset);T readLines(File file, Charset charset, LineProcessor callback);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void append(CharSequence from, File to, Charset charset);T readBytes(File file, ByteProcessor processor);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void append(CharSequence from, File to, Charset charset);HashCode hash(File file, HashFunction hashFunction);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void append(CharSequence from, File to, Charset charset);MappedByteBuffer map(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void append(CharSequence from, File to, Charset charset);MappedByteBuffer map(File file, MapMode mode);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void append(CharSequence from, File to, Charset charset);MappedByteBuffer map(File file, MapMode mode, long size);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, Charset charset, Appendable to);boolean equal(File file1, File file2);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, Charset charset, Appendable to);void touch(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, Charset charset, Appendable to);void move(File from, File to);@param;File from;File from;the source file;true
com.google.common.io.Files;void copy(File from, Charset charset, Appendable to);void move(File from, File to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, Charset charset, Appendable to);String readFirstLine(File file, Charset charset);@param;Charset charset;Charset charset;the charset used to decode the input stream, see Charsets for helpful predefined constants;true
com.google.common.io.Files;void copy(File from, Charset charset, Appendable to);String readFirstLine(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, Charset charset, Appendable to);List readLines(File file, Charset charset);@param;Charset charset;Charset charset;the charset used to decode the input stream, see Charsets for helpful predefined constants;true
com.google.common.io.Files;void copy(File from, Charset charset, Appendable to);List readLines(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, Charset charset, Appendable to);T readLines(File file, Charset charset, LineProcessor callback);@param;Charset charset;Charset charset;the charset used to decode the input stream, see Charsets for helpful predefined constants;true
com.google.common.io.Files;void copy(File from, Charset charset, Appendable to);T readLines(File file, Charset charset, LineProcessor callback);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, Charset charset, Appendable to);T readBytes(File file, ByteProcessor processor);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, Charset charset, Appendable to);HashCode hash(File file, HashFunction hashFunction);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, Charset charset, Appendable to);MappedByteBuffer map(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, Charset charset, Appendable to);MappedByteBuffer map(File file, MapMode mode);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void copy(File from, Charset charset, Appendable to);MappedByteBuffer map(File file, MapMode mode, long size);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;boolean equal(File file1, File file2);void touch(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;boolean equal(File file1, File file2);void move(File from, File to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;boolean equal(File file1, File file2);String readFirstLine(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;boolean equal(File file1, File file2);List readLines(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;boolean equal(File file1, File file2);T readLines(File file, Charset charset, LineProcessor callback);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;boolean equal(File file1, File file2);T readBytes(File file, ByteProcessor processor);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;boolean equal(File file1, File file2);HashCode hash(File file, HashFunction hashFunction);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;boolean equal(File file1, File file2);MappedByteBuffer map(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;boolean equal(File file1, File file2);MappedByteBuffer map(File file, MapMode mode);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;boolean equal(File file1, File file2);MappedByteBuffer map(File file, MapMode mode, long size);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void touch(File file);void move(File from, File to);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void touch(File file);String readFirstLine(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void touch(File file);List readLines(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void touch(File file);T readLines(File file, Charset charset, LineProcessor callback);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void touch(File file);T readBytes(File file, ByteProcessor processor);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void touch(File file);HashCode hash(File file, HashFunction hashFunction);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void touch(File file);MappedByteBuffer map(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void touch(File file);MappedByteBuffer map(File file, MapMode mode);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void touch(File file);MappedByteBuffer map(File file, MapMode mode, long size);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void move(File from, File to);String readFirstLine(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void move(File from, File to);List readLines(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void move(File from, File to);T readLines(File file, Charset charset, LineProcessor callback);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void move(File from, File to);T readBytes(File file, ByteProcessor processor);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void move(File from, File to);HashCode hash(File file, HashFunction hashFunction);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void move(File from, File to);MappedByteBuffer map(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void move(File from, File to);MappedByteBuffer map(File file, MapMode mode);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;void move(File from, File to);MappedByteBuffer map(File file, MapMode mode, long size);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String readFirstLine(File file, Charset charset);List readLines(File file, Charset charset);@param;File file;File file;the file to read from;true
com.google.common.io.Files;String readFirstLine(File file, Charset charset);List readLines(File file, Charset charset);@param;Charset charset;Charset charset;the charset used to decode the input stream, see Charsets for helpful predefined constants;true
com.google.common.io.Files;String readFirstLine(File file, Charset charset);List readLines(File file, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String readFirstLine(File file, Charset charset);T readLines(File file, Charset charset, LineProcessor callback);@param;File file;File file;the file to read from;true
com.google.common.io.Files;String readFirstLine(File file, Charset charset);T readLines(File file, Charset charset, LineProcessor callback);@param;Charset charset;Charset charset;the charset used to decode the input stream, see Charsets for helpful predefined constants;true
com.google.common.io.Files;String readFirstLine(File file, Charset charset);T readLines(File file, Charset charset, LineProcessor callback);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String readFirstLine(File file, Charset charset);T readBytes(File file, ByteProcessor processor);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String readFirstLine(File file, Charset charset);HashCode hash(File file, HashFunction hashFunction);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String readFirstLine(File file, Charset charset);MappedByteBuffer map(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String readFirstLine(File file, Charset charset);MappedByteBuffer map(File file, MapMode mode);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;String readFirstLine(File file, Charset charset);MappedByteBuffer map(File file, MapMode mode, long size);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;List readLines(File file, Charset charset);T readLines(File file, Charset charset, LineProcessor callback);@param;File file;File file;the file to read from;true
com.google.common.io.Files;List readLines(File file, Charset charset);T readLines(File file, Charset charset, LineProcessor callback);@param;Charset charset;Charset charset;the charset used to decode the input stream, see Charsets for helpful predefined constants;true
com.google.common.io.Files;List readLines(File file, Charset charset);T readLines(File file, Charset charset, LineProcessor callback);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;List readLines(File file, Charset charset);T readBytes(File file, ByteProcessor processor);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;List readLines(File file, Charset charset);HashCode hash(File file, HashFunction hashFunction);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;List readLines(File file, Charset charset);MappedByteBuffer map(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;List readLines(File file, Charset charset);MappedByteBuffer map(File file, MapMode mode);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;List readLines(File file, Charset charset);MappedByteBuffer map(File file, MapMode mode, long size);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;T readLines(File file, Charset charset, LineProcessor callback);T readBytes(File file, ByteProcessor processor);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;T readLines(File file, Charset charset, LineProcessor callback);HashCode hash(File file, HashFunction hashFunction);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;T readLines(File file, Charset charset, LineProcessor callback);MappedByteBuffer map(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;T readLines(File file, Charset charset, LineProcessor callback);MappedByteBuffer map(File file, MapMode mode);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;T readLines(File file, Charset charset, LineProcessor callback);MappedByteBuffer map(File file, MapMode mode, long size);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;T readBytes(File file, ByteProcessor processor);HashCode hash(File file, HashFunction hashFunction);@param;File file;File file;the file to read;true
com.google.common.io.Files;T readBytes(File file, ByteProcessor processor);HashCode hash(File file, HashFunction hashFunction);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;T readBytes(File file, ByteProcessor processor);MappedByteBuffer map(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;T readBytes(File file, ByteProcessor processor);MappedByteBuffer map(File file, MapMode mode);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;T readBytes(File file, ByteProcessor processor);MappedByteBuffer map(File file, MapMode mode, long size);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;HashCode hash(File file, HashFunction hashFunction);MappedByteBuffer map(File file);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;HashCode hash(File file, HashFunction hashFunction);MappedByteBuffer map(File file, MapMode mode);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;HashCode hash(File file, HashFunction hashFunction);MappedByteBuffer map(File file, MapMode mode, long size);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;MappedByteBuffer map(File file);MappedByteBuffer map(File file, MapMode mode);@param;File file;File file;the file to map;true
com.google.common.io.Files;MappedByteBuffer map(File file);MappedByteBuffer map(File file, MapMode mode);@throws;;;if the file does not exist;true
com.google.common.io.Files;MappedByteBuffer map(File file);MappedByteBuffer map(File file, MapMode mode);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;MappedByteBuffer map(File file);MappedByteBuffer map(File file, MapMode mode, long size);@param;File file;File file;the file to map;true
com.google.common.io.Files;MappedByteBuffer map(File file);MappedByteBuffer map(File file, MapMode mode, long size);@throws;;;if an I/O error occurs;true
com.google.common.io.Files;MappedByteBuffer map(File file, MapMode mode);MappedByteBuffer map(File file, MapMode mode, long size);@return;;;a buffer reflecting file;true
com.google.common.io.Files;MappedByteBuffer map(File file, MapMode mode);MappedByteBuffer map(File file, MapMode mode, long size);@param;File file;File file;the file to map;true
com.google.common.io.Files;MappedByteBuffer map(File file, MapMode mode);MappedByteBuffer map(File file, MapMode mode, long size);@param;MapMode mode;MapMode mode;the mode to use when mapping file;true
com.google.common.io.Files;MappedByteBuffer map(File file, MapMode mode);MappedByteBuffer map(File file, MapMode mode, long size);@throws;;;if an I/O error occurs;true
com.google.common.io.CharStreams;long copy(Readable from, Appendable to);String toString(Readable r);@param;Readable from;Readable r;the object to read from;false
com.google.common.io.CharStreams;long copy(Readable from, Appendable to);String toString(Readable r);@throws;;;if an I/O error occurs;true
com.google.common.io.CharStreams;long copy(Readable from, Appendable to);List readLines(Readable r);@param;Readable from;Readable r;the object to read from;false
com.google.common.io.CharStreams;long copy(Readable from, Appendable to);List readLines(Readable r);@throws;;;if an I/O error occurs;true
com.google.common.io.CharStreams;long copy(Readable from, Appendable to);T readLines(Readable readable, LineProcessor processor);@throws;;;if an I/O error occurs;true
com.google.common.io.CharStreams;long copy(Readable from, Appendable to);void skipFully(Reader reader, long n);@throws;;;if an I/O error occurs;true
com.google.common.io.CharStreams;String toString(Readable r);List readLines(Readable r);@param;Readable r;Readable r;the object to read from;true
com.google.common.io.CharStreams;String toString(Readable r);List readLines(Readable r);@throws;;;if an I/O error occurs;true
com.google.common.io.CharStreams;String toString(Readable r);T readLines(Readable readable, LineProcessor processor);@throws;;;if an I/O error occurs;true
com.google.common.io.CharStreams;String toString(Readable r);void skipFully(Reader reader, long n);@throws;;;if an I/O error occurs;true
com.google.common.io.CharStreams;List readLines(Readable r);T readLines(Readable readable, LineProcessor processor);@throws;;;if an I/O error occurs;true
com.google.common.io.CharStreams;List readLines(Readable r);void skipFully(Reader reader, long n);@throws;;;if an I/O error occurs;true
com.google.common.io.CharStreams;T readLines(Readable readable, LineProcessor processor);void skipFully(Reader reader, long n);@throws;;;if an I/O error occurs;true
com.google.common.io.Resources;byte[] toByteArray(URL url);String toString(URL url, Charset charset);@param;URL url;URL url;the URL to read from;true
com.google.common.io.Resources;byte[] toByteArray(URL url);T readLines(URL url, Charset charset, LineProcessor callback);@param;URL url;URL url;the URL to read from;true
com.google.common.io.Resources;byte[] toByteArray(URL url);T readLines(URL url, Charset charset, LineProcessor callback);@throws;;;if an I/O error occurs;true
com.google.common.io.Resources;byte[] toByteArray(URL url);List readLines(URL url, Charset charset);@param;URL url;URL url;the URL to read from;true
com.google.common.io.Resources;byte[] toByteArray(URL url);List readLines(URL url, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Resources;byte[] toByteArray(URL url);void copy(URL from, OutputStream to);@param;URL url;URL from;the URL to read from;false
com.google.common.io.Resources;byte[] toByteArray(URL url);void copy(URL from, OutputStream to);@throws;;;if an I/O error occurs;true
com.google.common.io.Resources;String toString(URL url, Charset charset);T readLines(URL url, Charset charset, LineProcessor callback);@param;URL url;URL url;the URL to read from;true
com.google.common.io.Resources;String toString(URL url, Charset charset);T readLines(URL url, Charset charset, LineProcessor callback);@param;Charset charset;Charset charset;the charset used to decode the input stream, see Charsets for helpful predefined constants;true
com.google.common.io.Resources;String toString(URL url, Charset charset);List readLines(URL url, Charset charset);@param;URL url;URL url;the URL to read from;true
com.google.common.io.Resources;String toString(URL url, Charset charset);List readLines(URL url, Charset charset);@param;Charset charset;Charset charset;the charset used to decode the input stream, see Charsets for helpful predefined constants;true
com.google.common.io.Resources;String toString(URL url, Charset charset);void copy(URL from, OutputStream to);@param;URL url;URL from;the URL to read from;false
com.google.common.io.Resources;T readLines(URL url, Charset charset, LineProcessor callback);List readLines(URL url, Charset charset);@param;URL url;URL url;the URL to read from;true
com.google.common.io.Resources;T readLines(URL url, Charset charset, LineProcessor callback);List readLines(URL url, Charset charset);@param;Charset charset;Charset charset;the charset used to decode the input stream, see Charsets for helpful predefined constants;true
com.google.common.io.Resources;T readLines(URL url, Charset charset, LineProcessor callback);List readLines(URL url, Charset charset);@throws;;;if an I/O error occurs;true
com.google.common.io.Resources;T readLines(URL url, Charset charset, LineProcessor callback);void copy(URL from, OutputStream to);@param;URL url;URL from;the URL to read from;false
com.google.common.io.Resources;T readLines(URL url, Charset charset, LineProcessor callback);void copy(URL from, OutputStream to);@throws;;;if an I/O error occurs;true
com.google.common.io.Resources;List readLines(URL url, Charset charset);void copy(URL from, OutputStream to);@param;URL url;URL from;the URL to read from;false
com.google.common.io.Resources;List readLines(URL url, Charset charset);void copy(URL from, OutputStream to);@throws;;;if an I/O error occurs;true
com.google.common.io.Resources;URL getResource(String resourceName);URL getResource(Class contextClass, String resourceName);@throws;;;if the resource is not found;true
com.google.common.io.ByteStreams;long copy(InputStream from, OutputStream to);long copy(ReadableByteChannel from, WritableByteChannel to);@return;;;the number of bytes copied;true
com.google.common.io.ByteStreams;long copy(InputStream from, OutputStream to);long copy(ReadableByteChannel from, WritableByteChannel to);@throws;;;if an I/O error occurs;true
com.google.common.io.ByteStreams;long copy(InputStream from, OutputStream to);byte[] toByteArray(InputStream in);@param;InputStream from;InputStream in;the input stream to read from;false
com.google.common.io.ByteStreams;long copy(InputStream from, OutputStream to);byte[] toByteArray(InputStream in);@throws;;;if an I/O error occurs;true
com.google.common.io.ByteStreams;long copy(InputStream from, OutputStream to);void skipFully(InputStream in, long n);@param;InputStream from;InputStream in;the input stream to read from;false
com.google.common.io.ByteStreams;long copy(InputStream from, OutputStream to);T readBytes(InputStream input, ByteProcessor processor);@throws;;;if an I/O error occurs;true
com.google.common.io.ByteStreams;long copy(InputStream from, OutputStream to);int read(InputStream in, byte[] b, int off, int len);@param;InputStream from;InputStream in;the input stream to read from;false
com.google.common.io.ByteStreams;long copy(InputStream from, OutputStream to);int read(InputStream in, byte[] b, int off, int len);@throws;;;if an I/O error occurs;true
com.google.common.io.ByteStreams;long copy(ReadableByteChannel from, WritableByteChannel to);byte[] toByteArray(InputStream in);@throws;;;if an I/O error occurs;true
com.google.common.io.ByteStreams;long copy(ReadableByteChannel from, WritableByteChannel to);T readBytes(InputStream input, ByteProcessor processor);@throws;;;if an I/O error occurs;true
com.google.common.io.ByteStreams;long copy(ReadableByteChannel from, WritableByteChannel to);int read(InputStream in, byte[] b, int off, int len);@throws;;;if an I/O error occurs;true
com.google.common.io.ByteStreams;byte[] toByteArray(InputStream in);void skipFully(InputStream in, long n);@param;InputStream in;InputStream in;the input stream to read from;true
com.google.common.io.ByteStreams;byte[] toByteArray(InputStream in);T readBytes(InputStream input, ByteProcessor processor);@throws;;;if an I/O error occurs;true
com.google.common.io.ByteStreams;byte[] toByteArray(InputStream in);int read(InputStream in, byte[] b, int off, int len);@param;InputStream in;InputStream in;the input stream to read from;true
com.google.common.io.ByteStreams;byte[] toByteArray(InputStream in);int read(InputStream in, byte[] b, int off, int len);@throws;;;if an I/O error occurs;true
com.google.common.io.ByteStreams;void readFully(InputStream in, byte[] b);void readFully(InputStream in, byte[] b, int off, int len);@param;InputStream in;InputStream in;the input stream to read from.;true
com.google.common.io.ByteStreams;void readFully(InputStream in, byte[] b);void readFully(InputStream in, byte[] b, int off, int len);@param;byte[] b;byte[] b;the buffer into which the data is read.;true
com.google.common.io.ByteStreams;void readFully(InputStream in, byte[] b);void readFully(InputStream in, byte[] b, int off, int len);@throws;;;if this stream reaches the end before reading all the bytes.;true
com.google.common.io.ByteStreams;void readFully(InputStream in, byte[] b);void readFully(InputStream in, byte[] b, int off, int len);@throws;;;if an I/O error occurs.;true
com.google.common.io.ByteStreams;void skipFully(InputStream in, long n);int read(InputStream in, byte[] b, int off, int len);@param;InputStream in;InputStream in;the input stream to read from;true
com.google.common.io.ByteStreams;T readBytes(InputStream input, ByteProcessor processor);int read(InputStream in, byte[] b, int off, int len);@throws;;;if an I/O error occurs;true
com.google.common.io.Flushables;void flush(Flushable flushable, boolean swallowIOException);void flushQuietly(Flushable flushable);@param;Flushable flushable;Flushable flushable;the Flushable object to be flushed.;true
com.google.common.io.ByteSource;InputStream openStream();InputStream openBufferedStream();@throws;;;if an I/O error occurs in the process of opening the stream;true
com.google.common.io.ByteSource;byte[] read();HashCode hash(HashFunction hashFunction);@throws;;;if an I/O error occurs in the process of reading from this source;true
com.google.common.io.ByteSource;ByteSource concat(Iterable sources);ByteSource concat(Iterator sources);@return;;;a ByteSource containing the concatenated data;true
com.google.common.io.ByteSource;ByteSource concat(Iterable sources);ByteSource concat(Iterator sources);@param;Iterable<? extends ByteSource> sources;Iterator<? extends ByteSource> sources;the sources to concatenate;true
com.google.common.io.ByteSource;ByteSource concat(Iterable sources);ByteSource concat(ByteSource sources);Free text;;;Concatenates multiple {@link ByteSource} instances into a single source. Streams returned from the source will contain the concatenated data from the streams of the underlying sources. <p>Only one underlying stream will be open at a time. Closing the concatenated stream will close the open underlying stream. ;true
com.google.common.io.ByteSource;ByteSource concat(Iterable sources);ByteSource concat(ByteSource sources);@return;;;a ByteSource containing the concatenated data;true
com.google.common.io.ByteSource;ByteSource concat(Iterable sources);ByteSource concat(ByteSource sources);@param;Iterable<? extends ByteSource> sources;ByteSource sources;the sources to concatenate;true
com.google.common.io.ByteSource;ByteSource concat(Iterator sources);ByteSource concat(ByteSource sources);@return;;;a ByteSource containing the concatenated data;true
com.google.common.io.ByteSource;ByteSource concat(Iterator sources);ByteSource concat(ByteSource sources);@param;Iterator<? extends ByteSource> sources;ByteSource sources;the sources to concatenate;true
com.google.common.io.ByteSource;ByteSource concat(Iterator sources);ByteSource concat(ByteSource sources);@throws;;;if any of sources is null;true
com.google.common.io.LittleEndianDataInputStream;int readUnsignedShort();int readInt();@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataInputStream;int readUnsignedShort();long readLong();@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataInputStream;int readUnsignedShort();float readFloat();@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataInputStream;int readUnsignedShort();double readDouble();@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataInputStream;int readUnsignedShort();char readChar();@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataInputStream;int readInt();long readLong();@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataInputStream;int readInt();float readFloat();@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataInputStream;int readInt();double readDouble();@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataInputStream;int readInt();char readChar();@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataInputStream;long readLong();float readFloat();@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataInputStream;long readLong();double readDouble();@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataInputStream;long readLong();char readChar();@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataInputStream;float readFloat();double readDouble();@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataInputStream;float readFloat();char readChar();@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataInputStream;double readDouble();char readChar();@throws;;;if an I/O error occurs;true
com.google.common.io.FileBackedOutputStream; FileBackedOutputStream(int fileThreshold); FileBackedOutputStream(int fileThreshold, boolean resetOnFinalize);@param;int fileThreshold;int fileThreshold;the number of bytes before the stream should switch to buffering to a file;true
com.google.common.io.LittleEndianDataOutputStream;void writeChar(int v);void writeChars(String s);@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataOutputStream;void writeChar(int v);void writeDouble(double v);@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataOutputStream;void writeChar(int v);void writeFloat(float v);@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataOutputStream;void writeChar(int v);void writeInt(int v);@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataOutputStream;void writeChar(int v);void writeLong(long v);@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataOutputStream;void writeChar(int v);void writeShort(int v);@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataOutputStream;void writeChars(String s);void writeDouble(double v);@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataOutputStream;void writeChars(String s);void writeFloat(float v);@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataOutputStream;void writeChars(String s);void writeInt(int v);@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataOutputStream;void writeChars(String s);void writeLong(long v);@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataOutputStream;void writeChars(String s);void writeShort(int v);@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataOutputStream;void writeDouble(double v);void writeFloat(float v);@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataOutputStream;void writeDouble(double v);void writeInt(int v);@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataOutputStream;void writeDouble(double v);void writeLong(long v);@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataOutputStream;void writeDouble(double v);void writeShort(int v);@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataOutputStream;void writeFloat(float v);void writeInt(int v);@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataOutputStream;void writeFloat(float v);void writeLong(long v);@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataOutputStream;void writeFloat(float v);void writeShort(int v);@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataOutputStream;void writeInt(int v);void writeLong(long v);@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataOutputStream;void writeInt(int v);void writeShort(int v);@throws;;;if an I/O error occurs;true
com.google.common.io.LittleEndianDataOutputStream;void writeLong(long v);void writeShort(int v);@throws;;;if an I/O error occurs;true
com.google.common.math.LongMath;int log2(long x, RoundingMode mode);int log10(long x, RoundingMode mode);@throws;;;if x <= 0;true
com.google.common.math.LongMath;int mod(long x, int m);long mod(long x, long m);Whole;;;Returns {@code x mod m}, a non-negative value less than {@code m}. This differs from {@code x % m}, which might be negative. <p>For example: <pre> {@code mod(7, 4) == 3 mod(-7, 4) == 1 mod(-1, 4) == 3 mod(-8, 4) == 0 mod(8, 4) == 0}</pre>    @throws if m <= 0;false
com.google.common.math.IntMath;int log2(int x, RoundingMode mode);int log10(int x, RoundingMode mode);@throws;;;if x <= 0;true
com.google.common.math.BigIntegerMath;int log2(BigInteger x, RoundingMode mode);int log10(BigInteger x, RoundingMode mode);@throws;;;if x <= 0;true
com.google.common.math.DoubleMath;boolean fuzzyEquals(double a, double b, double tolerance);int fuzzyCompare(double a, double b, double tolerance);@throws;;;if tolerance is < 0 or NaN;true
com.google.common.math.DoubleMath;double mean(double values);double mean(int values);Free text;;;Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of {@code values}. <p>If these values are a sample drawn from a population, this is also an unbiased estimator of the arithmetic mean of the population. ;true
com.google.common.math.DoubleMath;double mean(double values);double mean(int values);@param;double values;int values;a nonempty series of values;true
com.google.common.math.DoubleMath;double mean(double values);double mean(long values);Free text;;;Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of {@code values}. <p>If these values are a sample drawn from a population, this is also an unbiased estimator of the arithmetic mean of the population. ;true
com.google.common.math.DoubleMath;double mean(double values);double mean(Iterable values);Free text;;;Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of {@code values}. <p>If these values are a sample drawn from a population, this is also an unbiased estimator of the arithmetic mean of the population. ;true
com.google.common.math.DoubleMath;double mean(double values);double mean(Iterable values);@throws;;;if values is empty or contains any non-finite value;true
com.google.common.math.DoubleMath;double mean(double values);double mean(Iterator values);Free text;;;Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of {@code values}. <p>If these values are a sample drawn from a population, this is also an unbiased estimator of the arithmetic mean of the population. ;true
com.google.common.math.DoubleMath;double mean(double values);double mean(Iterator values);@throws;;;if values is empty or contains any non-finite value;true
com.google.common.math.DoubleMath;double mean(int values);double mean(long values);Free text;;;Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of {@code values}. <p>If these values are a sample drawn from a population, this is also an unbiased estimator of the arithmetic mean of the population. ;true
com.google.common.math.DoubleMath;double mean(int values);double mean(long values);@throws;;;if values is empty;true
com.google.common.math.DoubleMath;double mean(int values);double mean(Iterable values);Free text;;;Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of {@code values}. <p>If these values are a sample drawn from a population, this is also an unbiased estimator of the arithmetic mean of the population. ;true
com.google.common.math.DoubleMath;double mean(int values);double mean(Iterator values);Free text;;;Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of {@code values}. <p>If these values are a sample drawn from a population, this is also an unbiased estimator of the arithmetic mean of the population. ;true
com.google.common.math.DoubleMath;double mean(long values);double mean(Iterable values);Free text;;;Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of {@code values}. <p>If these values are a sample drawn from a population, this is also an unbiased estimator of the arithmetic mean of the population. ;true
com.google.common.math.DoubleMath;double mean(long values);double mean(Iterator values);Free text;;;Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of {@code values}. <p>If these values are a sample drawn from a population, this is also an unbiased estimator of the arithmetic mean of the population. ;true
com.google.common.math.DoubleMath;double mean(Iterable values);double mean(Iterator values);Whole;;;Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of {@code values}. <p>If these values are a sample drawn from a population, this is also an unbiased estimator of the arithmetic mean of the population.  @param a nonempty series of values, which will be converted to double values (this may cause loss of precision)  @throws if values is empty or contains any non-finite value;false
com.google.common.primitives.Floats;int hashCode(float value);boolean contains(float[] array, float target);@param;float value;float target;a primitive float value;false
com.google.common.primitives.Floats;int hashCode(float value);int indexOf(float[] array, float target);@param;float value;float target;a primitive float value;false
com.google.common.primitives.Floats;int hashCode(float value);int lastIndexOf(float[] array, float target);@param;float value;float target;a primitive float value;false
com.google.common.primitives.Floats;boolean contains(float[] array, float target);int indexOf(float[] array, float target);@param;float[] array;float[] array;an array of float values, possibly empty;true
com.google.common.primitives.Floats;boolean contains(float[] array, float target);int indexOf(float[] array, float target);@param;float target;float target;a primitive float value;true
com.google.common.primitives.Floats;boolean contains(float[] array, float target);int lastIndexOf(float[] array, float target);@param;float[] array;float[] array;an array of float values, possibly empty;true
com.google.common.primitives.Floats;boolean contains(float[] array, float target);int lastIndexOf(float[] array, float target);@param;float target;float target;a primitive float value;true
com.google.common.primitives.Floats;boolean contains(float[] array, float target);String join(String separator, float array);@param;float[] array;float array;an array of float values, possibly empty;true
com.google.common.primitives.Floats;int indexOf(float[] array, float target);int lastIndexOf(float[] array, float target);@param;float[] array;float[] array;an array of float values, possibly empty;true
com.google.common.primitives.Floats;int indexOf(float[] array, float target);int lastIndexOf(float[] array, float target);@param;float target;float target;a primitive float value;true
com.google.common.primitives.Floats;int indexOf(float[] array, float target);String join(String separator, float array);@param;float[] array;float array;an array of float values, possibly empty;true
com.google.common.primitives.Floats;int lastIndexOf(float[] array, float target);String join(String separator, float array);@param;float[] array;float array;an array of float values, possibly empty;true
com.google.common.primitives.Floats;float min(float array);float max(float array);@param;float array;float array;a nonempty array of float values;true
com.google.common.primitives.Floats;float min(float array);float max(float array);@throws;;;if array is empty;true
com.google.common.primitives.Booleans;int hashCode(boolean value);boolean contains(boolean[] array, boolean target);@param;boolean value;boolean target;a primitive boolean value;false
com.google.common.primitives.Booleans;int hashCode(boolean value);int indexOf(boolean[] array, boolean target);@param;boolean value;boolean target;a primitive boolean value;false
com.google.common.primitives.Booleans;int hashCode(boolean value);int lastIndexOf(boolean[] array, boolean target);@param;boolean value;boolean target;a primitive boolean value;false
com.google.common.primitives.Booleans;boolean contains(boolean[] array, boolean target);int indexOf(boolean[] array, boolean target);@param;boolean[] array;boolean[] array;an array of boolean values, possibly empty;true
com.google.common.primitives.Booleans;boolean contains(boolean[] array, boolean target);int indexOf(boolean[] array, boolean target);@param;boolean target;boolean target;a primitive boolean value;true
com.google.common.primitives.Booleans;boolean contains(boolean[] array, boolean target);int lastIndexOf(boolean[] array, boolean target);@param;boolean[] array;boolean[] array;an array of boolean values, possibly empty;true
com.google.common.primitives.Booleans;boolean contains(boolean[] array, boolean target);int lastIndexOf(boolean[] array, boolean target);@param;boolean target;boolean target;a primitive boolean value;true
com.google.common.primitives.Booleans;boolean contains(boolean[] array, boolean target);String join(String separator, boolean array);@param;boolean[] array;boolean array;an array of boolean values, possibly empty;true
com.google.common.primitives.Booleans;int indexOf(boolean[] array, boolean target);int lastIndexOf(boolean[] array, boolean target);@param;boolean[] array;boolean[] array;an array of boolean values, possibly empty;true
com.google.common.primitives.Booleans;int indexOf(boolean[] array, boolean target);int lastIndexOf(boolean[] array, boolean target);@param;boolean target;boolean target;a primitive boolean value;true
com.google.common.primitives.Booleans;int indexOf(boolean[] array, boolean target);String join(String separator, boolean array);@param;boolean[] array;boolean array;an array of boolean values, possibly empty;true
com.google.common.primitives.Booleans;int lastIndexOf(boolean[] array, boolean target);String join(String separator, boolean array);@param;boolean[] array;boolean array;an array of boolean values, possibly empty;true
com.google.common.primitives.UnsignedLongs;long min(long array);long max(long array);@param;long array;long array;a nonempty array of unsigned long values;true
com.google.common.primitives.UnsignedLongs;long min(long array);long max(long array);@throws;;;if array is empty;true
com.google.common.primitives.UnsignedLongs;long divide(long dividend, long divisor);long remainder(long dividend, long divisor);@param;long dividend;long dividend;the dividend (numerator);true
com.google.common.primitives.UnsignedLongs;long divide(long dividend, long divisor);long remainder(long dividend, long divisor);@param;long divisor;long divisor;the divisor (denominator);true
com.google.common.primitives.UnsignedLongs;long divide(long dividend, long divisor);long remainder(long dividend, long divisor);@throws;;;if divisor is 0;true
com.google.common.primitives.UnsignedLongs;long parseUnsignedLong(String s);long decode(String stringValue);@throws;;;if the string does not contain a valid unsigned long value;true
com.google.common.primitives.UnsignedLongs;long parseUnsignedLong(String s);long parseUnsignedLong(String s, int radix);@throws;;;if s is null (in contrast to Long#parseLong(String));true
com.google.common.primitives.Shorts;int hashCode(short value);boolean contains(short[] array, short target);@param;short value;short target;a primitive short value;false
com.google.common.primitives.Shorts;int hashCode(short value);int indexOf(short[] array, short target);@param;short value;short target;a primitive short value;false
com.google.common.primitives.Shorts;int hashCode(short value);int lastIndexOf(short[] array, short target);@param;short value;short target;a primitive short value;false
com.google.common.primitives.Shorts;boolean contains(short[] array, short target);int indexOf(short[] array, short target);@param;short[] array;short[] array;an array of short values, possibly empty;true
com.google.common.primitives.Shorts;boolean contains(short[] array, short target);int indexOf(short[] array, short target);@param;short target;short target;a primitive short value;true
com.google.common.primitives.Shorts;boolean contains(short[] array, short target);int lastIndexOf(short[] array, short target);@param;short[] array;short[] array;an array of short values, possibly empty;true
com.google.common.primitives.Shorts;boolean contains(short[] array, short target);int lastIndexOf(short[] array, short target);@param;short target;short target;a primitive short value;true
com.google.common.primitives.Shorts;boolean contains(short[] array, short target);String join(String separator, short array);@param;short[] array;short array;an array of short values, possibly empty;true
com.google.common.primitives.Shorts;int indexOf(short[] array, short target);int lastIndexOf(short[] array, short target);@param;short[] array;short[] array;an array of short values, possibly empty;true
com.google.common.primitives.Shorts;int indexOf(short[] array, short target);int lastIndexOf(short[] array, short target);@param;short target;short target;a primitive short value;true
com.google.common.primitives.Shorts;int indexOf(short[] array, short target);String join(String separator, short array);@param;short[] array;short array;an array of short values, possibly empty;true
com.google.common.primitives.Shorts;int lastIndexOf(short[] array, short target);String join(String separator, short array);@param;short[] array;short array;an array of short values, possibly empty;true
com.google.common.primitives.Shorts;short min(short array);short max(short array);@param;short array;short array;a nonempty array of short values;true
com.google.common.primitives.Shorts;short min(short array);short max(short array);@throws;;;if array is empty;true
com.google.common.primitives.SignedBytes;byte min(byte array);byte max(byte array);@param;byte array;byte array;a nonempty array of byte values;true
com.google.common.primitives.SignedBytes;byte min(byte array);byte max(byte array);@throws;;;if array is empty;true
com.google.common.primitives.Doubles;int hashCode(double value);boolean contains(double[] array, double target);@param;double value;double target;a primitive double value;false
com.google.common.primitives.Doubles;int hashCode(double value);int indexOf(double[] array, double target);@param;double value;double target;a primitive double value;false
com.google.common.primitives.Doubles;int hashCode(double value);int lastIndexOf(double[] array, double target);@param;double value;double target;a primitive double value;false
com.google.common.primitives.Doubles;boolean contains(double[] array, double target);int indexOf(double[] array, double target);@param;double[] array;double[] array;an array of double values, possibly empty;true
com.google.common.primitives.Doubles;boolean contains(double[] array, double target);int indexOf(double[] array, double target);@param;double target;double target;a primitive double value;true
com.google.common.primitives.Doubles;boolean contains(double[] array, double target);int lastIndexOf(double[] array, double target);@param;double[] array;double[] array;an array of double values, possibly empty;true
com.google.common.primitives.Doubles;boolean contains(double[] array, double target);int lastIndexOf(double[] array, double target);@param;double target;double target;a primitive double value;true
com.google.common.primitives.Doubles;boolean contains(double[] array, double target);String join(String separator, double array);@param;double[] array;double array;an array of double values, possibly empty;true
com.google.common.primitives.Doubles;int indexOf(double[] array, double target);int lastIndexOf(double[] array, double target);@param;double[] array;double[] array;an array of double values, possibly empty;true
com.google.common.primitives.Doubles;int indexOf(double[] array, double target);int lastIndexOf(double[] array, double target);@param;double target;double target;a primitive double value;true
com.google.common.primitives.Doubles;int indexOf(double[] array, double target);String join(String separator, double array);@param;double[] array;double array;an array of double values, possibly empty;true
com.google.common.primitives.Doubles;int lastIndexOf(double[] array, double target);String join(String separator, double array);@param;double[] array;double array;an array of double values, possibly empty;true
com.google.common.primitives.Doubles;double min(double array);double max(double array);@param;double array;double array;a nonempty array of double values;true
com.google.common.primitives.Doubles;double min(double array);double max(double array);@throws;;;if array is empty;true
com.google.common.primitives.Bytes;int hashCode(byte value);boolean contains(byte[] array, byte target);@param;byte value;byte target;a primitive byte value;false
com.google.common.primitives.Bytes;int hashCode(byte value);int indexOf(byte[] array, byte target);@param;byte value;byte target;a primitive byte value;false
com.google.common.primitives.Bytes;int hashCode(byte value);int lastIndexOf(byte[] array, byte target);@param;byte value;byte target;a primitive byte value;false
com.google.common.primitives.Bytes;boolean contains(byte[] array, byte target);int indexOf(byte[] array, byte target);@param;byte[] array;byte[] array;an array of byte values, possibly empty;true
com.google.common.primitives.Bytes;boolean contains(byte[] array, byte target);int indexOf(byte[] array, byte target);@param;byte target;byte target;a primitive byte value;true
com.google.common.primitives.Bytes;boolean contains(byte[] array, byte target);int lastIndexOf(byte[] array, byte target);@param;byte[] array;byte[] array;an array of byte values, possibly empty;true
com.google.common.primitives.Bytes;boolean contains(byte[] array, byte target);int lastIndexOf(byte[] array, byte target);@param;byte target;byte target;a primitive byte value;true
com.google.common.primitives.Bytes;int indexOf(byte[] array, byte target);int lastIndexOf(byte[] array, byte target);@param;byte[] array;byte[] array;an array of byte values, possibly empty;true
com.google.common.primitives.Bytes;int indexOf(byte[] array, byte target);int lastIndexOf(byte[] array, byte target);@param;byte target;byte target;a primitive byte value;true
com.google.common.primitives.UnsignedInts;int min(int array);int max(int array);@param;int array;int array;a nonempty array of unsigned int values;true
com.google.common.primitives.UnsignedInts;int min(int array);int max(int array);@throws;;;if array is empty;true
com.google.common.primitives.UnsignedInts;int divide(int dividend, int divisor);int remainder(int dividend, int divisor);@param;int dividend;int dividend;the dividend (numerator);true
com.google.common.primitives.UnsignedInts;int divide(int dividend, int divisor);int remainder(int dividend, int divisor);@param;int divisor;int divisor;the divisor (denominator);true
com.google.common.primitives.UnsignedInts;int divide(int dividend, int divisor);int remainder(int dividend, int divisor);@throws;;;if divisor is 0;true
com.google.common.primitives.UnsignedInts;int decode(String stringValue);int parseUnsignedInt(String s);@throws;;;if the string does not contain a valid unsigned int value;true
com.google.common.primitives.UnsignedInts;int parseUnsignedInt(String s);int parseUnsignedInt(String string, int radix);@throws;;;if s is null (in contrast to Integer#parseInt(String));true
com.google.common.primitives.Ints;int hashCode(int value);boolean contains(int[] array, int target);@param;int value;int target;a primitive int value;false
com.google.common.primitives.Ints;int hashCode(int value);int indexOf(int[] array, int target);@param;int value;int target;a primitive int value;false
com.google.common.primitives.Ints;int hashCode(int value);int lastIndexOf(int[] array, int target);@param;int value;int target;a primitive int value;false
com.google.common.primitives.Ints;boolean contains(int[] array, int target);int indexOf(int[] array, int target);@param;int[] array;int[] array;an array of int values, possibly empty;true
com.google.common.primitives.Ints;boolean contains(int[] array, int target);int indexOf(int[] array, int target);@param;int target;int target;a primitive int value;true
com.google.common.primitives.Ints;boolean contains(int[] array, int target);int lastIndexOf(int[] array, int target);@param;int[] array;int[] array;an array of int values, possibly empty;true
com.google.common.primitives.Ints;boolean contains(int[] array, int target);int lastIndexOf(int[] array, int target);@param;int target;int target;a primitive int value;true
com.google.common.primitives.Ints;boolean contains(int[] array, int target);String join(String separator, int array);@param;int[] array;int array;an array of int values, possibly empty;true
com.google.common.primitives.Ints;int indexOf(int[] array, int target);int lastIndexOf(int[] array, int target);@param;int[] array;int[] array;an array of int values, possibly empty;true
com.google.common.primitives.Ints;int indexOf(int[] array, int target);int lastIndexOf(int[] array, int target);@param;int target;int target;a primitive int value;true
com.google.common.primitives.Ints;int indexOf(int[] array, int target);String join(String separator, int array);@param;int[] array;int array;an array of int values, possibly empty;true
com.google.common.primitives.Ints;int lastIndexOf(int[] array, int target);String join(String separator, int array);@param;int[] array;int array;an array of int values, possibly empty;true
com.google.common.primitives.Ints;int min(int array);int max(int array);@param;int array;int array;a nonempty array of int values;true
com.google.common.primitives.Ints;int min(int array);int max(int array);@throws;;;if array is empty;true
com.google.common.primitives.Ints;Integer tryParse(String string);Integer tryParse(String string, int radix);@param;String string;String string;the string representation of an integer value;true
com.google.common.primitives.UnsignedBytes;byte min(byte array);byte max(byte array);@param;byte array;byte array;a nonempty array of byte values;true
com.google.common.primitives.UnsignedBytes;byte min(byte array);byte max(byte array);@throws;;;if array is empty;true
com.google.common.primitives.UnsignedBytes;byte parseUnsignedByte(String string);byte parseUnsignedByte(String string, int radix);@throws;;;if s is null (in contrast to Byte#parseByte(String));true
com.google.common.primitives.Chars;int hashCode(char value);boolean contains(char[] array, char target);@param;char value;char target;a primitive char value;false
com.google.common.primitives.Chars;int hashCode(char value);int indexOf(char[] array, char target);@param;char value;char target;a primitive char value;false
com.google.common.primitives.Chars;int hashCode(char value);int lastIndexOf(char[] array, char target);@param;char value;char target;a primitive char value;false
com.google.common.primitives.Chars;boolean contains(char[] array, char target);int indexOf(char[] array, char target);@param;char[] array;char[] array;an array of char values, possibly empty;true
com.google.common.primitives.Chars;boolean contains(char[] array, char target);int indexOf(char[] array, char target);@param;char target;char target;a primitive char value;true
com.google.common.primitives.Chars;boolean contains(char[] array, char target);int lastIndexOf(char[] array, char target);@param;char[] array;char[] array;an array of char values, possibly empty;true
com.google.common.primitives.Chars;boolean contains(char[] array, char target);int lastIndexOf(char[] array, char target);@param;char target;char target;a primitive char value;true
com.google.common.primitives.Chars;boolean contains(char[] array, char target);String join(String separator, char array);@param;char[] array;char array;an array of char values, possibly empty;true
com.google.common.primitives.Chars;int indexOf(char[] array, char target);int lastIndexOf(char[] array, char target);@param;char[] array;char[] array;an array of char values, possibly empty;true
com.google.common.primitives.Chars;int indexOf(char[] array, char target);int lastIndexOf(char[] array, char target);@param;char target;char target;a primitive char value;true
com.google.common.primitives.Chars;int indexOf(char[] array, char target);String join(String separator, char array);@param;char[] array;char array;an array of char values, possibly empty;true
com.google.common.primitives.Chars;int lastIndexOf(char[] array, char target);String join(String separator, char array);@param;char[] array;char array;an array of char values, possibly empty;true
com.google.common.primitives.Chars;char min(char array);char max(char array);@param;char array;char array;a nonempty array of char values;true
com.google.common.primitives.Chars;char min(char array);char max(char array);@throws;;;if array is empty;true
com.google.common.primitives.UnsignedInteger;UnsignedInteger valueOf(String string);UnsignedInteger valueOf(String string, int radix);@throws;;;if the string does not contain a parsable unsigned int value;true
com.google.common.primitives.UnsignedInteger;UnsignedInteger dividedBy(UnsignedInteger val);UnsignedInteger mod(UnsignedInteger val);@throws;;;if val is zero;true
com.google.common.primitives.Longs;int hashCode(long value);boolean contains(long[] array, long target);@param;long value;long target;a primitive long value;false
com.google.common.primitives.Longs;int hashCode(long value);int indexOf(long[] array, long target);@param;long value;long target;a primitive long value;false
com.google.common.primitives.Longs;int hashCode(long value);int lastIndexOf(long[] array, long target);@param;long value;long target;a primitive long value;false
com.google.common.primitives.Longs;boolean contains(long[] array, long target);int indexOf(long[] array, long target);@param;long[] array;long[] array;an array of long values, possibly empty;true
com.google.common.primitives.Longs;boolean contains(long[] array, long target);int indexOf(long[] array, long target);@param;long target;long target;a primitive long value;true
com.google.common.primitives.Longs;boolean contains(long[] array, long target);int lastIndexOf(long[] array, long target);@param;long[] array;long[] array;an array of long values, possibly empty;true
com.google.common.primitives.Longs;boolean contains(long[] array, long target);int lastIndexOf(long[] array, long target);@param;long target;long target;a primitive long value;true
com.google.common.primitives.Longs;boolean contains(long[] array, long target);String join(String separator, long array);@param;long[] array;long array;an array of long values, possibly empty;true
com.google.common.primitives.Longs;int indexOf(long[] array, long target);int lastIndexOf(long[] array, long target);@param;long[] array;long[] array;an array of long values, possibly empty;true
com.google.common.primitives.Longs;int indexOf(long[] array, long target);int lastIndexOf(long[] array, long target);@param;long target;long target;a primitive long value;true
com.google.common.primitives.Longs;int indexOf(long[] array, long target);String join(String separator, long array);@param;long[] array;long array;an array of long values, possibly empty;true
com.google.common.primitives.Longs;int lastIndexOf(long[] array, long target);String join(String separator, long array);@param;long[] array;long array;an array of long values, possibly empty;true
com.google.common.primitives.Longs;long min(long array);long max(long array);@param;long array;long array;a nonempty array of long values;true
com.google.common.primitives.Longs;long min(long array);long max(long array);@throws;;;if array is empty;true
com.google.common.base.Preconditions;void checkArgument(boolean expression);void checkArgument(boolean expression, Object errorMessage);Free text;;;Ensures the truth of an expression involving one or more parameters to the calling method. ;true
com.google.common.base.Preconditions;void checkArgument(boolean expression);void checkArgument(boolean expression, Object errorMessage);@param;boolean expression;boolean expression;a boolean expression;true
com.google.common.base.Preconditions;void checkArgument(boolean expression);void checkArgument(boolean expression, Object errorMessage);@throws;;;if expression is false;true
com.google.common.base.Preconditions;void checkArgument(boolean expression);void checkArgument(boolean expression, String errorMessageTemplate, Object errorMessageArgs);Free text;;;Ensures the truth of an expression involving one or more parameters to the calling method. ;true
com.google.common.base.Preconditions;void checkArgument(boolean expression);void checkArgument(boolean expression, String errorMessageTemplate, Object errorMessageArgs);@param;boolean expression;boolean expression;a boolean expression;true
com.google.common.base.Preconditions;void checkArgument(boolean expression);void checkArgument(boolean expression, String errorMessageTemplate, Object errorMessageArgs);@throws;;;if expression is false;true
com.google.common.base.Preconditions;void checkArgument(boolean expression);void checkState(boolean expression);@param;boolean expression;boolean expression;a boolean expression;true
com.google.common.base.Preconditions;void checkArgument(boolean expression);void checkState(boolean expression);@throws;;;if expression is false;false
com.google.common.base.Preconditions;void checkArgument(boolean expression);void checkState(boolean expression, Object errorMessage);@param;boolean expression;boolean expression;a boolean expression;true
com.google.common.base.Preconditions;void checkArgument(boolean expression);void checkState(boolean expression, Object errorMessage);@throws;;;if expression is false;false
com.google.common.base.Preconditions;void checkArgument(boolean expression);void checkState(boolean expression, String errorMessageTemplate, Object errorMessageArgs);@param;boolean expression;boolean expression;a boolean expression;true
com.google.common.base.Preconditions;void checkArgument(boolean expression);void checkState(boolean expression, String errorMessageTemplate, Object errorMessageArgs);@throws;;;if expression is false;false
com.google.common.base.Preconditions;void checkArgument(boolean expression, Object errorMessage);void checkArgument(boolean expression, String errorMessageTemplate, Object errorMessageArgs);Free text;;;Ensures the truth of an expression involving one or more parameters to the calling method. ;true
com.google.common.base.Preconditions;void checkArgument(boolean expression, Object errorMessage);void checkArgument(boolean expression, String errorMessageTemplate, Object errorMessageArgs);@param;boolean expression;boolean expression;a boolean expression;true
com.google.common.base.Preconditions;void checkArgument(boolean expression, Object errorMessage);void checkArgument(boolean expression, String errorMessageTemplate, Object errorMessageArgs);@throws;;;if expression is false;true
com.google.common.base.Preconditions;void checkArgument(boolean expression, Object errorMessage);void checkState(boolean expression);@param;boolean expression;boolean expression;a boolean expression;true
com.google.common.base.Preconditions;void checkArgument(boolean expression, Object errorMessage);void checkState(boolean expression);@throws;;;if expression is false;false
com.google.common.base.Preconditions;void checkArgument(boolean expression, Object errorMessage);void checkState(boolean expression, Object errorMessage);@param;boolean expression;boolean expression;a boolean expression;true
com.google.common.base.Preconditions;void checkArgument(boolean expression, Object errorMessage);void checkState(boolean expression, Object errorMessage);@param;Object errorMessage;Object errorMessage;the exception message to use if the check fails, will be converted to a string using String#valueOf(Object);true
com.google.common.base.Preconditions;void checkArgument(boolean expression, Object errorMessage);void checkState(boolean expression, Object errorMessage);@throws;;;if expression is false;false
com.google.common.base.Preconditions;void checkArgument(boolean expression, Object errorMessage);void checkState(boolean expression, String errorMessageTemplate, Object errorMessageArgs);@param;boolean expression;boolean expression;a boolean expression;true
com.google.common.base.Preconditions;void checkArgument(boolean expression, Object errorMessage);void checkState(boolean expression, String errorMessageTemplate, Object errorMessageArgs);@throws;;;if expression is false;false
com.google.common.base.Preconditions;void checkArgument(boolean expression, Object errorMessage);T checkNotNull(T reference, Object errorMessage);@param;Object errorMessage;Object errorMessage;the exception message to use if the check fails, will be converted to a string using String#valueOf(Object);true
com.google.common.base.Preconditions;void checkArgument(boolean expression, String errorMessageTemplate, Object errorMessageArgs);void checkState(boolean expression);@param;boolean expression;boolean expression;a boolean expression;true
com.google.common.base.Preconditions;void checkArgument(boolean expression, String errorMessageTemplate, Object errorMessageArgs);void checkState(boolean expression);@throws;;;if expression is false;false
com.google.common.base.Preconditions;void checkArgument(boolean expression, String errorMessageTemplate, Object errorMessageArgs);void checkState(boolean expression, Object errorMessage);@param;boolean expression;boolean expression;a boolean expression;true
com.google.common.base.Preconditions;void checkArgument(boolean expression, String errorMessageTemplate, Object errorMessageArgs);void checkState(boolean expression, Object errorMessage);@throws;;;if expression is false;false
com.google.common.base.Preconditions;void checkArgument(boolean expression, String errorMessageTemplate, Object errorMessageArgs);void checkState(boolean expression, String errorMessageTemplate, Object errorMessageArgs);@param;boolean expression;boolean expression;a boolean expression;true
com.google.common.base.Preconditions;void checkArgument(boolean expression, String errorMessageTemplate, Object errorMessageArgs);void checkState(boolean expression, String errorMessageTemplate, Object errorMessageArgs);@param;String errorMessageTemplate;String errorMessageTemplate;a template for the exception message should the check fail. The message is formed by replacing each %s placeholder in the template with an argument. These are matched by position - the first %s gets errorMessageArgs[0], etc. Unmatched arguments will be appended to the formatted message in square braces. Unmatched placeholders will be left as-is.;true
com.google.common.base.Preconditions;void checkArgument(boolean expression, String errorMessageTemplate, Object errorMessageArgs);void checkState(boolean expression, String errorMessageTemplate, Object errorMessageArgs);@param;Object errorMessageArgs;Object errorMessageArgs;the arguments to be substituted into the message template. Arguments are converted to strings using String#valueOf(Object).;true
com.google.common.base.Preconditions;void checkArgument(boolean expression, String errorMessageTemplate, Object errorMessageArgs);void checkState(boolean expression, String errorMessageTemplate, Object errorMessageArgs);@throws;;;if expression is false;false
com.google.common.base.Preconditions;void checkArgument(boolean expression, String errorMessageTemplate, Object errorMessageArgs);void checkState(boolean expression, String errorMessageTemplate, Object errorMessageArgs);@throws;;;if the check fails and either errorMessageTemplate or errorMessageArgs is null (don't let this happen);true
com.google.common.base.Preconditions;void checkArgument(boolean expression, String errorMessageTemplate, Object errorMessageArgs);T checkNotNull(T reference, String errorMessageTemplate, Object errorMessageArgs);@param;String errorMessageTemplate;String errorMessageTemplate;a template for the exception message should the check fail. The message is formed by replacing each %s placeholder in the template with an argument. These are matched by position - the first %s gets errorMessageArgs[0], etc. Unmatched arguments will be appended to the formatted message in square braces. Unmatched placeholders will be left as-is.;true
com.google.common.base.Preconditions;void checkArgument(boolean expression, String errorMessageTemplate, Object errorMessageArgs);T checkNotNull(T reference, String errorMessageTemplate, Object errorMessageArgs);@param;Object errorMessageArgs;Object errorMessageArgs;the arguments to be substituted into the message template. Arguments are converted to strings using String#valueOf(Object).;true
com.google.common.base.Preconditions;void checkState(boolean expression);void checkState(boolean expression, Object errorMessage);Free text;;;Ensures the truth of an expression involving the state of the calling instance, but not involving any parameters to the calling method. ;true
com.google.common.base.Preconditions;void checkState(boolean expression);void checkState(boolean expression, Object errorMessage);@param;boolean expression;boolean expression;a boolean expression;true
com.google.common.base.Preconditions;void checkState(boolean expression);void checkState(boolean expression, Object errorMessage);@throws;;;if expression is false;true
com.google.common.base.Preconditions;void checkState(boolean expression);void checkState(boolean expression, String errorMessageTemplate, Object errorMessageArgs);Free text;;;Ensures the truth of an expression involving the state of the calling instance, but not involving any parameters to the calling method. ;true
com.google.common.base.Preconditions;void checkState(boolean expression);void checkState(boolean expression, String errorMessageTemplate, Object errorMessageArgs);@param;boolean expression;boolean expression;a boolean expression;true
com.google.common.base.Preconditions;void checkState(boolean expression);void checkState(boolean expression, String errorMessageTemplate, Object errorMessageArgs);@throws;;;if expression is false;true
com.google.common.base.Preconditions;void checkState(boolean expression, Object errorMessage);void checkState(boolean expression, String errorMessageTemplate, Object errorMessageArgs);Free text;;;Ensures the truth of an expression involving the state of the calling instance, but not involving any parameters to the calling method. ;true
com.google.common.base.Preconditions;void checkState(boolean expression, Object errorMessage);void checkState(boolean expression, String errorMessageTemplate, Object errorMessageArgs);@param;boolean expression;boolean expression;a boolean expression;true
com.google.common.base.Preconditions;void checkState(boolean expression, Object errorMessage);void checkState(boolean expression, String errorMessageTemplate, Object errorMessageArgs);@throws;;;if expression is false;true
com.google.common.base.Preconditions;void checkState(boolean expression, Object errorMessage);T checkNotNull(T reference, Object errorMessage);@param;Object errorMessage;Object errorMessage;the exception message to use if the check fails, will be converted to a string using String#valueOf(Object);true
com.google.common.base.Preconditions;void checkState(boolean expression, String errorMessageTemplate, Object errorMessageArgs);T checkNotNull(T reference, String errorMessageTemplate, Object errorMessageArgs);@param;String errorMessageTemplate;String errorMessageTemplate;a template for the exception message should the check fail. The message is formed by replacing each %s placeholder in the template with an argument. These are matched by position - the first %s gets errorMessageArgs[0], etc. Unmatched arguments will be appended to the formatted message in square braces. Unmatched placeholders will be left as-is.;true
com.google.common.base.Preconditions;void checkState(boolean expression, String errorMessageTemplate, Object errorMessageArgs);T checkNotNull(T reference, String errorMessageTemplate, Object errorMessageArgs);@param;Object errorMessageArgs;Object errorMessageArgs;the arguments to be substituted into the message template. Arguments are converted to strings using String#valueOf(Object).;true
com.google.common.base.Preconditions;T checkNotNull(T reference);T checkNotNull(T reference, Object errorMessage);Free text;;;Ensures that an object reference passed as a parameter to the calling method is not null. ;true
com.google.common.base.Preconditions;T checkNotNull(T reference);T checkNotNull(T reference, Object errorMessage);@return;;;the non-null reference that was validated;true
com.google.common.base.Preconditions;T checkNotNull(T reference);T checkNotNull(T reference, Object errorMessage);@param;T reference;T reference;an object reference;true
com.google.common.base.Preconditions;T checkNotNull(T reference);T checkNotNull(T reference, Object errorMessage);@throws;;;if reference is null;true
com.google.common.base.Preconditions;T checkNotNull(T reference);T checkNotNull(T reference, String errorMessageTemplate, Object errorMessageArgs);Free text;;;Ensures that an object reference passed as a parameter to the calling method is not null. ;true
com.google.common.base.Preconditions;T checkNotNull(T reference);T checkNotNull(T reference, String errorMessageTemplate, Object errorMessageArgs);@return;;;the non-null reference that was validated;true
com.google.common.base.Preconditions;T checkNotNull(T reference);T checkNotNull(T reference, String errorMessageTemplate, Object errorMessageArgs);@param;T reference;T reference;an object reference;true
com.google.common.base.Preconditions;T checkNotNull(T reference);T checkNotNull(T reference, String errorMessageTemplate, Object errorMessageArgs);@throws;;;if reference is null;true
com.google.common.base.Preconditions;T checkNotNull(T reference, Object errorMessage);T checkNotNull(T reference, String errorMessageTemplate, Object errorMessageArgs);Free text;;;Ensures that an object reference passed as a parameter to the calling method is not null. ;true
com.google.common.base.Preconditions;T checkNotNull(T reference, Object errorMessage);T checkNotNull(T reference, String errorMessageTemplate, Object errorMessageArgs);@return;;;the non-null reference that was validated;true
com.google.common.base.Preconditions;T checkNotNull(T reference, Object errorMessage);T checkNotNull(T reference, String errorMessageTemplate, Object errorMessageArgs);@param;T reference;T reference;an object reference;true
com.google.common.base.Preconditions;T checkNotNull(T reference, Object errorMessage);T checkNotNull(T reference, String errorMessageTemplate, Object errorMessageArgs);@throws;;;if reference is null;true
com.google.common.base.Preconditions;int checkElementIndex(int index, int size);int checkElementIndex(int index, int size, String desc);Free text;;;Ensures that {@code index} specifies a valid <i>element</i> in an array, list or string of size {@code size}. An element index may range from zero, inclusive, to {@code size}, exclusive. ;true
com.google.common.base.Preconditions;int checkElementIndex(int index, int size);int checkElementIndex(int index, int size, String desc);@return;;;the value of index;true
com.google.common.base.Preconditions;int checkElementIndex(int index, int size);int checkElementIndex(int index, int size, String desc);@param;int index;int index;a user-supplied index identifying an element of an array, list or string;true
com.google.common.base.Preconditions;int checkElementIndex(int index, int size);int checkElementIndex(int index, int size, String desc);@param;int size;int size;the size of that array, list or string;true
com.google.common.base.Preconditions;int checkElementIndex(int index, int size);int checkElementIndex(int index, int size, String desc);@throws;;;if index is negative or is not less than size;true
com.google.common.base.Preconditions;int checkElementIndex(int index, int size);int checkElementIndex(int index, int size, String desc);@throws;;;if size is negative;true
com.google.common.base.Preconditions;int checkElementIndex(int index, int size);int checkPositionIndex(int index, int size);@return;;;the value of index;false
com.google.common.base.Preconditions;int checkElementIndex(int index, int size);int checkPositionIndex(int index, int size);@param;int size;int size;the size of that array, list or string;true
com.google.common.base.Preconditions;int checkElementIndex(int index, int size);int checkPositionIndex(int index, int size);@throws;;;if size is negative;true
com.google.common.base.Preconditions;int checkElementIndex(int index, int size);int checkPositionIndex(int index, int size, String desc);@return;;;the value of index;false
com.google.common.base.Preconditions;int checkElementIndex(int index, int size);int checkPositionIndex(int index, int size, String desc);@param;int size;int size;the size of that array, list or string;true
com.google.common.base.Preconditions;int checkElementIndex(int index, int size);int checkPositionIndex(int index, int size, String desc);@throws;;;if size is negative;true
com.google.common.base.Preconditions;int checkElementIndex(int index, int size);void checkPositionIndexes(int start, int end, int size);@param;int size;int size;the size of that array, list or string;true
com.google.common.base.Preconditions;int checkElementIndex(int index, int size);void checkPositionIndexes(int start, int end, int size);@throws;;;if size is negative;true
com.google.common.base.Preconditions;int checkElementIndex(int index, int size, String desc);int checkPositionIndex(int index, int size);@return;;;the value of index;false
com.google.common.base.Preconditions;int checkElementIndex(int index, int size, String desc);int checkPositionIndex(int index, int size);@param;int size;int size;the size of that array, list or string;true
com.google.common.base.Preconditions;int checkElementIndex(int index, int size, String desc);int checkPositionIndex(int index, int size);@throws;;;if size is negative;true
com.google.common.base.Preconditions;int checkElementIndex(int index, int size, String desc);int checkPositionIndex(int index, int size, String desc);@return;;;the value of index;false
com.google.common.base.Preconditions;int checkElementIndex(int index, int size, String desc);int checkPositionIndex(int index, int size, String desc);@param;int size;int size;the size of that array, list or string;true
com.google.common.base.Preconditions;int checkElementIndex(int index, int size, String desc);int checkPositionIndex(int index, int size, String desc);@param;String desc;String desc;the text to use to describe this index in an error message;true
com.google.common.base.Preconditions;int checkElementIndex(int index, int size, String desc);int checkPositionIndex(int index, int size, String desc);@throws;;;if size is negative;true
com.google.common.base.Preconditions;int checkElementIndex(int index, int size, String desc);void checkPositionIndexes(int start, int end, int size);@param;int size;int size;the size of that array, list or string;true
com.google.common.base.Preconditions;int checkElementIndex(int index, int size, String desc);void checkPositionIndexes(int start, int end, int size);@throws;;;if size is negative;true
com.google.common.base.Preconditions;int checkPositionIndex(int index, int size);int checkPositionIndex(int index, int size, String desc);Free text;;;Ensures that {@code index} specifies a valid <i>position</i> in an array, list or string of size {@code size}. A position index may range from zero to {@code size}, inclusive. ;true
com.google.common.base.Preconditions;int checkPositionIndex(int index, int size);int checkPositionIndex(int index, int size, String desc);@return;;;the value of index;true
com.google.common.base.Preconditions;int checkPositionIndex(int index, int size);int checkPositionIndex(int index, int size, String desc);@param;int index;int index;a user-supplied index identifying a position in an array, list or string;true
com.google.common.base.Preconditions;int checkPositionIndex(int index, int size);int checkPositionIndex(int index, int size, String desc);@param;int size;int size;the size of that array, list or string;true
com.google.common.base.Preconditions;int checkPositionIndex(int index, int size);int checkPositionIndex(int index, int size, String desc);@throws;;;if index is negative or is greater than size;true
com.google.common.base.Preconditions;int checkPositionIndex(int index, int size);int checkPositionIndex(int index, int size, String desc);@throws;;;if size is negative;true
com.google.common.base.Preconditions;int checkPositionIndex(int index, int size);void checkPositionIndexes(int start, int end, int size);@param;int size;int size;the size of that array, list or string;true
com.google.common.base.Preconditions;int checkPositionIndex(int index, int size);void checkPositionIndexes(int start, int end, int size);@throws;;;if size is negative;true
com.google.common.base.Preconditions;int checkPositionIndex(int index, int size, String desc);void checkPositionIndexes(int start, int end, int size);@param;int size;int size;the size of that array, list or string;true
com.google.common.base.Preconditions;int checkPositionIndex(int index, int size, String desc);void checkPositionIndexes(int start, int end, int size);@throws;;;if size is negative;true
com.google.common.base.Joiner;Joiner on(String separator);Joiner on(char separator);Whole;;;Returns a joiner which automatically places {@code separator} between consecutive elements.    ;false
com.google.common.base.Joiner;A appendTo(A appendable, Iterable parts);A appendTo(A appendable, Iterator parts);Whole;;;Appends the string representation of each of {@code parts}, using the previously configured separator between each, to {@code appendable}.    ;false
com.google.common.base.Joiner;A appendTo(A appendable, Iterable parts);A appendTo(A appendable, Object[] parts);Whole;;;Appends the string representation of each of {@code parts}, using the previously configured separator between each, to {@code appendable}.    ;false
com.google.common.base.Joiner;A appendTo(A appendable, Iterator parts);A appendTo(A appendable, Object[] parts);Whole;;;Appends the string representation of each of {@code parts}, using the previously configured separator between each, to {@code appendable}.    ;false
com.google.common.base.Joiner;StringBuilder appendTo(StringBuilder builder, Iterable parts);StringBuilder appendTo(StringBuilder builder, Iterator parts);Whole;;;Appends the string representation of each of {@code parts}, using the previously configured separator between each, to {@code builder}. Identical to {@link #appendTo(Appendable, Iterable)}, except that it does not throw {@link IOException}.    ;false
com.google.common.base.Joiner;StringBuilder appendTo(StringBuilder builder, Iterable parts);StringBuilder appendTo(StringBuilder builder, Object[] parts);Whole;;;Appends the string representation of each of {@code parts}, using the previously configured separator between each, to {@code builder}. Identical to {@link #appendTo(Appendable, Iterable)}, except that it does not throw {@link IOException}.    ;false
com.google.common.base.Joiner;StringBuilder appendTo(StringBuilder builder, Iterator parts);StringBuilder appendTo(StringBuilder builder, Object[] parts);Whole;;;Appends the string representation of each of {@code parts}, using the previously configured separator between each, to {@code builder}. Identical to {@link #appendTo(Appendable, Iterable)}, except that it does not throw {@link IOException}.    ;false
com.google.common.base.Joiner;String join(Iterable parts);String join(Iterator parts);Whole;;;Returns a string containing the string representation of each of {@code parts}, using the previously configured separator between each.    ;false
com.google.common.base.Joiner;String join(Iterable parts);String join(Object[] parts);Whole;;;Returns a string containing the string representation of each of {@code parts}, using the previously configured separator between each.    ;false
com.google.common.base.Joiner;String join(Iterator parts);String join(Object[] parts);Whole;;;Returns a string containing the string representation of each of {@code parts}, using the previously configured separator between each.    ;false
com.google.common.base.Stopwatch;Stopwatch start();Stopwatch stop();@return;;;this Stopwatch instance;false
com.google.common.base.Stopwatch;Stopwatch start();Stopwatch reset();@return;;;this Stopwatch instance;false
com.google.common.base.Stopwatch;Stopwatch stop();Stopwatch reset();@return;;;this Stopwatch instance;false
com.google.common.base.Strings;String nullToEmpty(String string);String emptyToNull(String string);@param;String string;String string;the string to test and possibly return;true
com.google.common.base.Strings;String padStart(String string, int minLength, char padChar);String padEnd(String string, int minLength, char padChar);@return;;;the padded string;false
com.google.common.base.Strings;String padStart(String string, int minLength, char padChar);String padEnd(String string, int minLength, char padChar);@param;int minLength;int minLength;the minimum length the resulting string must have. Can be zero or negative, in which case the input string is always returned.;true
com.google.common.base.Throwables;void propagateIfPossible(Throwable throwable, Class declaredType);void propagateIfPossible(Throwable throwable, Class declaredType1, Class declaredType2);@param;Throwable throwable;Throwable throwable;the Throwable to possibly propagate;true
com.google.common.base.Converter;B doForward(A a);A doBackward(B b);@return;;;the converted instance, must not be null;false
com.google.common.base.Converter;B doForward(A a);A doBackward(B b);@param;A a;B b;the instance to convert, will never be null;false
com.google.common.base.Splitter;Splitter on(char separator);Splitter on(String separator);@return;;;a splitter, with default settings, that recognizes that separator;true
com.google.common.base.Splitter;Splitter on(Pattern separatorPattern);Splitter onPattern(String separatorPattern);@return;;;a splitter, with default settings, that uses this pattern;false
com.google.common.base.Splitter;Splitter on(Pattern separatorPattern);Splitter onPattern(String separatorPattern);@param;Pattern separatorPattern;String separatorPattern;the pattern that determines whether a subsequence is a separator. This pattern may not match the empty string.;true
com.google.common.base.Splitter;Splitter on(Pattern separatorPattern);Splitter onPattern(String separatorPattern);@throws;;;if separatorPattern matches the empty string;true
com.google.common.base.Splitter;Splitter omitEmptyStrings();Splitter limit(int limit);@return;;;a splitter with the desired configuration;false
com.google.common.base.Splitter;Splitter omitEmptyStrings();Splitter trimResults();@return;;;a splitter with the desired configuration;false
com.google.common.base.Splitter;Splitter limit(int limit);Splitter trimResults();@return;;;a splitter with the desired configuration;false
com.google.common.base.Splitter;Iterable split(CharSequence sequence);List splitToList(CharSequence sequence);@param;CharSequence sequence;CharSequence sequence;the sequence of characters to split;true
com.google.common.base.Splitter;MapSplitter withKeyValueSeparator(String separator);MapSplitter withKeyValueSeparator(char separator);Whole;;;Returns a {@code MapSplitter} which splits entries based on this splitter, and splits entries into keys and values using the specified separator.    ;false
com.google.common.base.CharMatcher;boolean matchesAnyOf(CharSequence sequence);boolean matchesAllOf(CharSequence sequence);@param;CharSequence sequence;CharSequence sequence;the character sequence to examine, possibly empty;true
com.google.common.base.CharMatcher;boolean matchesAnyOf(CharSequence sequence);boolean matchesNoneOf(CharSequence sequence);@param;CharSequence sequence;CharSequence sequence;the character sequence to examine, possibly empty;true
com.google.common.base.CharMatcher;boolean matchesAllOf(CharSequence sequence);boolean matchesNoneOf(CharSequence sequence);@return;;;true if this matcher matches every character in the sequence, including when the sequence is empty;false
com.google.common.base.CharMatcher;boolean matchesAllOf(CharSequence sequence);boolean matchesNoneOf(CharSequence sequence);@param;CharSequence sequence;CharSequence sequence;the character sequence to examine, possibly empty;true
com.google.common.base.CharMatcher;int indexIn(CharSequence sequence);int lastIndexIn(CharSequence sequence);@return;;;an index, or -1 if no character matches;false
com.google.common.base.CharMatcher;String replaceFrom(CharSequence sequence, char replacement);String replaceFrom(CharSequence sequence, CharSequence replacement);@return;;;the new string;true
com.google.common.base.CharMatcher;String replaceFrom(CharSequence sequence, char replacement);String replaceFrom(CharSequence sequence, CharSequence replacement);@param;CharSequence sequence;CharSequence sequence;the character sequence to replace matching characters in;true
com.google.common.base.CharMatcher;String replaceFrom(CharSequence sequence, char replacement);String collapseFrom(CharSequence sequence, char replacement);@return;;;the new string;false
com.google.common.base.CharMatcher;String replaceFrom(CharSequence sequence, CharSequence replacement);String collapseFrom(CharSequence sequence, char replacement);@return;;;the new string;false
com.google.common.base.Verify;void verify(boolean expression);void verify(boolean expression, String errorMessageTemplate, Object errorMessageArgs);@throws;;;if expression is false;true
com.google.common.base.Verify;void verify(boolean expression, String errorMessageTemplate, Object errorMessageArgs);T verifyNotNull(T reference, String errorMessageTemplate, Object errorMessageArgs);@param;String errorMessageTemplate;String errorMessageTemplate;a template for the exception message should the check fail. The message is formed by replacing each %s placeholder in the template with an argument. These are matched by position - the first %s gets errorMessageArgs[0], etc. Unmatched arguments will be appended to the formatted message in square braces. Unmatched placeholders will be left as-is.;true
com.google.common.base.Verify;void verify(boolean expression, String errorMessageTemplate, Object errorMessageArgs);T verifyNotNull(T reference, String errorMessageTemplate, Object errorMessageArgs);@param;Object errorMessageArgs;Object errorMessageArgs;the arguments to be substituted into the message template. Arguments are converted to strings using String#valueOf(Object).;true
com.google.common.base.Verify;T verifyNotNull(T reference);T verifyNotNull(T reference, String errorMessageTemplate, Object errorMessageArgs);@return;;;reference, guaranteed to be non-null, for convenience;true
com.google.common.base.Verify;T verifyNotNull(T reference);T verifyNotNull(T reference, String errorMessageTemplate, Object errorMessageArgs);@throws;;;if reference is null;true
