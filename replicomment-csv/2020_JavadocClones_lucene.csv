Class;Method1;Method2;Type;Param1;Param2;Cloned text;Legit?
org.apache.lucene.codecs.TermVectorsFormat;TermVectorsReader vectorsReader(Directory directory, SegmentInfo segmentInfo, FieldInfos fieldInfos, IOContext context);TermVectorsWriter vectorsWriter(Directory directory, SegmentInfo segmentInfo, IOContext context);Whole;;; vectors.    ;false
org.apache.lucene.codecs.StoredFieldsFormat;StoredFieldsReader fieldsReader(Directory directory, SegmentInfo si, FieldInfos fn, IOContext context);StoredFieldsWriter fieldsWriter(Directory directory, SegmentInfo si, IOContext context);Whole;;; fields.    ;false
org.apache.lucene.codecs.SegmentInfoFormat;SegmentInfo read(Directory directory, String segmentName, byte[] segmentID, IOContext context);void write(Directory dir, SegmentInfo info, IOContext ioContext);@throws;;;If an I/O error occurs;true
org.apache.lucene.codecs.LegacyDocValuesIterables;Iterable valuesIterable(SortedDocValues values);Iterable sortedOrdIterable(DocValuesProducer valuesProducer, FieldInfo fieldInfo, int maxDoc);Whole;;;@deprecated Consume {@link SortedDocValues} instead.    ;false
org.apache.lucene.codecs.LegacyDocValuesIterables;Iterable valuesIterable(SortedDocValues values);Iterable sortedNumericToDocCount(DocValuesProducer valuesProducer, FieldInfo fieldInfo, int maxDoc);Whole;;;@deprecated Consume {@link SortedDocValues} instead.    ;false
org.apache.lucene.codecs.LegacyDocValuesIterables;Iterable valuesIterable(SortedDocValues values);Iterable sortedNumericToValues(DocValuesProducer valuesProducer, FieldInfo fieldInfo);Whole;;;@deprecated Consume {@link SortedDocValues} instead.    ;false
org.apache.lucene.codecs.LegacyDocValuesIterables;Iterable valuesIterable(SortedSetDocValues values);Iterable sortedSetOrdCountIterable(DocValuesProducer valuesProducer, FieldInfo fieldInfo, int maxDoc);Whole;;;@deprecated Consume {@link SortedSetDocValues} instead.    ;false
org.apache.lucene.codecs.LegacyDocValuesIterables;Iterable valuesIterable(SortedSetDocValues values);Iterable sortedSetOrdsIterable(DocValuesProducer valuesProducer, FieldInfo fieldInfo);Whole;;;@deprecated Consume {@link SortedSetDocValues} instead.    ;false
org.apache.lucene.codecs.LegacyDocValuesIterables;Iterable sortedOrdIterable(DocValuesProducer valuesProducer, FieldInfo fieldInfo, int maxDoc);Iterable sortedNumericToDocCount(DocValuesProducer valuesProducer, FieldInfo fieldInfo, int maxDoc);Whole;;;@deprecated Consume {@link SortedDocValues} instead.    ;false
org.apache.lucene.codecs.LegacyDocValuesIterables;Iterable sortedOrdIterable(DocValuesProducer valuesProducer, FieldInfo fieldInfo, int maxDoc);Iterable sortedNumericToValues(DocValuesProducer valuesProducer, FieldInfo fieldInfo);Whole;;;@deprecated Consume {@link SortedDocValues} instead.    ;false
org.apache.lucene.codecs.LegacyDocValuesIterables;Iterable sortedSetOrdCountIterable(DocValuesProducer valuesProducer, FieldInfo fieldInfo, int maxDoc);Iterable sortedSetOrdsIterable(DocValuesProducer valuesProducer, FieldInfo fieldInfo);Whole;;;@deprecated Consume {@link SortedSetDocValues} instead.    ;false
org.apache.lucene.codecs.LegacyDocValuesIterables;Iterable sortedNumericToDocCount(DocValuesProducer valuesProducer, FieldInfo fieldInfo, int maxDoc);Iterable sortedNumericToValues(DocValuesProducer valuesProducer, FieldInfo fieldInfo);Whole;;;@deprecated Consume {@link SortedDocValues} instead.    ;false
org.apache.lucene.codecs.LegacyDocValuesIterables;Iterable normsIterable(FieldInfo field, NormsProducer normsProducer, int maxDoc);Iterable numericIterable(FieldInfo field, DocValuesProducer valuesProducer, int maxDoc);Whole;;;@deprecated Consume {@link NumericDocValues} instead.    ;false
org.apache.lucene.codecs.DocValuesConsumer;void addNumericField(FieldInfo field, DocValuesProducer valuesProducer);void addBinaryField(FieldInfo field, DocValuesProducer valuesProducer);@param;FieldInfo field;FieldInfo field;field information;true
org.apache.lucene.codecs.DocValuesConsumer;void addNumericField(FieldInfo field, DocValuesProducer valuesProducer);void addBinaryField(FieldInfo field, DocValuesProducer valuesProducer);@throws;;;if an I/O error occurred.;true
org.apache.lucene.codecs.DocValuesConsumer;void addNumericField(FieldInfo field, DocValuesProducer valuesProducer);void addSortedField(FieldInfo field, DocValuesProducer valuesProducer);@param;FieldInfo field;FieldInfo field;field information;true
org.apache.lucene.codecs.DocValuesConsumer;void addNumericField(FieldInfo field, DocValuesProducer valuesProducer);void addSortedField(FieldInfo field, DocValuesProducer valuesProducer);@throws;;;if an I/O error occurred.;true
org.apache.lucene.codecs.DocValuesConsumer;void addNumericField(FieldInfo field, DocValuesProducer valuesProducer);void addSortedNumericField(FieldInfo field, DocValuesProducer valuesProducer);@param;FieldInfo field;FieldInfo field;field information;true
org.apache.lucene.codecs.DocValuesConsumer;void addNumericField(FieldInfo field, DocValuesProducer valuesProducer);void addSortedNumericField(FieldInfo field, DocValuesProducer valuesProducer);@throws;;;if an I/O error occurred.;true
org.apache.lucene.codecs.DocValuesConsumer;void addNumericField(FieldInfo field, DocValuesProducer valuesProducer);void addSortedSetField(FieldInfo field, DocValuesProducer valuesProducer);@param;FieldInfo field;FieldInfo field;field information;true
org.apache.lucene.codecs.DocValuesConsumer;void addNumericField(FieldInfo field, DocValuesProducer valuesProducer);void addSortedSetField(FieldInfo field, DocValuesProducer valuesProducer);@throws;;;if an I/O error occurred.;true
org.apache.lucene.codecs.DocValuesConsumer;void addBinaryField(FieldInfo field, DocValuesProducer valuesProducer);void addSortedField(FieldInfo field, DocValuesProducer valuesProducer);@param;FieldInfo field;FieldInfo field;field information;true
org.apache.lucene.codecs.DocValuesConsumer;void addBinaryField(FieldInfo field, DocValuesProducer valuesProducer);void addSortedField(FieldInfo field, DocValuesProducer valuesProducer);@throws;;;if an I/O error occurred.;true
org.apache.lucene.codecs.DocValuesConsumer;void addBinaryField(FieldInfo field, DocValuesProducer valuesProducer);void addSortedNumericField(FieldInfo field, DocValuesProducer valuesProducer);@param;FieldInfo field;FieldInfo field;field information;true
org.apache.lucene.codecs.DocValuesConsumer;void addBinaryField(FieldInfo field, DocValuesProducer valuesProducer);void addSortedNumericField(FieldInfo field, DocValuesProducer valuesProducer);@throws;;;if an I/O error occurred.;true
org.apache.lucene.codecs.DocValuesConsumer;void addBinaryField(FieldInfo field, DocValuesProducer valuesProducer);void addSortedSetField(FieldInfo field, DocValuesProducer valuesProducer);@param;FieldInfo field;FieldInfo field;field information;true
org.apache.lucene.codecs.DocValuesConsumer;void addBinaryField(FieldInfo field, DocValuesProducer valuesProducer);void addSortedSetField(FieldInfo field, DocValuesProducer valuesProducer);@throws;;;if an I/O error occurred.;true
org.apache.lucene.codecs.DocValuesConsumer;void addSortedField(FieldInfo field, DocValuesProducer valuesProducer);void addSortedNumericField(FieldInfo field, DocValuesProducer valuesProducer);@param;FieldInfo field;FieldInfo field;field information;true
org.apache.lucene.codecs.DocValuesConsumer;void addSortedField(FieldInfo field, DocValuesProducer valuesProducer);void addSortedNumericField(FieldInfo field, DocValuesProducer valuesProducer);@throws;;;if an I/O error occurred.;true
org.apache.lucene.codecs.DocValuesConsumer;void addSortedField(FieldInfo field, DocValuesProducer valuesProducer);void addSortedSetField(FieldInfo field, DocValuesProducer valuesProducer);@param;FieldInfo field;FieldInfo field;field information;true
org.apache.lucene.codecs.DocValuesConsumer;void addSortedField(FieldInfo field, DocValuesProducer valuesProducer);void addSortedSetField(FieldInfo field, DocValuesProducer valuesProducer);@throws;;;if an I/O error occurred.;true
org.apache.lucene.codecs.DocValuesConsumer;void addSortedNumericField(FieldInfo field, DocValuesProducer valuesProducer);void addSortedSetField(FieldInfo field, DocValuesProducer valuesProducer);@param;FieldInfo field;FieldInfo field;field information;true
org.apache.lucene.codecs.DocValuesConsumer;void addSortedNumericField(FieldInfo field, DocValuesProducer valuesProducer);void addSortedSetField(FieldInfo field, DocValuesProducer valuesProducer);@param;DocValuesProducer valuesProducer;DocValuesProducer valuesProducer;produces the values to write;true
org.apache.lucene.codecs.DocValuesConsumer;void addSortedNumericField(FieldInfo field, DocValuesProducer valuesProducer);void addSortedSetField(FieldInfo field, DocValuesProducer valuesProducer);@throws;;;if an I/O error occurred.;true
org.apache.lucene.codecs.CodecUtil;void writeHeader(DataOutput out, String codec, int version);void writeIndexHeader(DataOutput out, String codec, int version, byte[] id, String suffix);@param;DataOutput out;DataOutput out;Output stream;true
org.apache.lucene.codecs.CodecUtil;void writeHeader(DataOutput out, String codec, int version);void writeIndexHeader(DataOutput out, String codec, int version, byte[] id, String suffix);@param;int version;int version;Version number;true
org.apache.lucene.codecs.CodecUtil;void writeHeader(DataOutput out, String codec, int version);void writeIndexHeader(DataOutput out, String codec, int version, byte[] id, String suffix);@throws;;;If there is an I/O error writing to the underlying medium.;true
org.apache.lucene.codecs.CodecUtil;void writeHeader(DataOutput out, String codec, int version);void writeFooter(IndexOutput out);@param;DataOutput out;IndexOutput out;Output stream;true
org.apache.lucene.codecs.CodecUtil;void writeHeader(DataOutput out, String codec, int version);void writeFooter(IndexOutput out);@throws;;;If there is an I/O error writing to the underlying medium.;true
org.apache.lucene.codecs.CodecUtil;void writeIndexHeader(DataOutput out, String codec, int version, byte[] id, String suffix);void writeFooter(IndexOutput out);@param;DataOutput out;IndexOutput out;Output stream;true
org.apache.lucene.codecs.CodecUtil;void writeIndexHeader(DataOutput out, String codec, int version, byte[] id, String suffix);void writeFooter(IndexOutput out);@throws;;;If there is an I/O error writing to the underlying medium.;true
org.apache.lucene.codecs.CodecUtil;int headerLength(String codec);int indexHeaderLength(String codec, String suffix);@param;String codec;String codec;Codec name.;true
org.apache.lucene.codecs.CodecUtil;int checkHeader(DataInput in, String codec, int minVersion, int maxVersion);int checkIndexHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] expectedID, String expectedSuffix);@param;DataInput in;DataInput in;Input stream, positioned at the point where the header was previously written. Typically this is located at the beginning of the file.;true
org.apache.lucene.codecs.CodecUtil;int checkHeader(DataInput in, String codec, int minVersion, int maxVersion);int checkIndexHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] expectedID, String expectedSuffix);@param;String codec;String codec;The expected codec name.;true
org.apache.lucene.codecs.CodecUtil;int checkHeader(DataInput in, String codec, int minVersion, int maxVersion);int checkIndexHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] expectedID, String expectedSuffix);@param;int minVersion;int minVersion;The minimum supported expected version number.;true
org.apache.lucene.codecs.CodecUtil;int checkHeader(DataInput in, String codec, int minVersion, int maxVersion);int checkIndexHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] expectedID, String expectedSuffix);@param;int maxVersion;int maxVersion;The maximum supported expected version number.;true
org.apache.lucene.codecs.CodecUtil;int checkHeader(DataInput in, String codec, int minVersion, int maxVersion);int checkIndexHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] expectedID, String expectedSuffix);@throws;;;If the actual version is less than minVersion.;true
org.apache.lucene.codecs.CodecUtil;int checkHeader(DataInput in, String codec, int minVersion, int maxVersion);int checkIndexHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] expectedID, String expectedSuffix);@throws;;;If the actual version is greater than maxVersion.;true
org.apache.lucene.codecs.CodecUtil;int checkHeader(DataInput in, String codec, int minVersion, int maxVersion);int checkIndexHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] expectedID, String expectedSuffix);@throws;;;If there is an I/O error reading from the underlying medium.;true
org.apache.lucene.codecs.CodecUtil;int checkHeader(DataInput in, String codec, int minVersion, int maxVersion);void verifyAndCopyIndexHeader(IndexInput in, DataOutput out, byte[] expectedID);@throws;;;If there is an I/O error reading from the underlying medium.;true
org.apache.lucene.codecs.CodecUtil;int checkIndexHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] expectedID, String expectedSuffix);void verifyAndCopyIndexHeader(IndexInput in, DataOutput out, byte[] expectedID);@throws;;;If there is an I/O error reading from the underlying medium.;true
org.apache.lucene.codecs.CodecUtil;long checkFooter(ChecksumIndexInput in);long retrieveChecksum(IndexInput in);@return;;;actual checksum value;false
org.apache.lucene.codecs.CodecUtil;long readCRC(IndexInput input);void writeCRC(IndexOutput output);@throws;;;if CRC is formatted incorrectly (wrong bits set);false
org.apache.lucene.codecs.CodecUtil;long readCRC(IndexInput input);void writeCRC(IndexOutput output);@throws;;;if an i/o error occurs;true
org.apache.lucene.codecs.lucene50.Lucene50CompoundReader;void deleteFile(String name);void rename(String from, String to);Whole;;;   @throws always: not supported by CFS;false
org.apache.lucene.codecs.lucene50.ForUtil;void writeBlock(int[] data, byte[] encoded, IndexOutput out);void readBlock(IndexInput in, byte[] encoded, int[] decoded);@throws;;;If there is a low-level I/O error;true
org.apache.lucene.codecs.lucene50.ForUtil;void writeBlock(int[] data, byte[] encoded, IndexOutput out);void skipBlock(IndexInput in);@throws;;;If there is a low-level I/O error;true
org.apache.lucene.codecs.lucene50.ForUtil;void readBlock(IndexInput in, byte[] encoded, int[] decoded);void skipBlock(IndexInput in);@throws;;;If there is a low-level I/O error;true
org.apache.lucene.codecs.DocValuesProducer;NumericDocValues getNumeric(FieldInfo field);BinaryDocValues getBinary(FieldInfo field);Whole;;; The returned instance need not be thread-safe: it will only be  used by a single thread.    ;false
org.apache.lucene.codecs.DocValuesProducer;NumericDocValues getNumeric(FieldInfo field);SortedDocValues getSorted(FieldInfo field);Whole;;; The returned instance need not be thread-safe: it will only be  used by a single thread.    ;false
org.apache.lucene.codecs.DocValuesProducer;NumericDocValues getNumeric(FieldInfo field);SortedNumericDocValues getSortedNumeric(FieldInfo field);Whole;;; The returned instance need not be thread-safe: it will only be  used by a single thread.    ;false
org.apache.lucene.codecs.DocValuesProducer;NumericDocValues getNumeric(FieldInfo field);SortedSetDocValues getSortedSet(FieldInfo field);Whole;;; The returned instance need not be thread-safe: it will only be  used by a single thread.    ;false
org.apache.lucene.codecs.DocValuesProducer;BinaryDocValues getBinary(FieldInfo field);SortedDocValues getSorted(FieldInfo field);Whole;;; The returned instance need not be thread-safe: it will only be  used by a single thread.    ;false
org.apache.lucene.codecs.DocValuesProducer;BinaryDocValues getBinary(FieldInfo field);SortedNumericDocValues getSortedNumeric(FieldInfo field);Whole;;; The returned instance need not be thread-safe: it will only be  used by a single thread.    ;false
org.apache.lucene.codecs.DocValuesProducer;BinaryDocValues getBinary(FieldInfo field);SortedSetDocValues getSortedSet(FieldInfo field);Whole;;; The returned instance need not be thread-safe: it will only be  used by a single thread.    ;false
org.apache.lucene.codecs.DocValuesProducer;SortedDocValues getSorted(FieldInfo field);SortedNumericDocValues getSortedNumeric(FieldInfo field);Whole;;; The returned instance need not be thread-safe: it will only be  used by a single thread.    ;false
org.apache.lucene.codecs.DocValuesProducer;SortedDocValues getSorted(FieldInfo field);SortedSetDocValues getSortedSet(FieldInfo field);Whole;;; The returned instance need not be thread-safe: it will only be  used by a single thread.    ;false
org.apache.lucene.codecs.DocValuesProducer;SortedNumericDocValues getSortedNumeric(FieldInfo field);SortedSetDocValues getSortedSet(FieldInfo field);Whole;;; The returned instance need not be thread-safe: it will only be  used by a single thread.    ;false
org.apache.lucene.codecs.Codec;Codec getDefault();void setDefault(Codec codec);Whole;;; {@link IndexWriterConfig}s.    ;false
org.apache.lucene.analysis.Analyzer;TokenStream tokenStream(String fieldName, Reader reader);TokenStream tokenStream(String fieldName, String text);@return;;;TokenStream for iterating the analyzed content of reader;true
org.apache.lucene.analysis.Analyzer;TokenStream tokenStream(String fieldName, Reader reader);TokenStream tokenStream(String fieldName, String text);@param;String fieldName;String fieldName;the name of the field the created TokenStream is used for;true
org.apache.lucene.analysis.Analyzer;TokenStream tokenStream(String fieldName, Reader reader);TokenStream tokenStream(String fieldName, String text);@throws;;;if the Analyzer is closed.;true
org.apache.lucene.analysis.tokenattributes.PackedTokenAttributeImpl;void setPositionIncrement(int positionIncrement);int getPositionIncrement();Whole;;;{@inheritDoc} @see PositionIncrementAttribute    ;false
org.apache.lucene.analysis.tokenattributes.PackedTokenAttributeImpl;void setPositionLength(int positionLength);int getPositionLength();Whole;;;{@inheritDoc} @see PositionLengthAttribute    ;false
org.apache.lucene.analysis.tokenattributes.PackedTokenAttributeImpl;int startOffset();int endOffset();Whole;;;{@inheritDoc} @see OffsetAttribute    ;false
org.apache.lucene.analysis.tokenattributes.PackedTokenAttributeImpl;int startOffset();void setOffset(int startOffset, int endOffset);Whole;;;{@inheritDoc} @see OffsetAttribute    ;false
org.apache.lucene.analysis.tokenattributes.PackedTokenAttributeImpl;int endOffset();void setOffset(int startOffset, int endOffset);Whole;;;{@inheritDoc} @see OffsetAttribute    ;false
org.apache.lucene.analysis.tokenattributes.PackedTokenAttributeImpl;String type();void setType(String type);Whole;;;{@inheritDoc} @see TypeAttribute    ;false
org.apache.lucene.analysis.CharArrayMap; CharArrayMap(int startSize, boolean ignoreCase); CharArrayMap(Map c, boolean ignoreCase);@param;boolean ignoreCase;boolean ignoreCase;false if and only if the set should be case sensitive otherwise true.;true
org.apache.lucene.analysis.CharacterUtils;void toLowerCase(char[] buffer, int offset, int limit);void toUpperCase(char[] buffer, int offset, int limit);@param;int offset;int offset;the offset to start at;true
org.apache.lucene.analysis.CharacterUtils;void toLowerCase(char[] buffer, int offset, int limit);void toUpperCase(char[] buffer, int offset, int limit);@param;int limit;int limit;the max char in the buffer to lower case;true
org.apache.lucene.analysis.StopwordAnalyzerBase;CharArraySet loadStopwordSet(boolean ignoreCase, Class aClass, String resource, String comment);CharArraySet loadStopwordSet(Path stopwords);@return;;;a CharArraySet containing the distinct stopwords from the given file;true
org.apache.lucene.analysis.StopwordAnalyzerBase;CharArraySet loadStopwordSet(boolean ignoreCase, Class aClass, String resource, String comment);CharArraySet loadStopwordSet(Path stopwords);@throws;;;if loading the stopwords throws an IOException;true
org.apache.lucene.analysis.StopwordAnalyzerBase;CharArraySet loadStopwordSet(boolean ignoreCase, Class aClass, String resource, String comment);CharArraySet loadStopwordSet(Reader stopwords);@throws;;;if loading the stopwords throws an IOException;true
org.apache.lucene.analysis.StopwordAnalyzerBase;CharArraySet loadStopwordSet(Path stopwords);CharArraySet loadStopwordSet(Reader stopwords);@throws;;;if loading the stopwords throws an IOException;true
org.apache.lucene.analysis.Tokenizer; Tokenizer(); Tokenizer(AttributeFactory factory);Free text;;;Construct a tokenizer with no input, awaiting a call to {@link #setReader(java.io.Reader)} to provide input. ;true
org.apache.lucene.analysis.StopFilter;CharArraySet makeStopSet(String stopWords);CharArraySet makeStopSet(List stopWords);Free text;;;Builds a Set from an array of stop words, appropriate for passing into the StopFilter constructor. This permits this stopWords construction to be cached once when an Analyzer is constructed. ;true
org.apache.lucene.analysis.StopFilter;CharArraySet makeStopSet(String stopWords);CharArraySet makeStopSet(String[] stopWords, boolean ignoreCase);@param;String stopWords;String[] stopWords;An array of stopwords;true
org.apache.lucene.analysis.StopFilter;CharArraySet makeStopSet(List stopWords);CharArraySet makeStopSet(List stopWords, boolean ignoreCase);@return;;;A Set (CharArraySet) containing the words;true
org.apache.lucene.analysis.StopFilter;CharArraySet makeStopSet(List stopWords);CharArraySet makeStopSet(List stopWords, boolean ignoreCase);@param;List<?> stopWords;List<?> stopWords;A List of Strings or char[] or any other toString()-able list representing the stopwords;true
org.apache.lucene.analysis.AnalyzerWrapper;Analyzer getWrappedAnalyzer(String fieldName);TokenStreamComponents wrapComponents(String fieldName, TokenStreamComponents components);@param;String fieldName;String fieldName;Name of the field which is to be analyzed;true
org.apache.lucene.analysis.AnalyzerWrapper;Analyzer getWrappedAnalyzer(String fieldName);TokenStream wrapTokenStreamForNormalization(String fieldName, TokenStream in);@param;String fieldName;String fieldName;Name of the field which is to be analyzed;true
org.apache.lucene.analysis.AnalyzerWrapper;TokenStreamComponents wrapComponents(String fieldName, TokenStreamComponents components);TokenStream wrapTokenStreamForNormalization(String fieldName, TokenStream in);@return;;;Wrapped / altered TokenStreamComponents.;false
org.apache.lucene.analysis.AnalyzerWrapper;TokenStreamComponents wrapComponents(String fieldName, TokenStreamComponents components);TokenStream wrapTokenStreamForNormalization(String fieldName, TokenStream in);@param;String fieldName;String fieldName;Name of the field which is to be analyzed;true
org.apache.lucene.analysis.AnalyzerWrapper;Reader wrapReader(String fieldName, Reader reader);Reader wrapReaderForNormalization(String fieldName, Reader reader);@return;;;the wrapped reader;false
org.apache.lucene.analysis.AnalyzerWrapper;Reader wrapReader(String fieldName, Reader reader);Reader wrapReaderForNormalization(String fieldName, Reader reader);@param;String fieldName;String fieldName;name of the field which is to be analyzed;true
org.apache.lucene.analysis.AnalyzerWrapper;Reader wrapReader(String fieldName, Reader reader);Reader wrapReaderForNormalization(String fieldName, Reader reader);@param;Reader reader;Reader reader;the reader to wrap;true
org.apache.lucene.analysis.WordlistLoader;CharArraySet getWordSet(Reader reader, CharArraySet result);CharArraySet getWordSet(Reader reader);Free text;;;Reads lines from a Reader and adds every line as an entry to a CharArraySet (omitting leading and trailing whitespace). Every line of the Reader should contain only one word. The words need to be in lowercase if you make use of an Analyzer which uses LowerCaseFilter (like StandardAnalyzer). ;true
org.apache.lucene.analysis.WordlistLoader;CharArraySet getWordSet(Reader reader, CharArraySet result);CharArraySet getWordSet(Reader reader);@param;Reader reader;Reader reader;Reader containing the wordlist;true
org.apache.lucene.analysis.WordlistLoader;CharArraySet getWordSet(Reader reader, CharArraySet result);CharArraySet getWordSet(Reader reader, String comment);@param;Reader reader;Reader reader;Reader containing the wordlist;true
org.apache.lucene.analysis.WordlistLoader;CharArraySet getWordSet(Reader reader, CharArraySet result);CharArraySet getWordSet(Reader reader, String comment, CharArraySet result);@return;;;the given CharArraySet with the reader's words;true
org.apache.lucene.analysis.WordlistLoader;CharArraySet getWordSet(Reader reader, CharArraySet result);CharArraySet getWordSet(Reader reader, String comment, CharArraySet result);@param;Reader reader;Reader reader;Reader containing the wordlist;true
org.apache.lucene.analysis.WordlistLoader;CharArraySet getWordSet(Reader reader, CharArraySet result);CharArraySet getWordSet(Reader reader, String comment, CharArraySet result);@param;CharArraySet result;CharArraySet result;the CharArraySet to fill with the readers words;true
org.apache.lucene.analysis.WordlistLoader;CharArraySet getWordSet(Reader reader, CharArraySet result);CharArraySet getSnowballWordSet(Reader reader, CharArraySet result);@return;;;the given CharArraySet with the reader's words;false
org.apache.lucene.analysis.WordlistLoader;CharArraySet getWordSet(Reader reader, CharArraySet result);CharArraySet getSnowballWordSet(Reader reader, CharArraySet result);@param;CharArraySet result;CharArraySet result;the CharArraySet to fill with the readers words;true
org.apache.lucene.analysis.WordlistLoader;CharArraySet getWordSet(Reader reader);CharArraySet getWordSet(Reader reader, String comment);@return;;;A CharArraySet with the reader's words;true
org.apache.lucene.analysis.WordlistLoader;CharArraySet getWordSet(Reader reader);CharArraySet getWordSet(Reader reader, String comment);@param;Reader reader;Reader reader;Reader containing the wordlist;true
org.apache.lucene.analysis.WordlistLoader;CharArraySet getWordSet(Reader reader);CharArraySet getWordSet(Reader reader, String comment, CharArraySet result);@param;Reader reader;Reader reader;Reader containing the wordlist;true
org.apache.lucene.analysis.WordlistLoader;CharArraySet getWordSet(Reader reader);CharArraySet getSnowballWordSet(Reader reader);@return;;;A CharArraySet with the reader's words;false
org.apache.lucene.analysis.WordlistLoader;CharArraySet getWordSet(Reader reader, String comment);CharArraySet getWordSet(Reader reader, String comment, CharArraySet result);Free text;;;Reads lines from a Reader and adds every non-comment line as an entry to a CharArraySet (omitting leading and trailing whitespace). Every line of the Reader should contain only one word. The words need to be in lowercase if you make use of an Analyzer which uses LowerCaseFilter (like StandardAnalyzer). ;true
org.apache.lucene.analysis.WordlistLoader;CharArraySet getWordSet(Reader reader, String comment);CharArraySet getWordSet(Reader reader, String comment, CharArraySet result);@param;Reader reader;Reader reader;Reader containing the wordlist;true
org.apache.lucene.analysis.WordlistLoader;CharArraySet getWordSet(Reader reader, String comment);CharArraySet getWordSet(Reader reader, String comment, CharArraySet result);@param;String comment;String comment;The string representing a comment.;true
org.apache.lucene.analysis.WordlistLoader;CharArraySet getWordSet(Reader reader, String comment);CharArraySet getSnowballWordSet(Reader reader);@return;;;A CharArraySet with the reader's words;false
org.apache.lucene.analysis.WordlistLoader;CharArraySet getWordSet(Reader reader, String comment, CharArraySet result);CharArraySet getSnowballWordSet(Reader reader, CharArraySet result);@return;;;the given CharArraySet with the reader's words;false
org.apache.lucene.analysis.WordlistLoader;CharArraySet getWordSet(Reader reader, String comment, CharArraySet result);CharArraySet getSnowballWordSet(Reader reader, CharArraySet result);@param;CharArraySet result;CharArraySet result;the CharArraySet to fill with the readers words;true
org.apache.lucene.analysis.WordlistLoader;CharArraySet getSnowballWordSet(Reader reader, CharArraySet result);CharArraySet getSnowballWordSet(Reader reader);Free text;;;Reads stopwords from a stopword list in Snowball format. <p> The snowball format is the following: <ul> <li>Lines may contain multiple words separated by whitespace. <li>The comment character is the vertical line (&#124,). <li>Lines may contain trailing comments. </ul> ;true
org.apache.lucene.analysis.WordlistLoader;CharArraySet getSnowballWordSet(Reader reader, CharArraySet result);CharArraySet getSnowballWordSet(Reader reader);@param;Reader reader;Reader reader;Reader containing a Snowball stopword list;true
org.apache.lucene.analysis.WordlistLoader;CharArrayMap getStemDict(Reader reader, CharArrayMap result);List getLines(InputStream stream, Charset charset);@throws;;;If there is a low-level I/O error.;true
org.apache.lucene.analysis.CharArraySet; CharArraySet(int startSize, boolean ignoreCase); CharArraySet(Collection c, boolean ignoreCase);@param;boolean ignoreCase;boolean ignoreCase;false if and only if the set should be case sensitive otherwise true.;true
org.apache.lucene.util.BitUtil;long pop_intersect(long[] arr1, long[] arr2, int wordOffset, int numWords);long pop_union(long[] arr1, long[] arr2, int wordOffset, int numWords);Whole;;; Neither array is modified.    ;false
org.apache.lucene.util.BitUtil;long pop_intersect(long[] arr1, long[] arr2, int wordOffset, int numWords);long pop_andnot(long[] arr1, long[] arr2, int wordOffset, int numWords);Whole;;; Neither array is modified.    ;false
org.apache.lucene.util.BitUtil;long pop_intersect(long[] arr1, long[] arr2, int wordOffset, int numWords);long pop_xor(long[] arr1, long[] arr2, int wordOffset, int numWords);Free text;;; Neither array is modified. ;false
org.apache.lucene.util.BitUtil;long pop_union(long[] arr1, long[] arr2, int wordOffset, int numWords);long pop_andnot(long[] arr1, long[] arr2, int wordOffset, int numWords);Whole;;; Neither array is modified.    ;false
org.apache.lucene.util.BitUtil;long pop_union(long[] arr1, long[] arr2, int wordOffset, int numWords);long pop_xor(long[] arr1, long[] arr2, int wordOffset, int numWords);Free text;;; Neither array is modified. ;false
org.apache.lucene.util.BitUtil;long pop_andnot(long[] arr1, long[] arr2, int wordOffset, int numWords);long pop_xor(long[] arr1, long[] arr2, int wordOffset, int numWords);Free text;;; Neither array is modified. ;false
org.apache.lucene.util.SloppyMath;double haversinMeters(double lat1, double lon1, double lat2, double lon2);double haversinMeters(double sortKey);@return;;;distance in meters.;true
org.apache.lucene.util.SloppyMath;double haversinMeters(double lat1, double lon1, double lat2, double lon2);double haversinKilometers(double lat1, double lon1, double lat2, double lon2);@param;double lat1;double lat1;Latitude of the first point.;true
org.apache.lucene.util.SloppyMath;double haversinMeters(double lat1, double lon1, double lat2, double lon2);double haversinKilometers(double lat1, double lon1, double lat2, double lon2);@param;double lon1;double lon1;Longitude of the first point.;true
org.apache.lucene.util.SloppyMath;double haversinMeters(double lat1, double lon1, double lat2, double lon2);double haversinKilometers(double lat1, double lon1, double lat2, double lon2);@param;double lat2;double lat2;Latitude of the second point.;true
org.apache.lucene.util.SloppyMath;double haversinMeters(double lat1, double lon1, double lat2, double lon2);double haversinKilometers(double lat1, double lon1, double lat2, double lon2);@param;double lon2;double lon2;Longitude of the second point.;true
org.apache.lucene.util.MapOfSets;int put(K key, V val);int putAll(K key, Collection vals);@return;;;the size of the Set associated with key once val is added to it.;false
org.apache.lucene.util.IOUtils;void close(Closeable objects);void closeWhileHandlingException(Closeable objects);@param;Closeable objects;Closeable objects;objects to call close() on;true
org.apache.lucene.util.IOUtils;Reader getDecodingReader(InputStream stream, Charset charSet);Reader getDecodingReader(Class clazz, String resource, Charset charSet);@param;Charset charSet;Charset charSet;the expected charset;true
org.apache.lucene.util.IOUtils;void deleteFilesIgnoringExceptions(Path files);void deleteFilesIgnoringExceptions(Collection files);Whole;;;Deletes all given files, suppressing all thrown IOExceptions. <p> Some of the files may be null, if so they are ignored.    ;false
org.apache.lucene.util.IOUtils;void deleteFilesIfExist(Path files);void deleteFilesIfExist(Collection files);Whole;;;Deletes all given <tt>Path</tt>s, if they exist.  Some of the <tt>File</tt>s may be null, they are ignored.  After everything is deleted, the method either throws the first exception it hit while deleting, or completes normally if there were no exceptions.  @param files to delete  ;false
org.apache.lucene.util.IOUtils;boolean spins(Directory dir);boolean spins(Path path);@throws;;;if path does not exist.;true
org.apache.lucene.util.IntsRefBuilder;void copyInts(int[] otherInts, int otherOffset, int otherLength);void copyInts(IntsRef ints);Whole;;;Copies the given array into this instance.    ;false
org.apache.lucene.util.CommandLineUtil;FSDirectory newFSDirectory(String clazzName, Path path);FSDirectory newFSDirectory(String clazzName, Path path, LockFactory lf);@return;;;the new FSDirectory instance;true
org.apache.lucene.util.CommandLineUtil;FSDirectory newFSDirectory(String clazzName, Path path);FSDirectory newFSDirectory(String clazzName, Path path, LockFactory lf);@param;String clazzName;String clazzName;The name of the FSDirectory class to load;true
org.apache.lucene.util.CommandLineUtil;FSDirectory newFSDirectory(String clazzName, Path path);FSDirectory newFSDirectory(String clazzName, Path path, LockFactory lf);@param;Path path;Path path;The path to be used as parameter constructor;true
org.apache.lucene.util.CommandLineUtil;FSDirectory newFSDirectory(String clazzName, Path path);Class loadFSDirectoryClass(String clazzName);@param;String clazzName;String clazzName;The name of the FSDirectory class to load;true
org.apache.lucene.util.CommandLineUtil;FSDirectory newFSDirectory(String clazzName, Path path, LockFactory lf);Class loadFSDirectoryClass(String clazzName);@param;String clazzName;String clazzName;The name of the FSDirectory class to load;true
org.apache.lucene.util.CommandLineUtil;FSDirectory newFSDirectory(String clazzName, Path path, LockFactory lf);FSDirectory newFSDirectory(Class clazz, Path path, LockFactory lf);@param;LockFactory lf;LockFactory lf;The lock factory to be used;true
org.apache.lucene.util.CommandLineUtil;Class loadDirectoryClass(String clazzName);Class loadFSDirectoryClass(String clazzName);@throws;;;If the specified class cannot be found.;true
org.apache.lucene.util.CommandLineUtil;FSDirectory newFSDirectory(Class clazz, Path path);FSDirectory newFSDirectory(Class clazz, Path path, LockFactory lf);Free text;;;Creates a new specific FSDirectory instance ;true
org.apache.lucene.util.CommandLineUtil;FSDirectory newFSDirectory(Class clazz, Path path);FSDirectory newFSDirectory(Class clazz, Path path, LockFactory lf);@return;;;The new FSDirectory instance;true
org.apache.lucene.util.CommandLineUtil;FSDirectory newFSDirectory(Class clazz, Path path);FSDirectory newFSDirectory(Class clazz, Path path, LockFactory lf);@param;Class<? extends FSDirectory> clazz;Class<? extends FSDirectory> clazz;The class of the object to be created;true
org.apache.lucene.util.CommandLineUtil;FSDirectory newFSDirectory(Class clazz, Path path);FSDirectory newFSDirectory(Class clazz, Path path, LockFactory lf);@param;Path path;Path path;The file to be used as parameter constructor;true
org.apache.lucene.util.CommandLineUtil;FSDirectory newFSDirectory(Class clazz, Path path);FSDirectory newFSDirectory(Class clazz, Path path, LockFactory lf);@throws;;;If the Directory does not have a constructor that takes Path.;true
org.apache.lucene.util.CommandLineUtil;FSDirectory newFSDirectory(Class clazz, Path path);FSDirectory newFSDirectory(Class clazz, Path path, LockFactory lf);@throws;;;If the class is abstract or an interface.;true
org.apache.lucene.util.CommandLineUtil;FSDirectory newFSDirectory(Class clazz, Path path);FSDirectory newFSDirectory(Class clazz, Path path, LockFactory lf);@throws;;;If the constructor does not have public visibility.;true
org.apache.lucene.util.CommandLineUtil;FSDirectory newFSDirectory(Class clazz, Path path);FSDirectory newFSDirectory(Class clazz, Path path, LockFactory lf);@throws;;;If the constructor throws an exception;true
org.apache.lucene.util.BytesRefBuilder;void append(byte[] b, int off, int len);void append(BytesRef ref);Whole;;;Append the provided bytes to this builder.    ;false
org.apache.lucene.util.BytesRefBuilder;void append(byte[] b, int off, int len);void append(BytesRefBuilder builder);Whole;;;Append the provided bytes to this builder.    ;false
org.apache.lucene.util.BytesRefBuilder;void append(BytesRef ref);void append(BytesRefBuilder builder);Whole;;;Append the provided bytes to this builder.    ;false
org.apache.lucene.util.BytesRefBuilder;void copyChars(CharSequence text);void copyChars(CharSequence text, int off, int len);Whole;;;Replace the content of this buffer with UTF-8 encoded bytes that would represent the provided text.    ;false
org.apache.lucene.util.BytesRefBuilder;void copyChars(CharSequence text);void copyChars(char[] text, int off, int len);Whole;;;Replace the content of this buffer with UTF-8 encoded bytes that would represent the provided text.    ;false
org.apache.lucene.util.BytesRefBuilder;void copyChars(CharSequence text, int off, int len);void copyChars(char[] text, int off, int len);Whole;;;Replace the content of this buffer with UTF-8 encoded bytes that would represent the provided text.    ;false
org.apache.lucene.util.QueryBuilder;Query createBooleanQuery(String field, String queryText);Query createBooleanQuery(String field, String queryText, BooleanClause.Occur operator);@return;;;TermQuery or BooleanQuery, based on the analysis of queryText;true
org.apache.lucene.util.QueryBuilder;Query createBooleanQuery(String field, String queryText);Query createBooleanQuery(String field, String queryText, BooleanClause.Occur operator);@param;String field;String field;field name;true
org.apache.lucene.util.QueryBuilder;Query createBooleanQuery(String field, String queryText);Query createBooleanQuery(String field, String queryText, BooleanClause.Occur operator);@param;String queryText;String queryText;text to be passed to the analyzer;true
org.apache.lucene.util.QueryBuilder;Query createBooleanQuery(String field, String queryText);Query createPhraseQuery(String field, String queryText);@param;String field;String field;field name;true
org.apache.lucene.util.QueryBuilder;Query createBooleanQuery(String field, String queryText);Query createPhraseQuery(String field, String queryText);@param;String queryText;String queryText;text to be passed to the analyzer;true
org.apache.lucene.util.QueryBuilder;Query createBooleanQuery(String field, String queryText);Query createPhraseQuery(String field, String queryText, int phraseSlop);@param;String field;String field;field name;true
org.apache.lucene.util.QueryBuilder;Query createBooleanQuery(String field, String queryText);Query createPhraseQuery(String field, String queryText, int phraseSlop);@param;String queryText;String queryText;text to be passed to the analyzer;true
org.apache.lucene.util.QueryBuilder;Query createBooleanQuery(String field, String queryText);Query createMinShouldMatchQuery(String field, String queryText, float fraction);@return;;;TermQuery or BooleanQuery, based on the analysis of queryText;false
org.apache.lucene.util.QueryBuilder;Query createBooleanQuery(String field, String queryText);Query createMinShouldMatchQuery(String field, String queryText, float fraction);@param;String field;String field;field name;true
org.apache.lucene.util.QueryBuilder;Query createBooleanQuery(String field, String queryText);Query createMinShouldMatchQuery(String field, String queryText, float fraction);@param;String queryText;String queryText;text to be passed to the analyzer;true
org.apache.lucene.util.QueryBuilder;Query createBooleanQuery(String field, String queryText, BooleanClause.Occur operator);Query createPhraseQuery(String field, String queryText);@param;String field;String field;field name;true
org.apache.lucene.util.QueryBuilder;Query createBooleanQuery(String field, String queryText, BooleanClause.Occur operator);Query createPhraseQuery(String field, String queryText);@param;String queryText;String queryText;text to be passed to the analyzer;true
org.apache.lucene.util.QueryBuilder;Query createBooleanQuery(String field, String queryText, BooleanClause.Occur operator);Query createPhraseQuery(String field, String queryText, int phraseSlop);@param;String field;String field;field name;true
org.apache.lucene.util.QueryBuilder;Query createBooleanQuery(String field, String queryText, BooleanClause.Occur operator);Query createPhraseQuery(String field, String queryText, int phraseSlop);@param;String queryText;String queryText;text to be passed to the analyzer;true
org.apache.lucene.util.QueryBuilder;Query createBooleanQuery(String field, String queryText, BooleanClause.Occur operator);Query createMinShouldMatchQuery(String field, String queryText, float fraction);@return;;;TermQuery or BooleanQuery, based on the analysis of queryText;false
org.apache.lucene.util.QueryBuilder;Query createBooleanQuery(String field, String queryText, BooleanClause.Occur operator);Query createMinShouldMatchQuery(String field, String queryText, float fraction);@param;String field;String field;field name;true
org.apache.lucene.util.QueryBuilder;Query createBooleanQuery(String field, String queryText, BooleanClause.Occur operator);Query createMinShouldMatchQuery(String field, String queryText, float fraction);@param;String queryText;String queryText;text to be passed to the analyzer;true
org.apache.lucene.util.QueryBuilder;Query createPhraseQuery(String field, String queryText);Query createPhraseQuery(String field, String queryText, int phraseSlop);@return;;;TermQuery, BooleanQuery, PhraseQuery, or MultiPhraseQuery, based on the analysis of queryText;true
org.apache.lucene.util.QueryBuilder;Query createPhraseQuery(String field, String queryText);Query createPhraseQuery(String field, String queryText, int phraseSlop);@param;String field;String field;field name;true
org.apache.lucene.util.QueryBuilder;Query createPhraseQuery(String field, String queryText);Query createPhraseQuery(String field, String queryText, int phraseSlop);@param;String queryText;String queryText;text to be passed to the analyzer;true
org.apache.lucene.util.QueryBuilder;Query createPhraseQuery(String field, String queryText);Query createMinShouldMatchQuery(String field, String queryText, float fraction);@param;String field;String field;field name;true
org.apache.lucene.util.QueryBuilder;Query createPhraseQuery(String field, String queryText);Query createMinShouldMatchQuery(String field, String queryText, float fraction);@param;String queryText;String queryText;text to be passed to the analyzer;true
org.apache.lucene.util.QueryBuilder;Query createPhraseQuery(String field, String queryText, int phraseSlop);Query createMinShouldMatchQuery(String field, String queryText, float fraction);@param;String field;String field;field name;true
org.apache.lucene.util.QueryBuilder;Query createPhraseQuery(String field, String queryText, int phraseSlop);Query createMinShouldMatchQuery(String field, String queryText, float fraction);@param;String queryText;String queryText;text to be passed to the analyzer;true
org.apache.lucene.util.QueryBuilder;Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop);Query createFieldQuery(TokenStream source, BooleanClause.Occur operator, String field, boolean quoted, int phraseSlop);@param;BooleanClause.Occur operator;BooleanClause.Occur operator;default boolean operator used for this query;true
org.apache.lucene.util.QueryBuilder;Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop);Query createFieldQuery(TokenStream source, BooleanClause.Occur operator, String field, boolean quoted, int phraseSlop);@param;String field;String field;field to create queries against;true
org.apache.lucene.util.QueryBuilder;Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop);Query createFieldQuery(TokenStream source, BooleanClause.Occur operator, String field, boolean quoted, int phraseSlop);@param;boolean quoted;boolean quoted;true if phrases should be generated when terms occur at more than one position;true
org.apache.lucene.util.QueryBuilder;Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop);Query createFieldQuery(TokenStream source, BooleanClause.Occur operator, String field, boolean quoted, int phraseSlop);@param;int phraseSlop;int phraseSlop;slop factor for phrase/multiphrase queries;true
org.apache.lucene.util.QueryBuilder;void setEnableGraphQueries(boolean v);boolean getEnableGraphQueries();Whole;;;@lucene.experimental    ;false
org.apache.lucene.util.QueryBuilder;Query newSynonymQuery(Term[] terms);Query newGraphSynonymQuery(Iterator queries);@return;;;new Query instance;false
org.apache.lucene.util.RecyclingByteBlockAllocator; RecyclingByteBlockAllocator(int blockSize, int maxBufferedBlocks, Counter bytesUsed); RecyclingByteBlockAllocator(int blockSize, int maxBufferedBlocks);@param;int blockSize;int blockSize;the block size in bytes;true
org.apache.lucene.util.RecyclingByteBlockAllocator; RecyclingByteBlockAllocator(int blockSize, int maxBufferedBlocks, Counter bytesUsed); RecyclingByteBlockAllocator(int blockSize, int maxBufferedBlocks);@param;int maxBufferedBlocks;int maxBufferedBlocks;maximum number of buffered byte block;true
org.apache.lucene.util.BytesRefHash; BytesRefHash(ByteBlockPool pool); BytesRefHash(ByteBlockPool pool, int capacity, BytesStartArray bytesStartArray);Whole;;;Creates a new {@link BytesRefHash}    ;false
org.apache.lucene.util.RamUsageEstimator;String humanReadableUnits(long bytes);String humanReadableUnits(long bytes, DecimalFormat df);Whole;;;Returns <code>size</code> in human-readable units (GB, MB, KB or bytes).    ;false
org.apache.lucene.util.UnicodeUtil;int codePointCount(BytesRef utf8);int UTF8toUTF32(BytesRef utf8, int[] ints);@throws;;;If invalid codepoint header byte occurs or the content is prematurely truncated.;true
org.apache.lucene.util.packed.PackedInts;Decoder getDecoder(Format format, int version, int bitsPerValue);Encoder getEncoder(Format format, int version, int bitsPerValue);@param;Format format;Format format;the format used to store packed ints;true
org.apache.lucene.util.packed.PackedInts;Decoder getDecoder(Format format, int version, int bitsPerValue);Encoder getEncoder(Format format, int version, int bitsPerValue);@param;int version;int version;the compatibility version;true
org.apache.lucene.util.packed.PackedInts;Decoder getDecoder(Format format, int version, int bitsPerValue);Encoder getEncoder(Format format, int version, int bitsPerValue);@param;int bitsPerValue;int bitsPerValue;the number of bits per value;true
org.apache.lucene.util.packed.PackedInts;Decoder getDecoder(Format format, int version, int bitsPerValue);Reader getReaderNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue);@param;int bitsPerValue;int bitsPerValue;the number of bits per value;true
org.apache.lucene.util.packed.PackedInts;Decoder getDecoder(Format format, int version, int bitsPerValue);ReaderIterator getReaderIteratorNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue, int mem);@param;int bitsPerValue;int bitsPerValue;the number of bits per value;true
org.apache.lucene.util.packed.PackedInts;Decoder getDecoder(Format format, int version, int bitsPerValue);Reader getDirectReaderNoHeader(IndexInput in, Format format, int version, int valueCount, int bitsPerValue);@param;int bitsPerValue;int bitsPerValue;the number of bits per value;true
org.apache.lucene.util.packed.PackedInts;Decoder getDecoder(Format format, int version, int bitsPerValue);Writer getWriterNoHeader(DataOutput out, Format format, int valueCount, int bitsPerValue, int mem);@param;int bitsPerValue;int bitsPerValue;the number of bits per value;true
org.apache.lucene.util.packed.PackedInts;Decoder getDecoder(Format format, int version, int bitsPerValue);Writer getWriter(DataOutput out, int valueCount, int bitsPerValue, float acceptableOverheadRatio);@param;int bitsPerValue;int bitsPerValue;the number of bits per value;true
org.apache.lucene.util.packed.PackedInts;Encoder getEncoder(Format format, int version, int bitsPerValue);Reader getReaderNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue);@param;int bitsPerValue;int bitsPerValue;the number of bits per value;true
org.apache.lucene.util.packed.PackedInts;Encoder getEncoder(Format format, int version, int bitsPerValue);ReaderIterator getReaderIteratorNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue, int mem);@param;int bitsPerValue;int bitsPerValue;the number of bits per value;true
org.apache.lucene.util.packed.PackedInts;Encoder getEncoder(Format format, int version, int bitsPerValue);Reader getDirectReaderNoHeader(IndexInput in, Format format, int version, int valueCount, int bitsPerValue);@param;int bitsPerValue;int bitsPerValue;the number of bits per value;true
org.apache.lucene.util.packed.PackedInts;Encoder getEncoder(Format format, int version, int bitsPerValue);Writer getWriterNoHeader(DataOutput out, Format format, int valueCount, int bitsPerValue, int mem);@param;int bitsPerValue;int bitsPerValue;the number of bits per value;true
org.apache.lucene.util.packed.PackedInts;Encoder getEncoder(Format format, int version, int bitsPerValue);Writer getWriter(DataOutput out, int valueCount, int bitsPerValue, float acceptableOverheadRatio);@param;int bitsPerValue;int bitsPerValue;the number of bits per value;true
org.apache.lucene.util.packed.PackedInts;Reader getReaderNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue);Reader getReader(DataInput in);@return;;;a Reader;false
org.apache.lucene.util.packed.PackedInts;Reader getReaderNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue);Reader getReader(DataInput in);@throws;;;If there is a low-level I/O error;true
org.apache.lucene.util.packed.PackedInts;Reader getReaderNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue);ReaderIterator getReaderIteratorNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue, int mem);@param;DataInput in;DataInput in;the stream to read data from, positioned at the beginning of the packed values;true
org.apache.lucene.util.packed.PackedInts;Reader getReaderNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue);ReaderIterator getReaderIteratorNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue, int mem);@param;Format format;Format format;the format used to serialize;true
org.apache.lucene.util.packed.PackedInts;Reader getReaderNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue);ReaderIterator getReaderIteratorNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue, int mem);@param;int version;int version;the version used to serialize the data;true
org.apache.lucene.util.packed.PackedInts;Reader getReaderNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue);ReaderIterator getReaderIteratorNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue, int mem);@param;int valueCount;int valueCount;how many values the stream holds;true
org.apache.lucene.util.packed.PackedInts;Reader getReaderNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue);ReaderIterator getReaderIteratorNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue, int mem);@param;int bitsPerValue;int bitsPerValue;the number of bits per value;true
org.apache.lucene.util.packed.PackedInts;Reader getReaderNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue);Reader getDirectReaderNoHeader(IndexInput in, Format format, int version, int valueCount, int bitsPerValue);@param;Format format;Format format;the format used to serialize;true
org.apache.lucene.util.packed.PackedInts;Reader getReaderNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue);Reader getDirectReaderNoHeader(IndexInput in, Format format, int version, int valueCount, int bitsPerValue);@param;int version;int version;the version used to serialize the data;true
org.apache.lucene.util.packed.PackedInts;Reader getReaderNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue);Reader getDirectReaderNoHeader(IndexInput in, Format format, int version, int valueCount, int bitsPerValue);@param;int valueCount;int valueCount;how many values the stream holds;true
org.apache.lucene.util.packed.PackedInts;Reader getReaderNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue);Reader getDirectReaderNoHeader(IndexInput in, Format format, int version, int valueCount, int bitsPerValue);@param;int bitsPerValue;int bitsPerValue;the number of bits per value;true
org.apache.lucene.util.packed.PackedInts;Reader getReaderNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue);Reader getDirectReader(IndexInput in);@throws;;;If there is a low-level I/O error;true
org.apache.lucene.util.packed.PackedInts;Reader getReaderNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue);Writer getWriterNoHeader(DataOutput out, Format format, int valueCount, int bitsPerValue, int mem);@param;int bitsPerValue;int bitsPerValue;the number of bits per value;true
org.apache.lucene.util.packed.PackedInts;Reader getReaderNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue);Writer getWriter(DataOutput out, int valueCount, int bitsPerValue, float acceptableOverheadRatio);@param;int bitsPerValue;int bitsPerValue;the number of bits per value;true
org.apache.lucene.util.packed.PackedInts;Reader getReaderNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue);Writer getWriter(DataOutput out, int valueCount, int bitsPerValue, float acceptableOverheadRatio);@throws;;;If there is a low-level I/O error;true
org.apache.lucene.util.packed.PackedInts;Reader getReader(DataInput in);Reader getDirectReaderNoHeader(IndexInput in, Format format, int version, int valueCount, int bitsPerValue);@param;DataInput in;IndexInput in;the stream to read data from;true
org.apache.lucene.util.packed.PackedInts;Reader getReader(DataInput in);Reader getDirectReader(IndexInput in);@param;DataInput in;IndexInput in;the stream to read data from;true
org.apache.lucene.util.packed.PackedInts;Reader getReader(DataInput in);Reader getDirectReader(IndexInput in);@throws;;;If there is a low-level I/O error;true
org.apache.lucene.util.packed.PackedInts;Reader getReader(DataInput in);Writer getWriter(DataOutput out, int valueCount, int bitsPerValue, float acceptableOverheadRatio);@throws;;;If there is a low-level I/O error;true
org.apache.lucene.util.packed.PackedInts;ReaderIterator getReaderIteratorNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue, int mem);ReaderIterator getReaderIterator(DataInput in, int mem);@param;int mem;int mem;how much memory the iterator is allowed to use to read-ahead (likely to speed up iteration);true
org.apache.lucene.util.packed.PackedInts;ReaderIterator getReaderIteratorNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue, int mem);Reader getDirectReaderNoHeader(IndexInput in, Format format, int version, int valueCount, int bitsPerValue);@param;Format format;Format format;the format used to serialize;true
org.apache.lucene.util.packed.PackedInts;ReaderIterator getReaderIteratorNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue, int mem);Reader getDirectReaderNoHeader(IndexInput in, Format format, int version, int valueCount, int bitsPerValue);@param;int version;int version;the version used to serialize the data;true
org.apache.lucene.util.packed.PackedInts;ReaderIterator getReaderIteratorNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue, int mem);Reader getDirectReaderNoHeader(IndexInput in, Format format, int version, int valueCount, int bitsPerValue);@param;int valueCount;int valueCount;how many values the stream holds;true
org.apache.lucene.util.packed.PackedInts;ReaderIterator getReaderIteratorNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue, int mem);Reader getDirectReaderNoHeader(IndexInput in, Format format, int version, int valueCount, int bitsPerValue);@param;int bitsPerValue;int bitsPerValue;the number of bits per value;true
org.apache.lucene.util.packed.PackedInts;ReaderIterator getReaderIteratorNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue, int mem);Writer getWriterNoHeader(DataOutput out, Format format, int valueCount, int bitsPerValue, int mem);@param;int bitsPerValue;int bitsPerValue;the number of bits per value;true
org.apache.lucene.util.packed.PackedInts;ReaderIterator getReaderIteratorNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue, int mem);Writer getWriter(DataOutput out, int valueCount, int bitsPerValue, float acceptableOverheadRatio);@param;int bitsPerValue;int bitsPerValue;the number of bits per value;true
org.apache.lucene.util.packed.PackedInts;Reader getDirectReaderNoHeader(IndexInput in, Format format, int version, int valueCount, int bitsPerValue);Reader getDirectReader(IndexInput in);@return;;;a direct Reader;false
org.apache.lucene.util.packed.PackedInts;Reader getDirectReaderNoHeader(IndexInput in, Format format, int version, int valueCount, int bitsPerValue);Reader getDirectReader(IndexInput in);@param;IndexInput in;IndexInput in;the stream to read data from;true
org.apache.lucene.util.packed.PackedInts;Reader getDirectReaderNoHeader(IndexInput in, Format format, int version, int valueCount, int bitsPerValue);Writer getWriterNoHeader(DataOutput out, Format format, int valueCount, int bitsPerValue, int mem);@param;int bitsPerValue;int bitsPerValue;the number of bits per value;true
org.apache.lucene.util.packed.PackedInts;Reader getDirectReaderNoHeader(IndexInput in, Format format, int version, int valueCount, int bitsPerValue);Writer getWriter(DataOutput out, int valueCount, int bitsPerValue, float acceptableOverheadRatio);@param;int bitsPerValue;int bitsPerValue;the number of bits per value;true
org.apache.lucene.util.packed.PackedInts;Reader getDirectReader(IndexInput in);Writer getWriter(DataOutput out, int valueCount, int bitsPerValue, float acceptableOverheadRatio);@throws;;;If there is a low-level I/O error;true
org.apache.lucene.util.packed.PackedInts;Mutable getMutable(int valueCount, int bitsPerValue, float acceptableOverheadRatio);Writer getWriter(DataOutput out, int valueCount, int bitsPerValue, float acceptableOverheadRatio);@param;float acceptableOverheadRatio;float acceptableOverheadRatio;an acceptable overhead ratio per value;true
org.apache.lucene.util.packed.PackedInts;Writer getWriterNoHeader(DataOutput out, Format format, int valueCount, int bitsPerValue, int mem);Writer getWriter(DataOutput out, int valueCount, int bitsPerValue, float acceptableOverheadRatio);@return;;;a Writer;false
org.apache.lucene.util.packed.PackedInts;Writer getWriterNoHeader(DataOutput out, Format format, int valueCount, int bitsPerValue, int mem);Writer getWriter(DataOutput out, int valueCount, int bitsPerValue, float acceptableOverheadRatio);@param;DataOutput out;DataOutput out;the data output;true
org.apache.lucene.util.packed.PackedInts;Writer getWriterNoHeader(DataOutput out, Format format, int valueCount, int bitsPerValue, int mem);Writer getWriter(DataOutput out, int valueCount, int bitsPerValue, float acceptableOverheadRatio);@param;int valueCount;int valueCount;the number of values;true
org.apache.lucene.util.packed.PackedInts;Writer getWriterNoHeader(DataOutput out, Format format, int valueCount, int bitsPerValue, int mem);Writer getWriter(DataOutput out, int valueCount, int bitsPerValue, float acceptableOverheadRatio);@param;int bitsPerValue;int bitsPerValue;the number of bits per value;true
org.apache.lucene.util.packed.DirectWriter;int bitsRequired(long maxValue);int unsignedBitsRequired(long maxValue);@return;;;the amount of bits needed to represent values from 0 to maxValue.;false
org.apache.lucene.util.packed.DirectWriter;int bitsRequired(long maxValue);int unsignedBitsRequired(long maxValue);@param;long maxValue;long maxValue;the maximum value that should be representable.;true
org.apache.lucene.util.packed.Packed64; Packed64(int valueCount, int bitsPerValue); Packed64(int packedIntsVersion, DataInput in, int valueCount, int bitsPerValue);@param;int valueCount;int valueCount;the number of elements.;true
org.apache.lucene.util.packed.Packed64; Packed64(int valueCount, int bitsPerValue); Packed64(int packedIntsVersion, DataInput in, int valueCount, int bitsPerValue);@param;int bitsPerValue;int bitsPerValue;the number of bits available for any given value.;true
org.apache.lucene.util.automaton.Operations;Automaton concatenate(Automaton a1, Automaton a2);Automaton concatenate(List l);Whole;;;Returns an automaton that accepts the concatenation of the languages of the given automata. <p> Complexity: linear in total number of states.    ;false
org.apache.lucene.util.automaton.Operations;Automaton complement(Automaton a, int maxDeterminizedStates);BytesRef getCommonSuffixBytesRef(Automaton a, int maxDeterminizedStates);@param;int maxDeterminizedStates;int maxDeterminizedStates;maximum number of states determinizing the automaton can result in. Set higher to allow more complex queries and lower to prevent memory exhaustion.;true
org.apache.lucene.util.automaton.Operations;Automaton union(Automaton a1, Automaton a2);Automaton union(Collection l);Whole;;;Returns an automaton that accepts the union of the languages of the given automata. <p> Complexity: linear in number of states.    ;false
org.apache.lucene.util.automaton.FiniteStringsIterator; FiniteStringsIterator(Automaton a); FiniteStringsIterator(Automaton a, int startState, int endState);Free text;;;Constructor. ;true
org.apache.lucene.util.automaton.FiniteStringsIterator; FiniteStringsIterator(Automaton a); FiniteStringsIterator(Automaton a, int startState, int endState);@param;Automaton a;Automaton a;Automaton to create finite string from.;true
org.apache.lucene.util.automaton.RegExp; RegExp(String s); RegExp(String s, int syntax_flags);@param;String s;String s;regexp string;true
org.apache.lucene.util.automaton.RegExp; RegExp(String s); RegExp(String s, int syntax_flags);@throws;;;if an error occured while parsing the regular expression;true
org.apache.lucene.util.automaton.RegExp;Automaton toAutomaton(int maxDeterminizedStates);Automaton toAutomaton(AutomatonProvider automaton_provider, int maxDeterminizedStates);Free text;;;Constructs new <code>Automaton</code> from this <code>RegExp</code>. The constructed automaton is minimal and deterministic and has no transitions to dead states. ;true
org.apache.lucene.util.automaton.RegExp;Automaton toAutomaton(int maxDeterminizedStates);Automaton toAutomaton(AutomatonProvider automaton_provider, int maxDeterminizedStates);@param;int maxDeterminizedStates;int maxDeterminizedStates;maximum number of states in the resulting automata. If the automata would need more than this many states TooComplextToDeterminizeException is thrown. Higher number require more space but can process more complex regexes.;true
org.apache.lucene.util.automaton.RegExp;Automaton toAutomaton(int maxDeterminizedStates);Automaton toAutomaton(AutomatonProvider automaton_provider, int maxDeterminizedStates);@throws;;;if this regular expression uses a named identifier that is not available from the automaton provider;true
org.apache.lucene.util.automaton.RegExp;Automaton toAutomaton(int maxDeterminizedStates);Automaton toAutomaton(AutomatonProvider automaton_provider, int maxDeterminizedStates);@throws;;;if determinizing this regexp requires more than maxDeterminizedStates states;true
org.apache.lucene.util.automaton.RegExp;Automaton toAutomaton(int maxDeterminizedStates);Automaton toAutomaton(Map automata, int maxDeterminizedStates);Free text;;;Constructs new <code>Automaton</code> from this <code>RegExp</code>. The constructed automaton is minimal and deterministic and has no transitions to dead states. ;true
org.apache.lucene.util.automaton.RegExp;Automaton toAutomaton(int maxDeterminizedStates);Automaton toAutomaton(Map automata, int maxDeterminizedStates);@throws;;;if determinizing this regexp requires more than maxDeterminizedStates states;true
org.apache.lucene.util.automaton.RegExp;Automaton toAutomaton(AutomatonProvider automaton_provider, int maxDeterminizedStates);Automaton toAutomaton(Map automata, int maxDeterminizedStates);Free text;;;Constructs new <code>Automaton</code> from this <code>RegExp</code>. The constructed automaton is minimal and deterministic and has no transitions to dead states. ;true
org.apache.lucene.util.automaton.RegExp;Automaton toAutomaton(AutomatonProvider automaton_provider, int maxDeterminizedStates);Automaton toAutomaton(Map automata, int maxDeterminizedStates);@throws;;;if determinizing this regexp requires more than maxDeterminizedStates states;true
org.apache.lucene.util.automaton.RunAutomaton; RunAutomaton(Automaton a, int alphabetSize); RunAutomaton(Automaton a, int alphabetSize, int maxDeterminizedStates);Free text;;;Constructs a new <code>RunAutomaton</code> from a deterministic <code>Automaton</code>. ;true
org.apache.lucene.util.automaton.RunAutomaton; RunAutomaton(Automaton a, int alphabetSize); RunAutomaton(Automaton a, int alphabetSize, int maxDeterminizedStates);@param;Automaton a;Automaton a;an automaton;true
org.apache.lucene.util.StringHelper;boolean startsWith(byte[] ref, BytesRef prefix);boolean startsWith(BytesRef ref, BytesRef prefix);Free text;;;Returns <code>true</code> iff the ref starts with the given prefix. Otherwise <code>false</code>. ;true
org.apache.lucene.util.StringHelper;boolean startsWith(byte[] ref, BytesRef prefix);boolean startsWith(BytesRef ref, BytesRef prefix);@return;;;Returns true iff the ref starts with the given prefix. Otherwise false.;true
org.apache.lucene.util.StringHelper;boolean startsWith(byte[] ref, BytesRef prefix);boolean startsWith(BytesRef ref, BytesRef prefix);@param;BytesRef prefix;BytesRef prefix;the expected prefix;true
org.apache.lucene.util.StringHelper;boolean startsWith(BytesRef ref, BytesRef prefix);boolean endsWith(BytesRef ref, BytesRef suffix);@param;BytesRef ref;BytesRef ref;the BytesRef to test;true
org.apache.lucene.util.LongBitSet;long nextSetBit(long index);long prevSetBit(long index);Whole;;; -1 is returned if there are no more set bits.    ;false
org.apache.lucene.util.LongBitSet;void flip(long startIndex, long endIndex);void set(long startIndex, long endIndex);@param;long startIndex;long startIndex;lower index;true
org.apache.lucene.util.LongBitSet;void flip(long startIndex, long endIndex);void clear(long startIndex, long endIndex);@param;long startIndex;long startIndex;lower index;true
org.apache.lucene.util.LongBitSet;void set(long startIndex, long endIndex);void clear(long startIndex, long endIndex);@param;long startIndex;long startIndex;lower index;true
org.apache.lucene.util.fst.FST;Arc readLastTargetArc(Arc follow, Arc arc, BytesReader in);Arc readFirstTargetArc(Arc follow, Arc arc, BytesReader in);@return;;;Returns the second argument (arc).;false
org.apache.lucene.util.ArrayUtil;boolean equals(byte[] left, int offsetLeft, byte[] right, int offsetRight, int length);boolean equals(int[] left, int offsetLeft, int[] right, int offsetRight, int length);Whole;;;See if two array slices are the same.  @param The left array to compare@param The offset into the array. Must be positive@param The right array to compare@param the offset into the right array. Must be positive@param The length of the section of the array to compare @return true if the two arrays, starting at their respective offsets, are equal ;false
org.apache.lucene.util.ArrayUtil;void introSort(T[] a, int fromIndex, int toIndex, Comparator comp);void introSort(T[] a, int fromIndex, int toIndex);@param;int fromIndex;int fromIndex;start index (inclusive);true
org.apache.lucene.util.ArrayUtil;void introSort(T[] a, int fromIndex, int toIndex, Comparator comp);void introSort(T[] a, int fromIndex, int toIndex);@param;int toIndex;int toIndex;end index (exclusive);true
org.apache.lucene.util.ArrayUtil;void introSort(T[] a, int fromIndex, int toIndex, Comparator comp);void timSort(T[] a, int fromIndex, int toIndex, Comparator comp);@param;int fromIndex;int fromIndex;start index (inclusive);true
org.apache.lucene.util.ArrayUtil;void introSort(T[] a, int fromIndex, int toIndex, Comparator comp);void timSort(T[] a, int fromIndex, int toIndex, Comparator comp);@param;int toIndex;int toIndex;end index (exclusive);true
org.apache.lucene.util.ArrayUtil;void introSort(T[] a, int fromIndex, int toIndex, Comparator comp);void timSort(T[] a, int fromIndex, int toIndex);@param;int fromIndex;int fromIndex;start index (inclusive);true
org.apache.lucene.util.ArrayUtil;void introSort(T[] a, int fromIndex, int toIndex, Comparator comp);void timSort(T[] a, int fromIndex, int toIndex);@param;int toIndex;int toIndex;end index (exclusive);true
org.apache.lucene.util.ArrayUtil;void introSort(T[] a, int fromIndex, int toIndex);void timSort(T[] a, int fromIndex, int toIndex, Comparator comp);@param;int fromIndex;int fromIndex;start index (inclusive);true
org.apache.lucene.util.ArrayUtil;void introSort(T[] a, int fromIndex, int toIndex);void timSort(T[] a, int fromIndex, int toIndex, Comparator comp);@param;int toIndex;int toIndex;end index (exclusive);true
org.apache.lucene.util.ArrayUtil;void introSort(T[] a, int fromIndex, int toIndex);void timSort(T[] a, int fromIndex, int toIndex);@param;int fromIndex;int fromIndex;start index (inclusive);true
org.apache.lucene.util.ArrayUtil;void introSort(T[] a, int fromIndex, int toIndex);void timSort(T[] a, int fromIndex, int toIndex);@param;int toIndex;int toIndex;end index (exclusive);true
org.apache.lucene.util.ArrayUtil;void timSort(T[] a, int fromIndex, int toIndex, Comparator comp);void timSort(T[] a, int fromIndex, int toIndex);@param;int fromIndex;int fromIndex;start index (inclusive);true
org.apache.lucene.util.ArrayUtil;void timSort(T[] a, int fromIndex, int toIndex, Comparator comp);void timSort(T[] a, int fromIndex, int toIndex);@param;int toIndex;int toIndex;end index (exclusive);true
org.apache.lucene.util.CollectionUtil;void introSort(List list, Comparator comp);void introSort(List list);@throws;;;if list is e.g. a linked list without random access.;true
org.apache.lucene.util.CollectionUtil;void introSort(List list, Comparator comp);void timSort(List list, Comparator comp);@throws;;;if list is e.g. a linked list without random access.;true
org.apache.lucene.util.CollectionUtil;void introSort(List list, Comparator comp);void timSort(List list);@throws;;;if list is e.g. a linked list without random access.;true
org.apache.lucene.util.CollectionUtil;void introSort(List list);void timSort(List list, Comparator comp);@throws;;;if list is e.g. a linked list without random access.;true
org.apache.lucene.util.CollectionUtil;void introSort(List list);void timSort(List list);@throws;;;if list is e.g. a linked list without random access.;true
org.apache.lucene.util.CollectionUtil;void timSort(List list, Comparator comp);void timSort(List list);@throws;;;if list is e.g. a linked list without random access.;true
org.apache.lucene.util.CharsRefBuilder;void copyUTF8Bytes(byte[] bytes, int offset, int length);void copyUTF8Bytes(BytesRef bytes);Whole;;;Copy the provided bytes, interpreted as UTF-8 bytes.    ;false
org.apache.lucene.util.WeakIdentityMap;WeakIdentityMap newHashMap(boolean reapOnRead);WeakIdentityMap newConcurrentHashMap(boolean reapOnRead);@param;boolean reapOnRead;boolean reapOnRead;controls if the map cleans up the reference queue on every read operation.;true
org.apache.lucene.util.FixedBitSet;void flip(int startIndex, int endIndex);void set(int startIndex, int endIndex);@param;int startIndex;int startIndex;lower index;true
org.apache.lucene.geo.GeoEncodingUtils;int encodeLatitude(double latitude);int encodeLatitudeCeil(double latitude);@return;;;encoded value as a 32-bit int;false
org.apache.lucene.geo.GeoEncodingUtils;int encodeLatitude(double latitude);int encodeLatitudeCeil(double latitude);@param;double latitude;double latitude;latitude value: must be within standard +/-90 coordinate bounds.;true
org.apache.lucene.geo.GeoEncodingUtils;int encodeLatitude(double latitude);int encodeLatitudeCeil(double latitude);@throws;;;if latitude is out of bounds;true
org.apache.lucene.geo.GeoEncodingUtils;int encodeLatitude(double latitude);int encodeLongitude(double longitude);@return;;;encoded value as a 32-bit int;false
org.apache.lucene.geo.GeoEncodingUtils;int encodeLatitude(double latitude);int encodeLongitudeCeil(double longitude);@return;;;encoded value as a 32-bit int;false
org.apache.lucene.geo.GeoEncodingUtils;int encodeLatitudeCeil(double latitude);int encodeLongitude(double longitude);@return;;;encoded value as a 32-bit int;false
org.apache.lucene.geo.GeoEncodingUtils;int encodeLatitudeCeil(double latitude);int encodeLongitudeCeil(double longitude);@return;;;encoded value as a 32-bit int;false
org.apache.lucene.geo.GeoEncodingUtils;int encodeLongitude(double longitude);int encodeLongitudeCeil(double longitude);@return;;;encoded value as a 32-bit int;false
org.apache.lucene.geo.GeoEncodingUtils;int encodeLongitude(double longitude);int encodeLongitudeCeil(double longitude);@param;double longitude;double longitude;longitude value: must be within standard +/-180 coordinate bounds.;true
org.apache.lucene.geo.GeoEncodingUtils;int encodeLongitude(double longitude);int encodeLongitudeCeil(double longitude);@throws;;;if longitude is out of bounds;true
org.apache.lucene.geo.GeoEncodingUtils;double decodeLatitude(int encoded);double decodeLatitude(byte[] src, int offset);@return;;;decoded latitude value.;true
org.apache.lucene.geo.GeoEncodingUtils;double decodeLatitude(int encoded);double decodeLongitude(int encoded);@param;int encoded;int encoded;encoded value: 32-bit quantized value.;true
org.apache.lucene.geo.GeoEncodingUtils;double decodeLatitude(byte[] src, int offset);double decodeLongitude(byte[] src, int offset);Free text;;;Turns quantized value from byte array back into a double. ;false
org.apache.lucene.geo.GeoEncodingUtils;double decodeLatitude(byte[] src, int offset);double decodeLongitude(byte[] src, int offset);@param;byte[] src;byte[] src;byte array containing 4 bytes to decode at offset;true
org.apache.lucene.geo.GeoEncodingUtils;double decodeLatitude(byte[] src, int offset);double decodeLongitude(byte[] src, int offset);@param;int offset;int offset;offset into src to decode from.;true
org.apache.lucene.geo.GeoEncodingUtils;double decodeLongitude(int encoded);double decodeLongitude(byte[] src, int offset);@return;;;decoded longitude value.;true
org.apache.lucene.document.DoubleRange; DoubleRange(String name, double[] min, double[] max);Query newIntersectsQuery(String field, double[] min, double[] max);@param;String name;String field;field name. must not be null.;false
org.apache.lucene.document.DoubleRange; DoubleRange(String name, double[] min, double[] max);Query newContainsQuery(String field, double[] min, double[] max);@param;String name;String field;field name. must not be null.;false
org.apache.lucene.document.DoubleRange; DoubleRange(String name, double[] min, double[] max);Query newWithinQuery(String field, double[] min, double[] max);@param;String name;String field;field name. must not be null.;false
org.apache.lucene.document.DoubleRange; DoubleRange(String name, double[] min, double[] max);Query newCrossesQuery(String field, double[] min, double[] max);@param;String name;String field;field name. must not be null.;false
org.apache.lucene.document.DoubleRange;void setRangeValues(double[] min, double[] max);Query newIntersectsQuery(String field, double[] min, double[] max);@param;double[] min;double[] min;array of min values. (accepts Double.NEGATIVE_INFINITY);true
org.apache.lucene.document.DoubleRange;void setRangeValues(double[] min, double[] max);Query newIntersectsQuery(String field, double[] min, double[] max);@param;double[] max;double[] max;array of max values. (accepts Double.POSITIVE_INFINITY);true
org.apache.lucene.document.DoubleRange;double getMin(int dimension);double getMax(int dimension);@param;int dimension;int dimension;the dimension, always positive;true
org.apache.lucene.document.DoubleRange;Query newIntersectsQuery(String field, double[] min, double[] max);Query newContainsQuery(String field, double[] min, double[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.DoubleRange;Query newIntersectsQuery(String field, double[] min, double[] max);Query newContainsQuery(String field, double[] min, double[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.DoubleRange;Query newIntersectsQuery(String field, double[] min, double[] max);Query newWithinQuery(String field, double[] min, double[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.DoubleRange;Query newIntersectsQuery(String field, double[] min, double[] max);Query newWithinQuery(String field, double[] min, double[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.DoubleRange;Query newIntersectsQuery(String field, double[] min, double[] max);Query newCrossesQuery(String field, double[] min, double[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.DoubleRange;Query newIntersectsQuery(String field, double[] min, double[] max);Query newCrossesQuery(String field, double[] min, double[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.DoubleRange;Query newContainsQuery(String field, double[] min, double[] max);Query newWithinQuery(String field, double[] min, double[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.DoubleRange;Query newContainsQuery(String field, double[] min, double[] max);Query newWithinQuery(String field, double[] min, double[] max);@param;double[] min;double[] min;array of min values. (accepts Double.MIN_VALUE);true
org.apache.lucene.document.DoubleRange;Query newContainsQuery(String field, double[] min, double[] max);Query newWithinQuery(String field, double[] min, double[] max);@param;double[] max;double[] max;array of max values. (accepts Double.MAX_VALUE);true
org.apache.lucene.document.DoubleRange;Query newContainsQuery(String field, double[] min, double[] max);Query newWithinQuery(String field, double[] min, double[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.DoubleRange;Query newContainsQuery(String field, double[] min, double[] max);Query newCrossesQuery(String field, double[] min, double[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.DoubleRange;Query newContainsQuery(String field, double[] min, double[] max);Query newCrossesQuery(String field, double[] min, double[] max);@param;double[] min;double[] min;array of min values. (accepts Double.MIN_VALUE);true
org.apache.lucene.document.DoubleRange;Query newContainsQuery(String field, double[] min, double[] max);Query newCrossesQuery(String field, double[] min, double[] max);@param;double[] max;double[] max;array of max values. (accepts Double.MAX_VALUE);true
org.apache.lucene.document.DoubleRange;Query newContainsQuery(String field, double[] min, double[] max);Query newCrossesQuery(String field, double[] min, double[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.DoubleRange;Query newWithinQuery(String field, double[] min, double[] max);Query newCrossesQuery(String field, double[] min, double[] max);@return;;;query for matching ranges within the defined range;false
org.apache.lucene.document.DoubleRange;Query newWithinQuery(String field, double[] min, double[] max);Query newCrossesQuery(String field, double[] min, double[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.DoubleRange;Query newWithinQuery(String field, double[] min, double[] max);Query newCrossesQuery(String field, double[] min, double[] max);@param;double[] min;double[] min;array of min values. (accepts Double.MIN_VALUE);true
org.apache.lucene.document.DoubleRange;Query newWithinQuery(String field, double[] min, double[] max);Query newCrossesQuery(String field, double[] min, double[] max);@param;double[] max;double[] max;array of max values. (accepts Double.MAX_VALUE);true
org.apache.lucene.document.DoubleRange;Query newWithinQuery(String field, double[] min, double[] max);Query newCrossesQuery(String field, double[] min, double[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.BinaryPoint;Query newExactQuery(String field, byte[] value);Query newRangeQuery(String field, byte[] lowerValue, byte[] upperValue);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.BinaryPoint;Query newExactQuery(String field, byte[] value);Query newRangeQuery(String field, byte[][] lowerValue, byte[][] upperValue);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.BinaryPoint;Query newExactQuery(String field, byte[] value);Query newSetQuery(String field, byte[] values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.BinaryPoint;Query newRangeQuery(String field, byte[] lowerValue, byte[] upperValue);Query newRangeQuery(String field, byte[][] lowerValue, byte[][] upperValue);@return;;;a query matching documents within this range.;true
org.apache.lucene.document.BinaryPoint;Query newRangeQuery(String field, byte[] lowerValue, byte[] upperValue);Query newRangeQuery(String field, byte[][] lowerValue, byte[][] upperValue);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.BinaryPoint;Query newRangeQuery(String field, byte[] lowerValue, byte[] upperValue);Query newSetQuery(String field, byte[] values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.BinaryPoint;Query newRangeQuery(String field, byte[][] lowerValue, byte[][] upperValue);Query newSetQuery(String field, byte[] values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.DateTools;String dateToString(Date date, Resolution resolution);String timeToString(long time, Resolution resolution);@return;;;a string in format yyyyMMddHHmmssSSS or shorter, depending on resolution, using GMT as timezone;false
org.apache.lucene.document.DateTools;long stringToTime(String dateString);Date stringToDate(String dateString);@param;String dateString;String dateString;the date string to be converted;true
org.apache.lucene.document.DateTools;long stringToTime(String dateString);Date stringToDate(String dateString);@throws;;;if dateString is not in the expected format;true
org.apache.lucene.document.DateTools;Date round(Date date, Resolution resolution);long round(long time, Resolution resolution);@param;Resolution resolution;Resolution resolution;The desired resolution of the date to be returned;true
org.apache.lucene.document.FloatRange; FloatRange(String name, float[] min, float[] max);Query newIntersectsQuery(String field, float[] min, float[] max);@param;String name;String field;field name. must not be null.;false
org.apache.lucene.document.FloatRange; FloatRange(String name, float[] min, float[] max);Query newContainsQuery(String field, float[] min, float[] max);@param;String name;String field;field name. must not be null.;false
org.apache.lucene.document.FloatRange; FloatRange(String name, float[] min, float[] max);Query newWithinQuery(String field, float[] min, float[] max);@param;String name;String field;field name. must not be null.;false
org.apache.lucene.document.FloatRange; FloatRange(String name, float[] min, float[] max);Query newCrossesQuery(String field, float[] min, float[] max);@param;String name;String field;field name. must not be null.;false
org.apache.lucene.document.FloatRange;void setRangeValues(float[] min, float[] max);Query newIntersectsQuery(String field, float[] min, float[] max);@param;float[] min;float[] min;array of min values. (accepts Float.NEGATIVE_INFINITY);true
org.apache.lucene.document.FloatRange;void setRangeValues(float[] min, float[] max);Query newContainsQuery(String field, float[] min, float[] max);@param;float[] min;float[] min;array of min values. (accepts Float.NEGATIVE_INFINITY);true
org.apache.lucene.document.FloatRange;void setRangeValues(float[] min, float[] max);Query newContainsQuery(String field, float[] min, float[] max);@param;float[] max;float[] max;array of max values. (accepts Float.POSITIVE_INFINITY);true
org.apache.lucene.document.FloatRange;void setRangeValues(float[] min, float[] max);Query newWithinQuery(String field, float[] min, float[] max);@param;float[] min;float[] min;array of min values. (accepts Float.NEGATIVE_INFINITY);true
org.apache.lucene.document.FloatRange;void setRangeValues(float[] min, float[] max);Query newWithinQuery(String field, float[] min, float[] max);@param;float[] max;float[] max;array of max values. (accepts Float.POSITIVE_INFINITY);true
org.apache.lucene.document.FloatRange;void setRangeValues(float[] min, float[] max);Query newCrossesQuery(String field, float[] min, float[] max);@param;float[] min;float[] min;array of min values. (accepts Float.NEGATIVE_INFINITY);true
org.apache.lucene.document.FloatRange;void setRangeValues(float[] min, float[] max);Query newCrossesQuery(String field, float[] min, float[] max);@param;float[] max;float[] max;array of max values. (accepts Float.POSITIVE_INFINITY);true
org.apache.lucene.document.FloatRange;float getMin(int dimension);float getMax(int dimension);@param;int dimension;int dimension;the dimension, always positive;true
org.apache.lucene.document.FloatRange;Query newIntersectsQuery(String field, float[] min, float[] max);Query newContainsQuery(String field, float[] min, float[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.FloatRange;Query newIntersectsQuery(String field, float[] min, float[] max);Query newContainsQuery(String field, float[] min, float[] max);@param;float[] min;float[] min;array of min values. (accepts Float.NEGATIVE_INFINITY);true
org.apache.lucene.document.FloatRange;Query newIntersectsQuery(String field, float[] min, float[] max);Query newContainsQuery(String field, float[] min, float[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.FloatRange;Query newIntersectsQuery(String field, float[] min, float[] max);Query newWithinQuery(String field, float[] min, float[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.FloatRange;Query newIntersectsQuery(String field, float[] min, float[] max);Query newWithinQuery(String field, float[] min, float[] max);@param;float[] min;float[] min;array of min values. (accepts Float.NEGATIVE_INFINITY);true
org.apache.lucene.document.FloatRange;Query newIntersectsQuery(String field, float[] min, float[] max);Query newWithinQuery(String field, float[] min, float[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.FloatRange;Query newIntersectsQuery(String field, float[] min, float[] max);Query newCrossesQuery(String field, float[] min, float[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.FloatRange;Query newIntersectsQuery(String field, float[] min, float[] max);Query newCrossesQuery(String field, float[] min, float[] max);@param;float[] min;float[] min;array of min values. (accepts Float.NEGATIVE_INFINITY);true
org.apache.lucene.document.FloatRange;Query newIntersectsQuery(String field, float[] min, float[] max);Query newCrossesQuery(String field, float[] min, float[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.FloatRange;Query newContainsQuery(String field, float[] min, float[] max);Query newWithinQuery(String field, float[] min, float[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.FloatRange;Query newContainsQuery(String field, float[] min, float[] max);Query newWithinQuery(String field, float[] min, float[] max);@param;float[] min;float[] min;array of min values. (accepts Float.NEGATIVE_INFINITY);true
org.apache.lucene.document.FloatRange;Query newContainsQuery(String field, float[] min, float[] max);Query newWithinQuery(String field, float[] min, float[] max);@param;float[] max;float[] max;array of max values. (accepts Float.POSITIVE_INFINITY);true
org.apache.lucene.document.FloatRange;Query newContainsQuery(String field, float[] min, float[] max);Query newWithinQuery(String field, float[] min, float[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.FloatRange;Query newContainsQuery(String field, float[] min, float[] max);Query newCrossesQuery(String field, float[] min, float[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.FloatRange;Query newContainsQuery(String field, float[] min, float[] max);Query newCrossesQuery(String field, float[] min, float[] max);@param;float[] min;float[] min;array of min values. (accepts Float.NEGATIVE_INFINITY);true
org.apache.lucene.document.FloatRange;Query newContainsQuery(String field, float[] min, float[] max);Query newCrossesQuery(String field, float[] min, float[] max);@param;float[] max;float[] max;array of max values. (accepts Float.POSITIVE_INFINITY);true
org.apache.lucene.document.FloatRange;Query newContainsQuery(String field, float[] min, float[] max);Query newCrossesQuery(String field, float[] min, float[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.FloatRange;Query newWithinQuery(String field, float[] min, float[] max);Query newCrossesQuery(String field, float[] min, float[] max);@return;;;query for matching ranges within the defined range;false
org.apache.lucene.document.FloatRange;Query newWithinQuery(String field, float[] min, float[] max);Query newCrossesQuery(String field, float[] min, float[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.FloatRange;Query newWithinQuery(String field, float[] min, float[] max);Query newCrossesQuery(String field, float[] min, float[] max);@param;float[] min;float[] min;array of min values. (accepts Float.NEGATIVE_INFINITY);true
org.apache.lucene.document.FloatRange;Query newWithinQuery(String field, float[] min, float[] max);Query newCrossesQuery(String field, float[] min, float[] max);@param;float[] max;float[] max;array of max values. (accepts Float.POSITIVE_INFINITY);true
org.apache.lucene.document.FloatRange;Query newWithinQuery(String field, float[] min, float[] max);Query newCrossesQuery(String field, float[] min, float[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.IntPoint;Query newExactQuery(String field, int value);Query newRangeQuery(String field, int lowerValue, int upperValue);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.IntPoint;Query newExactQuery(String field, int value);Query newRangeQuery(String field, int lowerValue, int upperValue);@throws;;;if field is null.;true
org.apache.lucene.document.IntPoint;Query newExactQuery(String field, int value);Query newRangeQuery(String field, int[] lowerValue, int[] upperValue);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.IntPoint;Query newExactQuery(String field, int value);Query newSetQuery(String field, int values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.IntPoint;Query newExactQuery(String field, int value);Query newSetQuery(String field, Collection values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.IntPoint;Query newRangeQuery(String field, int lowerValue, int upperValue);Query newRangeQuery(String field, int[] lowerValue, int[] upperValue);@return;;;a query matching documents within this range.;true
org.apache.lucene.document.IntPoint;Query newRangeQuery(String field, int lowerValue, int upperValue);Query newRangeQuery(String field, int[] lowerValue, int[] upperValue);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.IntPoint;Query newRangeQuery(String field, int lowerValue, int upperValue);Query newSetQuery(String field, int values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.IntPoint;Query newRangeQuery(String field, int lowerValue, int upperValue);Query newSetQuery(String field, Collection values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.IntPoint;Query newRangeQuery(String field, int[] lowerValue, int[] upperValue);Query newSetQuery(String field, int values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.IntPoint;Query newRangeQuery(String field, int[] lowerValue, int[] upperValue);Query newSetQuery(String field, Collection values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.IntPoint;Query newSetQuery(String field, int values);Query newSetQuery(String field, Collection values);Whole;;;Create a query matching any of the specified 1D values.  This is the points equivalent of {@code TermsQuery}.  @param field name. must not be null.@param all values to match  ;false
org.apache.lucene.document.Document;BytesRef[] getBinaryValues(String name);IndexableField[] getFields(String name);@param;String name;String name;the name of the field;true
org.apache.lucene.document.Document;BytesRef[] getBinaryValues(String name);String[] getValues(String name);@param;String name;String name;the name of the field;true
org.apache.lucene.document.Document;IndexableField[] getFields(String name);String[] getValues(String name);@param;String name;String name;the name of the field;true
org.apache.lucene.document.FieldType;void setStored(boolean value);void setTokenized(boolean value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStored(boolean value);void setStoreTermVectors(boolean value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStored(boolean value);void setStoreTermVectorOffsets(boolean value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStored(boolean value);void setStoreTermVectorPositions(boolean value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStored(boolean value);void setStoreTermVectorPayloads(boolean value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStored(boolean value);void setOmitNorms(boolean value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStored(boolean value);void setIndexOptions(IndexOptions value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStored(boolean value);void setDocValuesType(DocValuesType type);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setTokenized(boolean value);void setStoreTermVectors(boolean value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setTokenized(boolean value);void setStoreTermVectorOffsets(boolean value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setTokenized(boolean value);void setStoreTermVectorPositions(boolean value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setTokenized(boolean value);void setStoreTermVectorPayloads(boolean value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setTokenized(boolean value);void setOmitNorms(boolean value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setTokenized(boolean value);void setIndexOptions(IndexOptions value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setTokenized(boolean value);void setDocValuesType(DocValuesType type);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStoreTermVectors(boolean value);void setStoreTermVectorOffsets(boolean value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStoreTermVectors(boolean value);void setStoreTermVectorPositions(boolean value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStoreTermVectors(boolean value);void setStoreTermVectorPayloads(boolean value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStoreTermVectors(boolean value);void setOmitNorms(boolean value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStoreTermVectors(boolean value);void setIndexOptions(IndexOptions value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStoreTermVectors(boolean value);void setDocValuesType(DocValuesType type);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStoreTermVectorOffsets(boolean value);void setStoreTermVectorPositions(boolean value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStoreTermVectorOffsets(boolean value);void setStoreTermVectorPayloads(boolean value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStoreTermVectorOffsets(boolean value);void setOmitNorms(boolean value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStoreTermVectorOffsets(boolean value);void setIndexOptions(IndexOptions value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStoreTermVectorOffsets(boolean value);void setDocValuesType(DocValuesType type);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStoreTermVectorPositions(boolean value);void setStoreTermVectorPayloads(boolean value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStoreTermVectorPositions(boolean value);void setOmitNorms(boolean value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStoreTermVectorPositions(boolean value);void setIndexOptions(IndexOptions value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStoreTermVectorPositions(boolean value);void setDocValuesType(DocValuesType type);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStoreTermVectorPayloads(boolean value);void setOmitNorms(boolean value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStoreTermVectorPayloads(boolean value);void setIndexOptions(IndexOptions value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setStoreTermVectorPayloads(boolean value);void setDocValuesType(DocValuesType type);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setOmitNorms(boolean value);void setIndexOptions(IndexOptions value);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setOmitNorms(boolean value);void setDocValuesType(DocValuesType type);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.FieldType;void setIndexOptions(IndexOptions value);void setDocValuesType(DocValuesType type);@throws;;;if this FieldType is frozen against future modifications.;true
org.apache.lucene.document.LongRange; LongRange(String name, long[] min, long[] max);Query newIntersectsQuery(String field, long[] min, long[] max);@param;String name;String field;field name. must not be null.;false
org.apache.lucene.document.LongRange; LongRange(String name, long[] min, long[] max);Query newContainsQuery(String field, long[] min, long[] max);@param;String name;String field;field name. must not be null.;false
org.apache.lucene.document.LongRange; LongRange(String name, long[] min, long[] max);Query newWithinQuery(String field, long[] min, long[] max);@param;String name;String field;field name. must not be null.;false
org.apache.lucene.document.LongRange; LongRange(String name, long[] min, long[] max);Query newCrossesQuery(String field, long[] min, long[] max);@param;String name;String field;field name. must not be null.;false
org.apache.lucene.document.LongRange;void setRangeValues(long[] min, long[] max);Query newIntersectsQuery(String field, long[] min, long[] max);@param;long[] min;long[] min;array of min values. (accepts Long.MIN_VALUE);true
org.apache.lucene.document.LongRange;void setRangeValues(long[] min, long[] max);Query newIntersectsQuery(String field, long[] min, long[] max);@param;long[] max;long[] max;array of max values. (accepts Long.MAX_VALUE);true
org.apache.lucene.document.LongRange;void setRangeValues(long[] min, long[] max);Query newContainsQuery(String field, long[] min, long[] max);@param;long[] min;long[] min;array of min values. (accepts Long.MIN_VALUE);true
org.apache.lucene.document.LongRange;void setRangeValues(long[] min, long[] max);Query newContainsQuery(String field, long[] min, long[] max);@param;long[] max;long[] max;array of max values. (accepts Long.MAX_VALUE);true
org.apache.lucene.document.LongRange;void setRangeValues(long[] min, long[] max);Query newWithinQuery(String field, long[] min, long[] max);@param;long[] min;long[] min;array of min values. (accepts Long.MIN_VALUE);true
org.apache.lucene.document.LongRange;void setRangeValues(long[] min, long[] max);Query newWithinQuery(String field, long[] min, long[] max);@param;long[] max;long[] max;array of max values. (accepts Long.MAX_VALUE);true
org.apache.lucene.document.LongRange;void setRangeValues(long[] min, long[] max);Query newCrossesQuery(String field, long[] min, long[] max);@param;long[] min;long[] min;array of min values. (accepts Long.MIN_VALUE);true
org.apache.lucene.document.LongRange;void setRangeValues(long[] min, long[] max);Query newCrossesQuery(String field, long[] min, long[] max);@param;long[] max;long[] max;array of max values. (accepts Long.MAX_VALUE);true
org.apache.lucene.document.LongRange;long getMin(int dimension);long getMax(int dimension);@param;int dimension;int dimension;the dimension, always positive;true
org.apache.lucene.document.LongRange;Query newIntersectsQuery(String field, long[] min, long[] max);Query newContainsQuery(String field, long[] min, long[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.LongRange;Query newIntersectsQuery(String field, long[] min, long[] max);Query newContainsQuery(String field, long[] min, long[] max);@param;long[] min;long[] min;array of min values. (accepts Long.MIN_VALUE);true
org.apache.lucene.document.LongRange;Query newIntersectsQuery(String field, long[] min, long[] max);Query newContainsQuery(String field, long[] min, long[] max);@param;long[] max;long[] max;array of max values. (accepts Long.MAX_VALUE);true
org.apache.lucene.document.LongRange;Query newIntersectsQuery(String field, long[] min, long[] max);Query newContainsQuery(String field, long[] min, long[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.LongRange;Query newIntersectsQuery(String field, long[] min, long[] max);Query newWithinQuery(String field, long[] min, long[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.LongRange;Query newIntersectsQuery(String field, long[] min, long[] max);Query newWithinQuery(String field, long[] min, long[] max);@param;long[] min;long[] min;array of min values. (accepts Long.MIN_VALUE);true
org.apache.lucene.document.LongRange;Query newIntersectsQuery(String field, long[] min, long[] max);Query newWithinQuery(String field, long[] min, long[] max);@param;long[] max;long[] max;array of max values. (accepts Long.MAX_VALUE);true
org.apache.lucene.document.LongRange;Query newIntersectsQuery(String field, long[] min, long[] max);Query newWithinQuery(String field, long[] min, long[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.LongRange;Query newIntersectsQuery(String field, long[] min, long[] max);Query newCrossesQuery(String field, long[] min, long[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.LongRange;Query newIntersectsQuery(String field, long[] min, long[] max);Query newCrossesQuery(String field, long[] min, long[] max);@param;long[] min;long[] min;array of min values. (accepts Long.MIN_VALUE);true
org.apache.lucene.document.LongRange;Query newIntersectsQuery(String field, long[] min, long[] max);Query newCrossesQuery(String field, long[] min, long[] max);@param;long[] max;long[] max;array of max values. (accepts Long.MAX_VALUE);true
org.apache.lucene.document.LongRange;Query newIntersectsQuery(String field, long[] min, long[] max);Query newCrossesQuery(String field, long[] min, long[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.LongRange;Query newContainsQuery(String field, long[] min, long[] max);Query newWithinQuery(String field, long[] min, long[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.LongRange;Query newContainsQuery(String field, long[] min, long[] max);Query newWithinQuery(String field, long[] min, long[] max);@param;long[] min;long[] min;array of min values. (accepts Long.MIN_VALUE);true
org.apache.lucene.document.LongRange;Query newContainsQuery(String field, long[] min, long[] max);Query newWithinQuery(String field, long[] min, long[] max);@param;long[] max;long[] max;array of max values. (accepts Long.MAX_VALUE);true
org.apache.lucene.document.LongRange;Query newContainsQuery(String field, long[] min, long[] max);Query newWithinQuery(String field, long[] min, long[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.LongRange;Query newContainsQuery(String field, long[] min, long[] max);Query newCrossesQuery(String field, long[] min, long[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.LongRange;Query newContainsQuery(String field, long[] min, long[] max);Query newCrossesQuery(String field, long[] min, long[] max);@param;long[] min;long[] min;array of min values. (accepts Long.MIN_VALUE);true
org.apache.lucene.document.LongRange;Query newContainsQuery(String field, long[] min, long[] max);Query newCrossesQuery(String field, long[] min, long[] max);@param;long[] max;long[] max;array of max values. (accepts Long.MAX_VALUE);true
org.apache.lucene.document.LongRange;Query newContainsQuery(String field, long[] min, long[] max);Query newCrossesQuery(String field, long[] min, long[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.LongRange;Query newWithinQuery(String field, long[] min, long[] max);Query newCrossesQuery(String field, long[] min, long[] max);@return;;;query for matching ranges within the defined range;false
org.apache.lucene.document.LongRange;Query newWithinQuery(String field, long[] min, long[] max);Query newCrossesQuery(String field, long[] min, long[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.LongRange;Query newWithinQuery(String field, long[] min, long[] max);Query newCrossesQuery(String field, long[] min, long[] max);@param;long[] min;long[] min;array of min values. (accepts Long.MIN_VALUE);true
org.apache.lucene.document.LongRange;Query newWithinQuery(String field, long[] min, long[] max);Query newCrossesQuery(String field, long[] min, long[] max);@param;long[] max;long[] max;array of max values. (accepts Long.MAX_VALUE);true
org.apache.lucene.document.LongRange;Query newWithinQuery(String field, long[] min, long[] max);Query newCrossesQuery(String field, long[] min, long[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.TextField; TextField(String name, Reader reader); TextField(String name, String value, Store store);@param;String name;String name;field name;true
org.apache.lucene.document.TextField; TextField(String name, Reader reader); TextField(String name, TokenStream stream);@param;String name;String name;field name;true
org.apache.lucene.document.TextField; TextField(String name, String value, Store store); TextField(String name, TokenStream stream);@param;String name;String name;field name;true
org.apache.lucene.document.LongPoint;Query newExactQuery(String field, long value);Query newRangeQuery(String field, long lowerValue, long upperValue);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.LongPoint;Query newExactQuery(String field, long value);Query newRangeQuery(String field, long lowerValue, long upperValue);@throws;;;if field is null.;true
org.apache.lucene.document.LongPoint;Query newExactQuery(String field, long value);Query newRangeQuery(String field, long[] lowerValue, long[] upperValue);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.LongPoint;Query newExactQuery(String field, long value);Query newSetQuery(String field, long values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.LongPoint;Query newExactQuery(String field, long value);Query newSetQuery(String field, Collection values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.LongPoint;Query newRangeQuery(String field, long lowerValue, long upperValue);Query newRangeQuery(String field, long[] lowerValue, long[] upperValue);@return;;;a query matching documents within this range.;true
org.apache.lucene.document.LongPoint;Query newRangeQuery(String field, long lowerValue, long upperValue);Query newRangeQuery(String field, long[] lowerValue, long[] upperValue);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.LongPoint;Query newRangeQuery(String field, long lowerValue, long upperValue);Query newSetQuery(String field, long values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.LongPoint;Query newRangeQuery(String field, long lowerValue, long upperValue);Query newSetQuery(String field, Collection values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.LongPoint;Query newRangeQuery(String field, long[] lowerValue, long[] upperValue);Query newSetQuery(String field, long values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.LongPoint;Query newRangeQuery(String field, long[] lowerValue, long[] upperValue);Query newSetQuery(String field, Collection values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.LongPoint;Query newSetQuery(String field, long values);Query newSetQuery(String field, Collection values);Whole;;;Create a query matching any of the specified 1D values.  This is the points equivalent of {@code TermsQuery}.  @param field name. must not be null.@param all values to match  ;false
org.apache.lucene.document.IntRange; IntRange(String name, int[] min, int[] max);Query newIntersectsQuery(String field, int[] min, int[] max);@param;String name;String field;field name. must not be null.;false
org.apache.lucene.document.IntRange; IntRange(String name, int[] min, int[] max);Query newContainsQuery(String field, int[] min, int[] max);@param;String name;String field;field name. must not be null.;false
org.apache.lucene.document.IntRange; IntRange(String name, int[] min, int[] max);Query newWithinQuery(String field, int[] min, int[] max);@param;String name;String field;field name. must not be null.;false
org.apache.lucene.document.IntRange; IntRange(String name, int[] min, int[] max);Query newCrossesQuery(String field, int[] min, int[] max);@param;String name;String field;field name. must not be null.;false
org.apache.lucene.document.IntRange;int getMin(int dimension);int getMax(int dimension);@param;int dimension;int dimension;the dimension, always positive;true
org.apache.lucene.document.IntRange;Query newIntersectsQuery(String field, int[] min, int[] max);Query newContainsQuery(String field, int[] min, int[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.IntRange;Query newIntersectsQuery(String field, int[] min, int[] max);Query newContainsQuery(String field, int[] min, int[] max);@param;int[] min;int[] min;array of min values. (accepts Integer.MIN_VALUE);true
org.apache.lucene.document.IntRange;Query newIntersectsQuery(String field, int[] min, int[] max);Query newContainsQuery(String field, int[] min, int[] max);@param;int[] max;int[] max;array of max values. (accepts Integer.MAX_VALUE);true
org.apache.lucene.document.IntRange;Query newIntersectsQuery(String field, int[] min, int[] max);Query newContainsQuery(String field, int[] min, int[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.IntRange;Query newIntersectsQuery(String field, int[] min, int[] max);Query newWithinQuery(String field, int[] min, int[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.IntRange;Query newIntersectsQuery(String field, int[] min, int[] max);Query newWithinQuery(String field, int[] min, int[] max);@param;int[] min;int[] min;array of min values. (accepts Integer.MIN_VALUE);true
org.apache.lucene.document.IntRange;Query newIntersectsQuery(String field, int[] min, int[] max);Query newWithinQuery(String field, int[] min, int[] max);@param;int[] max;int[] max;array of max values. (accepts Integer.MAX_VALUE);true
org.apache.lucene.document.IntRange;Query newIntersectsQuery(String field, int[] min, int[] max);Query newWithinQuery(String field, int[] min, int[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.IntRange;Query newIntersectsQuery(String field, int[] min, int[] max);Query newCrossesQuery(String field, int[] min, int[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.IntRange;Query newIntersectsQuery(String field, int[] min, int[] max);Query newCrossesQuery(String field, int[] min, int[] max);@param;int[] min;int[] min;array of min values. (accepts Integer.MIN_VALUE);true
org.apache.lucene.document.IntRange;Query newIntersectsQuery(String field, int[] min, int[] max);Query newCrossesQuery(String field, int[] min, int[] max);@param;int[] max;int[] max;array of max values. (accepts Integer.MAX_VALUE);true
org.apache.lucene.document.IntRange;Query newIntersectsQuery(String field, int[] min, int[] max);Query newCrossesQuery(String field, int[] min, int[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.IntRange;Query newContainsQuery(String field, int[] min, int[] max);Query newWithinQuery(String field, int[] min, int[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.IntRange;Query newContainsQuery(String field, int[] min, int[] max);Query newWithinQuery(String field, int[] min, int[] max);@param;int[] min;int[] min;array of min values. (accepts Integer.MIN_VALUE);true
org.apache.lucene.document.IntRange;Query newContainsQuery(String field, int[] min, int[] max);Query newWithinQuery(String field, int[] min, int[] max);@param;int[] max;int[] max;array of max values. (accepts Integer.MAX_VALUE);true
org.apache.lucene.document.IntRange;Query newContainsQuery(String field, int[] min, int[] max);Query newWithinQuery(String field, int[] min, int[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.IntRange;Query newContainsQuery(String field, int[] min, int[] max);Query newCrossesQuery(String field, int[] min, int[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.IntRange;Query newContainsQuery(String field, int[] min, int[] max);Query newCrossesQuery(String field, int[] min, int[] max);@param;int[] min;int[] min;array of min values. (accepts Integer.MIN_VALUE);true
org.apache.lucene.document.IntRange;Query newContainsQuery(String field, int[] min, int[] max);Query newCrossesQuery(String field, int[] min, int[] max);@param;int[] max;int[] max;array of max values. (accepts Integer.MAX_VALUE);true
org.apache.lucene.document.IntRange;Query newContainsQuery(String field, int[] min, int[] max);Query newCrossesQuery(String field, int[] min, int[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.IntRange;Query newWithinQuery(String field, int[] min, int[] max);Query newCrossesQuery(String field, int[] min, int[] max);@return;;;query for matching ranges within the defined range;false
org.apache.lucene.document.IntRange;Query newWithinQuery(String field, int[] min, int[] max);Query newCrossesQuery(String field, int[] min, int[] max);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.IntRange;Query newWithinQuery(String field, int[] min, int[] max);Query newCrossesQuery(String field, int[] min, int[] max);@param;int[] min;int[] min;array of min values. (accepts Integer.MIN_VALUE);true
org.apache.lucene.document.IntRange;Query newWithinQuery(String field, int[] min, int[] max);Query newCrossesQuery(String field, int[] min, int[] max);@param;int[] max;int[] max;array of max values. (accepts Integer.MAX_VALUE);true
org.apache.lucene.document.IntRange;Query newWithinQuery(String field, int[] min, int[] max);Query newCrossesQuery(String field, int[] min, int[] max);@throws;;;if field is null, min or max is invalid;true
org.apache.lucene.document.FloatPoint;Query newExactQuery(String field, float value);Query newRangeQuery(String field, float lowerValue, float upperValue);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.FloatPoint;Query newExactQuery(String field, float value);Query newRangeQuery(String field, float lowerValue, float upperValue);@throws;;;if field is null.;true
org.apache.lucene.document.FloatPoint;Query newExactQuery(String field, float value);Query newRangeQuery(String field, float[] lowerValue, float[] upperValue);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.FloatPoint;Query newExactQuery(String field, float value);Query newSetQuery(String field, float values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.FloatPoint;Query newExactQuery(String field, float value);Query newSetQuery(String field, Collection values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.FloatPoint;Query newRangeQuery(String field, float lowerValue, float upperValue);Query newRangeQuery(String field, float[] lowerValue, float[] upperValue);@return;;;a query matching documents within this range.;true
org.apache.lucene.document.FloatPoint;Query newRangeQuery(String field, float lowerValue, float upperValue);Query newRangeQuery(String field, float[] lowerValue, float[] upperValue);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.FloatPoint;Query newRangeQuery(String field, float lowerValue, float upperValue);Query newSetQuery(String field, float values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.FloatPoint;Query newRangeQuery(String field, float lowerValue, float upperValue);Query newSetQuery(String field, Collection values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.FloatPoint;Query newRangeQuery(String field, float[] lowerValue, float[] upperValue);Query newSetQuery(String field, float values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.FloatPoint;Query newRangeQuery(String field, float[] lowerValue, float[] upperValue);Query newSetQuery(String field, Collection values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.FloatPoint;Query newSetQuery(String field, float values);Query newSetQuery(String field, Collection values);Whole;;;Create a query matching any of the specified 1D values.  This is the points equivalent of {@code TermsQuery}.  @param field name. must not be null.@param all values to match  ;false
org.apache.lucene.document.StringField; StringField(String name, String value, Store stored); StringField(String name, BytesRef value, Store stored);@param;String name;String name;field name;true
org.apache.lucene.document.StringField; StringField(String name, String value, Store stored); StringField(String name, BytesRef value, Store stored);@param;Store stored;Store stored;Store.YES if the content should also be stored;true
org.apache.lucene.document.StringField; StringField(String name, String value, Store stored); StringField(String name, BytesRef value, Store stored);@throws;;;if the field name or value is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, FieldType type); StoredField(String name, BytesRef bytes, FieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, FieldType type); StoredField(String name, BytesRef bytes, FieldType type);@param;FieldType type;FieldType type;custom FieldType for this field;true
org.apache.lucene.document.StoredField; StoredField(String name, FieldType type); StoredField(String name, BytesRef bytes, FieldType type);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, FieldType type); StoredField(String name, byte[] value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, FieldType type); StoredField(String name, byte[] value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, FieldType type); StoredField(String name, byte[] value, int offset, int length);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, FieldType type); StoredField(String name, byte[] value, int offset, int length);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, FieldType type); StoredField(String name, BytesRef value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, FieldType type); StoredField(String name, BytesRef value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, FieldType type); StoredField(String name, String value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, FieldType type); StoredField(String name, String value, FieldType type);Free text;;;Expert: allows you to customize the {@link FieldType}. ;true
org.apache.lucene.document.StoredField; StoredField(String name, FieldType type); StoredField(String name, String value, FieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, FieldType type); StoredField(String name, String value, FieldType type);@param;FieldType type;FieldType type;custom FieldType for this field;true
org.apache.lucene.document.StoredField; StoredField(String name, FieldType type); StoredField(String name, int value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, FieldType type); StoredField(String name, int value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, FieldType type); StoredField(String name, float value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, FieldType type); StoredField(String name, float value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, FieldType type); StoredField(String name, long value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, FieldType type); StoredField(String name, long value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, FieldType type); StoredField(String name, double value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, FieldType type); StoredField(String name, double value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef bytes, FieldType type); StoredField(String name, byte[] value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef bytes, FieldType type); StoredField(String name, byte[] value);@param;BytesRef bytes;byte[] value;byte array pointing to binary content (not copied);true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef bytes, FieldType type); StoredField(String name, byte[] value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef bytes, FieldType type); StoredField(String name, byte[] value, int offset, int length);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef bytes, FieldType type); StoredField(String name, byte[] value, int offset, int length);@param;BytesRef bytes;byte[] value;byte array pointing to binary content (not copied);true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef bytes, FieldType type); StoredField(String name, byte[] value, int offset, int length);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef bytes, FieldType type); StoredField(String name, BytesRef value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef bytes, FieldType type); StoredField(String name, BytesRef value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef bytes, FieldType type); StoredField(String name, String value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef bytes, FieldType type); StoredField(String name, String value, FieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef bytes, FieldType type); StoredField(String name, String value, FieldType type);@param;FieldType type;FieldType type;custom FieldType for this field;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef bytes, FieldType type); StoredField(String name, int value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef bytes, FieldType type); StoredField(String name, int value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef bytes, FieldType type); StoredField(String name, float value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef bytes, FieldType type); StoredField(String name, float value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef bytes, FieldType type); StoredField(String name, long value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef bytes, FieldType type); StoredField(String name, long value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef bytes, FieldType type); StoredField(String name, double value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef bytes, FieldType type); StoredField(String name, double value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value); StoredField(String name, byte[] value, int offset, int length);Free text;;;Create a stored-only field with the given binary value. <p>NOTE: the provided byte[] is not copied so be sure not to change it until you're done with this field. ;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value); StoredField(String name, byte[] value, int offset, int length);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value); StoredField(String name, byte[] value, int offset, int length);@param;byte[] value;byte[] value;byte array pointing to binary content (not copied);true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value); StoredField(String name, byte[] value, int offset, int length);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value); StoredField(String name, BytesRef value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value); StoredField(String name, BytesRef value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value); StoredField(String name, String value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value); StoredField(String name, String value, FieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value); StoredField(String name, int value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value); StoredField(String name, int value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value); StoredField(String name, float value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value); StoredField(String name, float value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value); StoredField(String name, long value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value); StoredField(String name, long value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value); StoredField(String name, double value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value); StoredField(String name, double value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value, int offset, int length); StoredField(String name, BytesRef value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value, int offset, int length); StoredField(String name, BytesRef value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value, int offset, int length); StoredField(String name, String value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value, int offset, int length); StoredField(String name, String value, FieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value, int offset, int length); StoredField(String name, int value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value, int offset, int length); StoredField(String name, int value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value, int offset, int length); StoredField(String name, float value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value, int offset, int length); StoredField(String name, float value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value, int offset, int length); StoredField(String name, long value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value, int offset, int length); StoredField(String name, long value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value, int offset, int length); StoredField(String name, double value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, byte[] value, int offset, int length); StoredField(String name, double value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef value); StoredField(String name, String value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef value); StoredField(String name, String value, FieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef value); StoredField(String name, int value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef value); StoredField(String name, int value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef value); StoredField(String name, float value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef value); StoredField(String name, float value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef value); StoredField(String name, long value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef value); StoredField(String name, long value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef value); StoredField(String name, double value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, BytesRef value); StoredField(String name, double value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, String value); StoredField(String name, String value, FieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, String value); StoredField(String name, String value, FieldType type);@param;String value;String value;string value;true
org.apache.lucene.document.StoredField; StoredField(String name, String value); StoredField(String name, String value, FieldType type);@throws;;;if the field name or value is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, String value); StoredField(String name, int value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, String value); StoredField(String name, float value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, String value); StoredField(String name, long value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, String value); StoredField(String name, double value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, String value, FieldType type); StoredField(String name, int value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, String value, FieldType type); StoredField(String name, float value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, String value, FieldType type); StoredField(String name, long value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, String value, FieldType type); StoredField(String name, double value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, int value); StoredField(String name, float value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, int value); StoredField(String name, float value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, int value); StoredField(String name, long value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, int value); StoredField(String name, long value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, int value); StoredField(String name, double value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, int value); StoredField(String name, double value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, float value); StoredField(String name, long value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, float value); StoredField(String name, long value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, float value); StoredField(String name, double value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, float value); StoredField(String name, double value);@throws;;;if the field name is null.;true
org.apache.lucene.document.StoredField; StoredField(String name, long value); StoredField(String name, double value);@param;String name;String name;field name;true
org.apache.lucene.document.StoredField; StoredField(String name, long value); StoredField(String name, double value);@throws;;;if the field name is null.;true
org.apache.lucene.document.Field; Field(String name, IndexableFieldType type); Field(String name, Reader reader, IndexableFieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.Field; Field(String name, IndexableFieldType type); Field(String name, Reader reader, IndexableFieldType type);@param;IndexableFieldType type;IndexableFieldType type;field type;true
org.apache.lucene.document.Field; Field(String name, IndexableFieldType type); Field(String name, TokenStream tokenStream, IndexableFieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.Field; Field(String name, IndexableFieldType type); Field(String name, TokenStream tokenStream, IndexableFieldType type);@param;IndexableFieldType type;IndexableFieldType type;field type;true
org.apache.lucene.document.Field; Field(String name, IndexableFieldType type); Field(String name, byte[] value, IndexableFieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.Field; Field(String name, IndexableFieldType type); Field(String name, byte[] value, IndexableFieldType type);@param;IndexableFieldType type;IndexableFieldType type;field type;true
org.apache.lucene.document.Field; Field(String name, IndexableFieldType type); Field(String name, byte[] value, int offset, int length, IndexableFieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.Field; Field(String name, IndexableFieldType type); Field(String name, byte[] value, int offset, int length, IndexableFieldType type);@param;IndexableFieldType type;IndexableFieldType type;field type;true
org.apache.lucene.document.Field; Field(String name, IndexableFieldType type); Field(String name, BytesRef bytes, IndexableFieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.Field; Field(String name, IndexableFieldType type); Field(String name, BytesRef bytes, IndexableFieldType type);@param;IndexableFieldType type;IndexableFieldType type;field type;true
org.apache.lucene.document.Field; Field(String name, IndexableFieldType type); Field(String name, String value, IndexableFieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.Field; Field(String name, IndexableFieldType type); Field(String name, String value, IndexableFieldType type);@param;IndexableFieldType type;IndexableFieldType type;field type;true
org.apache.lucene.document.Field; Field(String name, Reader reader, IndexableFieldType type); Field(String name, TokenStream tokenStream, IndexableFieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.Field; Field(String name, Reader reader, IndexableFieldType type); Field(String name, TokenStream tokenStream, IndexableFieldType type);@param;IndexableFieldType type;IndexableFieldType type;field type;true
org.apache.lucene.document.Field; Field(String name, Reader reader, IndexableFieldType type); Field(String name, byte[] value, IndexableFieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.Field; Field(String name, Reader reader, IndexableFieldType type); Field(String name, byte[] value, IndexableFieldType type);@param;IndexableFieldType type;IndexableFieldType type;field type;true
org.apache.lucene.document.Field; Field(String name, Reader reader, IndexableFieldType type); Field(String name, byte[] value, int offset, int length, IndexableFieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.Field; Field(String name, Reader reader, IndexableFieldType type); Field(String name, byte[] value, int offset, int length, IndexableFieldType type);@param;IndexableFieldType type;IndexableFieldType type;field type;true
org.apache.lucene.document.Field; Field(String name, Reader reader, IndexableFieldType type); Field(String name, BytesRef bytes, IndexableFieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.Field; Field(String name, Reader reader, IndexableFieldType type); Field(String name, BytesRef bytes, IndexableFieldType type);@param;IndexableFieldType type;IndexableFieldType type;field type;true
org.apache.lucene.document.Field; Field(String name, Reader reader, IndexableFieldType type); Field(String name, String value, IndexableFieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.Field; Field(String name, Reader reader, IndexableFieldType type); Field(String name, String value, IndexableFieldType type);@param;IndexableFieldType type;IndexableFieldType type;field type;true
org.apache.lucene.document.Field; Field(String name, TokenStream tokenStream, IndexableFieldType type); Field(String name, byte[] value, IndexableFieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.Field; Field(String name, TokenStream tokenStream, IndexableFieldType type); Field(String name, byte[] value, IndexableFieldType type);@param;IndexableFieldType type;IndexableFieldType type;field type;true
org.apache.lucene.document.Field; Field(String name, TokenStream tokenStream, IndexableFieldType type); Field(String name, byte[] value, int offset, int length, IndexableFieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.Field; Field(String name, TokenStream tokenStream, IndexableFieldType type); Field(String name, byte[] value, int offset, int length, IndexableFieldType type);@param;IndexableFieldType type;IndexableFieldType type;field type;true
org.apache.lucene.document.Field; Field(String name, TokenStream tokenStream, IndexableFieldType type); Field(String name, BytesRef bytes, IndexableFieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.Field; Field(String name, TokenStream tokenStream, IndexableFieldType type); Field(String name, BytesRef bytes, IndexableFieldType type);@param;IndexableFieldType type;IndexableFieldType type;field type;true
org.apache.lucene.document.Field; Field(String name, TokenStream tokenStream, IndexableFieldType type); Field(String name, String value, IndexableFieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.Field; Field(String name, TokenStream tokenStream, IndexableFieldType type); Field(String name, String value, IndexableFieldType type);@param;IndexableFieldType type;IndexableFieldType type;field type;true
org.apache.lucene.document.Field; Field(String name, byte[] value, IndexableFieldType type); Field(String name, byte[] value, int offset, int length, IndexableFieldType type);Free text;;;Create field with binary value. <p>NOTE: the provided byte[] is not copied so be sure not to change it until you're done with this field. ;true
org.apache.lucene.document.Field; Field(String name, byte[] value, IndexableFieldType type); Field(String name, byte[] value, int offset, int length, IndexableFieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.Field; Field(String name, byte[] value, IndexableFieldType type); Field(String name, byte[] value, int offset, int length, IndexableFieldType type);@param;byte[] value;byte[] value;byte array pointing to binary content (not copied);true
org.apache.lucene.document.Field; Field(String name, byte[] value, IndexableFieldType type); Field(String name, byte[] value, int offset, int length, IndexableFieldType type);@param;IndexableFieldType type;IndexableFieldType type;field type;true
org.apache.lucene.document.Field; Field(String name, byte[] value, IndexableFieldType type); Field(String name, byte[] value, int offset, int length, IndexableFieldType type);@throws;;;if the field name is null, or the field's type is indexed();true
org.apache.lucene.document.Field; Field(String name, byte[] value, IndexableFieldType type); Field(String name, byte[] value, int offset, int length, IndexableFieldType type);@throws;;;if the type is null;true
org.apache.lucene.document.Field; Field(String name, byte[] value, IndexableFieldType type); Field(String name, BytesRef bytes, IndexableFieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.Field; Field(String name, byte[] value, IndexableFieldType type); Field(String name, BytesRef bytes, IndexableFieldType type);@param;IndexableFieldType type;IndexableFieldType type;field type;true
org.apache.lucene.document.Field; Field(String name, byte[] value, IndexableFieldType type); Field(String name, BytesRef bytes, IndexableFieldType type);@throws;;;if the field name is null, or the field's type is indexed();true
org.apache.lucene.document.Field; Field(String name, byte[] value, IndexableFieldType type); Field(String name, BytesRef bytes, IndexableFieldType type);@throws;;;if the type is null;true
org.apache.lucene.document.Field; Field(String name, byte[] value, IndexableFieldType type); Field(String name, String value, IndexableFieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.Field; Field(String name, byte[] value, IndexableFieldType type); Field(String name, String value, IndexableFieldType type);@param;IndexableFieldType type;IndexableFieldType type;field type;true
org.apache.lucene.document.Field; Field(String name, byte[] value, IndexableFieldType type); Field(String name, String value, IndexableFieldType type);@throws;;;if the type is null;true
org.apache.lucene.document.Field; Field(String name, byte[] value, int offset, int length, IndexableFieldType type); Field(String name, BytesRef bytes, IndexableFieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.Field; Field(String name, byte[] value, int offset, int length, IndexableFieldType type); Field(String name, BytesRef bytes, IndexableFieldType type);@param;IndexableFieldType type;IndexableFieldType type;field type;true
org.apache.lucene.document.Field; Field(String name, byte[] value, int offset, int length, IndexableFieldType type); Field(String name, BytesRef bytes, IndexableFieldType type);@throws;;;if the field name is null, or the field's type is indexed();true
org.apache.lucene.document.Field; Field(String name, byte[] value, int offset, int length, IndexableFieldType type); Field(String name, BytesRef bytes, IndexableFieldType type);@throws;;;if the type is null;true
org.apache.lucene.document.Field; Field(String name, byte[] value, int offset, int length, IndexableFieldType type); Field(String name, String value, IndexableFieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.Field; Field(String name, byte[] value, int offset, int length, IndexableFieldType type); Field(String name, String value, IndexableFieldType type);@param;IndexableFieldType type;IndexableFieldType type;field type;true
org.apache.lucene.document.Field; Field(String name, byte[] value, int offset, int length, IndexableFieldType type); Field(String name, String value, IndexableFieldType type);@throws;;;if the type is null;true
org.apache.lucene.document.Field; Field(String name, BytesRef bytes, IndexableFieldType type); Field(String name, String value, IndexableFieldType type);@param;String name;String name;field name;true
org.apache.lucene.document.Field; Field(String name, BytesRef bytes, IndexableFieldType type); Field(String name, String value, IndexableFieldType type);@param;IndexableFieldType type;IndexableFieldType type;field type;true
org.apache.lucene.document.Field; Field(String name, BytesRef bytes, IndexableFieldType type); Field(String name, String value, IndexableFieldType type);@throws;;;if the type is null;true
org.apache.lucene.document.Field;void setReaderValue(Reader value);void setBytesValue(byte[] value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setReaderValue(Reader value);void setByteValue(byte value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setReaderValue(Reader value);void setShortValue(short value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setReaderValue(Reader value);void setIntValue(int value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setReaderValue(Reader value);void setLongValue(long value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setReaderValue(Reader value);void setFloatValue(float value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setReaderValue(Reader value);void setDoubleValue(double value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setBytesValue(byte[] value);void setByteValue(byte value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setBytesValue(byte[] value);void setShortValue(short value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setBytesValue(byte[] value);void setIntValue(int value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setBytesValue(byte[] value);void setLongValue(long value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setBytesValue(byte[] value);void setFloatValue(float value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setBytesValue(byte[] value);void setDoubleValue(double value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setByteValue(byte value);void setShortValue(short value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setByteValue(byte value);void setIntValue(int value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setByteValue(byte value);void setLongValue(long value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setByteValue(byte value);void setFloatValue(float value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setByteValue(byte value);void setDoubleValue(double value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setShortValue(short value);void setIntValue(int value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setShortValue(short value);void setLongValue(long value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setShortValue(short value);void setFloatValue(float value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setShortValue(short value);void setDoubleValue(double value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setIntValue(int value);void setLongValue(long value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setIntValue(int value);void setFloatValue(float value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setIntValue(int value);void setDoubleValue(double value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setLongValue(long value);void setFloatValue(float value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setLongValue(long value);void setDoubleValue(double value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.Field;void setFloatValue(float value);void setDoubleValue(double value);Whole;;;Expert: change the value of this field. See {@link #setStringValue(String)}.    ;false
org.apache.lucene.document.DoublePoint;Query newExactQuery(String field, double value);Query newRangeQuery(String field, double lowerValue, double upperValue);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.DoublePoint;Query newExactQuery(String field, double value);Query newRangeQuery(String field, double lowerValue, double upperValue);@throws;;;if field is null.;true
org.apache.lucene.document.DoublePoint;Query newExactQuery(String field, double value);Query newRangeQuery(String field, double[] lowerValue, double[] upperValue);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.DoublePoint;Query newExactQuery(String field, double value);Query newSetQuery(String field, double values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.DoublePoint;Query newExactQuery(String field, double value);Query newSetQuery(String field, Collection values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.DoublePoint;Query newRangeQuery(String field, double lowerValue, double upperValue);Query newRangeQuery(String field, double[] lowerValue, double[] upperValue);@return;;;a query matching documents within this range.;true
org.apache.lucene.document.DoublePoint;Query newRangeQuery(String field, double lowerValue, double upperValue);Query newRangeQuery(String field, double[] lowerValue, double[] upperValue);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.DoublePoint;Query newRangeQuery(String field, double lowerValue, double upperValue);Query newSetQuery(String field, double values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.DoublePoint;Query newRangeQuery(String field, double lowerValue, double upperValue);Query newSetQuery(String field, Collection values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.DoublePoint;Query newRangeQuery(String field, double[] lowerValue, double[] upperValue);Query newSetQuery(String field, double values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.DoublePoint;Query newRangeQuery(String field, double[] lowerValue, double[] upperValue);Query newSetQuery(String field, Collection values);@param;String field;String field;field name. must not be null.;true
org.apache.lucene.document.DoublePoint;Query newSetQuery(String field, double values);Query newSetQuery(String field, Collection values);Whole;;;Create a query matching any of the specified 1D values.  This is the points equivalent of {@code TermsQuery}.  @param field name. must not be null.@param all values to match  ;false
org.apache.lucene.search.similarities.BM25Similarity;Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats);Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics[] termStats);@param;CollectionStatistics collectionStats;CollectionStatistics collectionStats;collection-level statistics;true
org.apache.lucene.search.similarities.SimilarityBase;float score(BasicStats stats, float freq, float docLen);void explain(List subExpls, BasicStats stats, int doc, float freq, float docLen);@param;BasicStats stats;BasicStats stats;the corpus level statistics.;true
org.apache.lucene.search.similarities.SimilarityBase;float score(BasicStats stats, float freq, float docLen);void explain(List subExpls, BasicStats stats, int doc, float freq, float docLen);@param;float freq;float freq;the term frequency.;true
org.apache.lucene.search.similarities.SimilarityBase;float score(BasicStats stats, float freq, float docLen);void explain(List subExpls, BasicStats stats, int doc, float freq, float docLen);@param;float docLen;float docLen;the document length.;true
org.apache.lucene.search.similarities.SimilarityBase;float score(BasicStats stats, float freq, float docLen);Explanation explain(BasicStats stats, int doc, Explanation freq, float docLen);@param;BasicStats stats;BasicStats stats;the corpus level statistics.;true
org.apache.lucene.search.similarities.SimilarityBase;float score(BasicStats stats, float freq, float docLen);Explanation explain(BasicStats stats, int doc, Explanation freq, float docLen);@param;float docLen;float docLen;the document length.;true
org.apache.lucene.search.similarities.SimilarityBase;void explain(List subExpls, BasicStats stats, int doc, float freq, float docLen);Explanation explain(BasicStats stats, int doc, Explanation freq, float docLen);@param;BasicStats stats;BasicStats stats;the corpus level statistics.;true
org.apache.lucene.search.similarities.SimilarityBase;void explain(List subExpls, BasicStats stats, int doc, float freq, float docLen);Explanation explain(BasicStats stats, int doc, Explanation freq, float docLen);@param;int doc;int doc;the document id.;true
org.apache.lucene.search.similarities.SimilarityBase;void explain(List subExpls, BasicStats stats, int doc, float freq, float docLen);Explanation explain(BasicStats stats, int doc, Explanation freq, float docLen);@param;float docLen;float docLen;the document length.;true
org.apache.lucene.search.similarities.AxiomaticF2EXP; AxiomaticF2EXP(float s, float k); AxiomaticF2EXP(float s);@param;float s;float s;hyperparam for the growth function;true
org.apache.lucene.search.similarities.Axiomatic; Axiomatic(float s, int queryLen, float k); Axiomatic(float s);@param;float s;float s;hyperparam for the growth function;true
org.apache.lucene.search.similarities.Axiomatic; Axiomatic(float s, int queryLen, float k); Axiomatic(float s, int queryLen);@param;float s;float s;hyperparam for the growth function;true
org.apache.lucene.search.similarities.Axiomatic; Axiomatic(float s, int queryLen, float k); Axiomatic(float s, int queryLen);@param;int queryLen;int queryLen;the query length;true
org.apache.lucene.search.similarities.Axiomatic; Axiomatic(float s); Axiomatic(float s, int queryLen);@param;float s;float s;hyperparam for the growth function;true
org.apache.lucene.search.similarities.AxiomaticF3EXP; AxiomaticF3EXP(float s, int queryLen, float k); AxiomaticF3EXP(float s, int queryLen);@param;float s;float s;hyperparam for the growth function;true
org.apache.lucene.search.similarities.AxiomaticF3EXP; AxiomaticF3EXP(float s, int queryLen, float k); AxiomaticF3EXP(float s, int queryLen);@param;int queryLen;int queryLen;the query length;true
org.apache.lucene.search.similarities.AxiomaticF1EXP; AxiomaticF1EXP(float s, float k); AxiomaticF1EXP(float s);@param;float s;float s;hyperparam for the growth function;true
org.apache.lucene.search.similarities.TFIDFSimilarity;Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats);Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics[] termStats);@param;CollectionStatistics collectionStats;CollectionStatistics collectionStats;collection-level statistics;true
org.apache.lucene.search.PhraseQuery; PhraseQuery(int slop, String field, String terms); PhraseQuery(int slop, String field, BytesRef terms);Whole;;;Create a phrase query which will match documents that contain the given list of terms at consecutive positions in {@code field}, and at a maximum edit distance of {@code slop}. For more complicated use-cases, use {@link PhraseQuery.Builder}. @see #getSlop()    ;false
org.apache.lucene.search.PhraseQuery; PhraseQuery(String field, String terms); PhraseQuery(String field, BytesRef terms);Whole;;;Create a phrase query which will match documents that contain the given list of terms at consecutive positions in {@code field}.    ;false
org.apache.lucene.search.Sort; Sort(SortField fields);void setSort(SortField fields);Whole;;; first SortField is checked first, but if it produces a  tie, then the second SortField is used to break the tie,  etc.  Finally, if there is still a tie after all SortFields  are checked, the internal Lucene docid is used to break it.    ;false
org.apache.lucene.search.WildcardQuery; WildcardQuery(Term term); WildcardQuery(Term term, int maxDeterminizedStates);Free text;;;Constructs a query for terms matching <code>term</code>. ;true
org.apache.lucene.search.RegexpQuery; RegexpQuery(Term term); RegexpQuery(Term term, int flags);@param;Term term;Term term;regular expression.;true
org.apache.lucene.search.RegexpQuery; RegexpQuery(Term term); RegexpQuery(Term term, int flags, int maxDeterminizedStates);@param;Term term;Term term;regular expression.;true
org.apache.lucene.search.RegexpQuery; RegexpQuery(Term term); RegexpQuery(Term term, int flags, AutomatonProvider provider, int maxDeterminizedStates);@param;Term term;Term term;regular expression.;true
org.apache.lucene.search.RegexpQuery; RegexpQuery(Term term, int flags); RegexpQuery(Term term, int flags, int maxDeterminizedStates);Free text;;;Constructs a query for terms matching <code>term</code>. ;true
org.apache.lucene.search.RegexpQuery; RegexpQuery(Term term, int flags); RegexpQuery(Term term, int flags, int maxDeterminizedStates);@param;Term term;Term term;regular expression.;true
org.apache.lucene.search.RegexpQuery; RegexpQuery(Term term, int flags); RegexpQuery(Term term, int flags, int maxDeterminizedStates);@param;int flags;int flags;optional RegExp features from RegExp;true
org.apache.lucene.search.RegexpQuery; RegexpQuery(Term term, int flags); RegexpQuery(Term term, int flags, AutomatonProvider provider, int maxDeterminizedStates);Free text;;;Constructs a query for terms matching <code>term</code>. ;true
org.apache.lucene.search.RegexpQuery; RegexpQuery(Term term, int flags); RegexpQuery(Term term, int flags, AutomatonProvider provider, int maxDeterminizedStates);@param;Term term;Term term;regular expression.;true
org.apache.lucene.search.RegexpQuery; RegexpQuery(Term term, int flags); RegexpQuery(Term term, int flags, AutomatonProvider provider, int maxDeterminizedStates);@param;int flags;int flags;optional RegExp features from RegExp;true
org.apache.lucene.search.RegexpQuery; RegexpQuery(Term term, int flags, int maxDeterminizedStates); RegexpQuery(Term term, int flags, AutomatonProvider provider, int maxDeterminizedStates);Free text;;;Constructs a query for terms matching <code>term</code>. ;true
org.apache.lucene.search.RegexpQuery; RegexpQuery(Term term, int flags, int maxDeterminizedStates); RegexpQuery(Term term, int flags, AutomatonProvider provider, int maxDeterminizedStates);@param;Term term;Term term;regular expression.;true
org.apache.lucene.search.RegexpQuery; RegexpQuery(Term term, int flags, int maxDeterminizedStates); RegexpQuery(Term term, int flags, AutomatonProvider provider, int maxDeterminizedStates);@param;int flags;int flags;optional RegExp features from RegExp;true
org.apache.lucene.search.RegexpQuery; RegexpQuery(Term term, int flags, int maxDeterminizedStates); RegexpQuery(Term term, int flags, AutomatonProvider provider, int maxDeterminizedStates);@param;int maxDeterminizedStates;int maxDeterminizedStates;maximum number of states that compiling the automaton for the regexp can result in. Set higher to allow more complex queries and lower to prevent memory exhaustion.;true
org.apache.lucene.search.SortedNumericSortField; SortedNumericSortField(String field, SortField.Type type); SortedNumericSortField(String field, SortField.Type type, boolean reverse);@param;String field;String field;Name of field to sort by. Must not be null.;true
org.apache.lucene.search.SortedNumericSortField; SortedNumericSortField(String field, SortField.Type type); SortedNumericSortField(String field, SortField.Type type, boolean reverse);@param;SortField.Type type;SortField.Type type;Type of values;true
org.apache.lucene.search.SortedNumericSortField; SortedNumericSortField(String field, SortField.Type type); SortedNumericSortField(String field, SortField.Type type, boolean reverse, SortedNumericSelector.Type selector);@param;String field;String field;Name of field to sort by. Must not be null.;true
org.apache.lucene.search.SortedNumericSortField; SortedNumericSortField(String field, SortField.Type type); SortedNumericSortField(String field, SortField.Type type, boolean reverse, SortedNumericSelector.Type selector);@param;SortField.Type type;SortField.Type type;Type of values;true
org.apache.lucene.search.SortedNumericSortField; SortedNumericSortField(String field, SortField.Type type, boolean reverse); SortedNumericSortField(String field, SortField.Type type, boolean reverse, SortedNumericSelector.Type selector);@param;String field;String field;Name of field to sort by. Must not be null.;true
org.apache.lucene.search.SortedNumericSortField; SortedNumericSortField(String field, SortField.Type type, boolean reverse); SortedNumericSortField(String field, SortField.Type type, boolean reverse, SortedNumericSelector.Type selector);@param;SortField.Type type;SortField.Type type;Type of values;true
org.apache.lucene.search.SortedNumericSortField; SortedNumericSortField(String field, SortField.Type type, boolean reverse); SortedNumericSortField(String field, SortField.Type type, boolean reverse, SortedNumericSelector.Type selector);@param;boolean reverse;boolean reverse;True if natural order should be reversed.;true
org.apache.lucene.search.ConstantScoreScorer; ConstantScoreScorer(Weight weight, float score, DocIdSetIterator disi); ConstantScoreScorer(Weight weight, float score, TwoPhaseIterator twoPhaseIterator);@param;Weight weight;Weight weight;the parent weight;true
org.apache.lucene.search.ConstantScoreScorer; ConstantScoreScorer(Weight weight, float score, DocIdSetIterator disi); ConstantScoreScorer(Weight weight, float score, TwoPhaseIterator twoPhaseIterator);@param;float score;float score;the score to return on each document;true
org.apache.lucene.search.ConstantScoreScorer; ConstantScoreScorer(Weight weight, float score, DocIdSetIterator disi); ConstantScoreScorer(Weight weight, float score, TwoPhaseIterator twoPhaseIterator);@param;DocIdSetIterator disi;TwoPhaseIterator twoPhaseIterator;the iterator that defines matching documents;true
org.apache.lucene.search.spans.SpanWeight; SpanWeight(SpanQuery query, IndexSearcher searcher, Map termContexts, float boost);Spans getSpans(LeafReaderContext ctx, Postings requiredPostings);@throws;;;on error;true
org.apache.lucene.search.spans.SpanWeight; SpanWeight(SpanQuery query, IndexSearcher searcher, Map termContexts, float boost);Similarity.SimScorer getSimScorer(LeafReaderContext context);@throws;;;on error;true
org.apache.lucene.search.spans.SpanWeight;Spans getSpans(LeafReaderContext ctx, Postings requiredPostings);Similarity.SimScorer getSimScorer(LeafReaderContext context);@throws;;;on error;true
org.apache.lucene.search.spans.SpanQuery;Map getTermContexts(SpanWeight weights);Map getTermContexts(Collection weights);Whole;;;Build a map of terms to termcontexts, for use in constructing SpanWeights @lucene.internal    ;false
org.apache.lucene.search.AutomatonQuery; AutomatonQuery(Term term, Automaton automaton); AutomatonQuery(Term term, Automaton automaton, int maxDeterminizedStates);Free text;;;Create a new AutomatonQuery from an {@link Automaton}. ;true
org.apache.lucene.search.AutomatonQuery; AutomatonQuery(Term term, Automaton automaton); AutomatonQuery(Term term, Automaton automaton, int maxDeterminizedStates);@param;Term term;Term term;Term containing field and possibly some pattern structure. The term text is ignored.;true
org.apache.lucene.search.AutomatonQuery; AutomatonQuery(Term term, Automaton automaton); AutomatonQuery(Term term, Automaton automaton, int maxDeterminizedStates);@param;Automaton automaton;Automaton automaton;Automaton to run, terms that are accepted are considered a match.;true
org.apache.lucene.search.AutomatonQuery; AutomatonQuery(Term term, Automaton automaton); AutomatonQuery(Term term, Automaton automaton, int maxDeterminizedStates, boolean isBinary);Free text;;;Create a new AutomatonQuery from an {@link Automaton}. ;true
org.apache.lucene.search.AutomatonQuery; AutomatonQuery(Term term, Automaton automaton); AutomatonQuery(Term term, Automaton automaton, int maxDeterminizedStates, boolean isBinary);@param;Term term;Term term;Term containing field and possibly some pattern structure. The term text is ignored.;true
org.apache.lucene.search.AutomatonQuery; AutomatonQuery(Term term, Automaton automaton); AutomatonQuery(Term term, Automaton automaton, int maxDeterminizedStates, boolean isBinary);@param;Automaton automaton;Automaton automaton;Automaton to run, terms that are accepted are considered a match.;true
org.apache.lucene.search.AutomatonQuery; AutomatonQuery(Term term, Automaton automaton, int maxDeterminizedStates); AutomatonQuery(Term term, Automaton automaton, int maxDeterminizedStates, boolean isBinary);Free text;;;Create a new AutomatonQuery from an {@link Automaton}. ;true
org.apache.lucene.search.AutomatonQuery; AutomatonQuery(Term term, Automaton automaton, int maxDeterminizedStates); AutomatonQuery(Term term, Automaton automaton, int maxDeterminizedStates, boolean isBinary);@param;Term term;Term term;Term containing field and possibly some pattern structure. The term text is ignored.;true
org.apache.lucene.search.AutomatonQuery; AutomatonQuery(Term term, Automaton automaton, int maxDeterminizedStates); AutomatonQuery(Term term, Automaton automaton, int maxDeterminizedStates, boolean isBinary);@param;Automaton automaton;Automaton automaton;Automaton to run, terms that are accepted are considered a match.;true
org.apache.lucene.search.AutomatonQuery; AutomatonQuery(Term term, Automaton automaton, int maxDeterminizedStates); AutomatonQuery(Term term, Automaton automaton, int maxDeterminizedStates, boolean isBinary);@param;int maxDeterminizedStates;int maxDeterminizedStates;maximum number of states in the resulting automata. If the automata would need more than this many states TooComplextToDeterminizeException is thrown. Higher number require more space but can process more complex automata.;true
org.apache.lucene.search.IndexSearcher;TopDocs searchAfter(ScoreDoc after, Query query, int numHits);TopDocs search(Query query, int n);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopDocs searchAfter(ScoreDoc after, Query query, int numHits);void search(Query query, Collector results);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopDocs searchAfter(ScoreDoc after, Query query, int numHits);TopFieldDocs search(Query query, int n, Sort sort, boolean doDocScores, boolean doMaxScore);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopDocs searchAfter(ScoreDoc after, Query query, int numHits);TopDocs searchAfter(ScoreDoc after, Query query, int n, Sort sort);Whole;;;hits for <code>query</code> where all results are after a previous result (<code>after</code>). <p> By passing the bottom result from a previous page as <code>after</code>, this method can be used for efficient 'deep-paging' across potentially large result sets.    @throws If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;false
org.apache.lucene.search.IndexSearcher;TopDocs searchAfter(ScoreDoc after, Query query, int numHits);TopFieldDocs searchAfter(ScoreDoc after, Query query, int numHits, Sort sort, boolean doDocScores, boolean doMaxScore);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopDocs searchAfter(ScoreDoc after, Query query, int numHits);void search(List leaves, Weight weight, Collector collector);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopDocs searchAfter(ScoreDoc after, Query query, int numHits);Query rewrite(Query original);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopDocs searchAfter(ScoreDoc after, Query query, int numHits);Explanation explain(Weight weight, int doc);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopDocs search(Query query, int n);void search(Query query, Collector results);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopDocs search(Query query, int n);TopFieldDocs search(Query query, int n, Sort sort, boolean doDocScores, boolean doMaxScore);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopDocs search(Query query, int n);TopDocs searchAfter(ScoreDoc after, Query query, int n, Sort sort);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopDocs search(Query query, int n);TopFieldDocs searchAfter(ScoreDoc after, Query query, int numHits, Sort sort, boolean doDocScores, boolean doMaxScore);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopDocs search(Query query, int n);void search(List leaves, Weight weight, Collector collector);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopDocs search(Query query, int n);Query rewrite(Query original);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopDocs search(Query query, int n);Explanation explain(Weight weight, int doc);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;void search(Query query, Collector results);TopFieldDocs search(Query query, int n, Sort sort, boolean doDocScores, boolean doMaxScore);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;void search(Query query, Collector results);TopDocs searchAfter(ScoreDoc after, Query query, int n, Sort sort);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;void search(Query query, Collector results);TopFieldDocs searchAfter(ScoreDoc after, Query query, int numHits, Sort sort, boolean doDocScores, boolean doMaxScore);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;void search(Query query, Collector results);void search(List leaves, Weight weight, Collector collector);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;void search(Query query, Collector results);Query rewrite(Query original);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;void search(Query query, Collector results);Explanation explain(Weight weight, int doc);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopFieldDocs search(Query query, int n, Sort sort, boolean doDocScores, boolean doMaxScore);TopDocs searchAfter(ScoreDoc after, Query query, int n, Sort sort);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopFieldDocs search(Query query, int n, Sort sort, boolean doDocScores, boolean doMaxScore);TopFieldDocs searchAfter(ScoreDoc after, Query query, int numHits, Sort sort, boolean doDocScores, boolean doMaxScore);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopFieldDocs search(Query query, int n, Sort sort, boolean doDocScores, boolean doMaxScore);void search(List leaves, Weight weight, Collector collector);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopFieldDocs search(Query query, int n, Sort sort, boolean doDocScores, boolean doMaxScore);Query rewrite(Query original);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopFieldDocs search(Query query, int n, Sort sort, boolean doDocScores, boolean doMaxScore);Explanation explain(Weight weight, int doc);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopDocs searchAfter(ScoreDoc after, Query query, int n, Sort sort);TopFieldDocs searchAfter(ScoreDoc after, Query query, int numHits, Sort sort, boolean doDocScores, boolean doMaxScore);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopDocs searchAfter(ScoreDoc after, Query query, int n, Sort sort);void search(List leaves, Weight weight, Collector collector);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopDocs searchAfter(ScoreDoc after, Query query, int n, Sort sort);Query rewrite(Query original);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopDocs searchAfter(ScoreDoc after, Query query, int n, Sort sort);Explanation explain(Weight weight, int doc);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopFieldDocs searchAfter(ScoreDoc after, Query query, int numHits, Sort sort, boolean doDocScores, boolean doMaxScore);void search(List leaves, Weight weight, Collector collector);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopFieldDocs searchAfter(ScoreDoc after, Query query, int numHits, Sort sort, boolean doDocScores, boolean doMaxScore);Query rewrite(Query original);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;TopFieldDocs searchAfter(ScoreDoc after, Query query, int numHits, Sort sort, boolean doDocScores, boolean doMaxScore);Explanation explain(Weight weight, int doc);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;void search(List leaves, Weight weight, Collector collector);Query rewrite(Query original);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;void search(List leaves, Weight weight, Collector collector);Explanation explain(Weight weight, int doc);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.IndexSearcher;Query rewrite(Query original);Explanation explain(Weight weight, int doc);@throws;;;If a query would exceed BooleanQuery#getMaxClauseCount() clauses.;true
org.apache.lucene.search.SortedSetSortField; SortedSetSortField(String field, boolean reverse); SortedSetSortField(String field, boolean reverse, SortedSetSelector.Type selector);@param;String field;String field;Name of field to sort by. Must not be null.;true
org.apache.lucene.search.SortedSetSortField; SortedSetSortField(String field, boolean reverse); SortedSetSortField(String field, boolean reverse, SortedSetSelector.Type selector);@param;boolean reverse;boolean reverse;True if natural order should be reversed.;true
org.apache.lucene.search.SearcherManager; SearcherManager(IndexWriter writer, SearcherFactory searcherFactory); SearcherManager(IndexWriter writer, boolean applyAllDeletes, boolean writeAllDeletes, SearcherFactory searcherFactory);@param;IndexWriter writer;IndexWriter writer;the IndexWriter to open the IndexReader from.;true
org.apache.lucene.search.SearcherManager; SearcherManager(IndexWriter writer, SearcherFactory searcherFactory); SearcherManager(IndexWriter writer, boolean applyAllDeletes, boolean writeAllDeletes, SearcherFactory searcherFactory);@param;SearcherFactory searcherFactory;SearcherFactory searcherFactory;An optional SearcherFactory. Pass null if you don't require the searcher to be warmed before going live or other custom behavior.;true
org.apache.lucene.search.SearcherManager; SearcherManager(IndexWriter writer, SearcherFactory searcherFactory); SearcherManager(IndexWriter writer, boolean applyAllDeletes, boolean writeAllDeletes, SearcherFactory searcherFactory);@throws;;;if there is a low-level I/O error;true
org.apache.lucene.search.SearcherManager; SearcherManager(IndexWriter writer, SearcherFactory searcherFactory); SearcherManager(Directory dir, SearcherFactory searcherFactory);@param;SearcherFactory searcherFactory;SearcherFactory searcherFactory;An optional SearcherFactory. Pass null if you don't require the searcher to be warmed before going live or other custom behavior.;true
org.apache.lucene.search.SearcherManager; SearcherManager(IndexWriter writer, SearcherFactory searcherFactory); SearcherManager(Directory dir, SearcherFactory searcherFactory);@throws;;;if there is a low-level I/O error;true
org.apache.lucene.search.SearcherManager; SearcherManager(IndexWriter writer, SearcherFactory searcherFactory); SearcherManager(DirectoryReader reader, SearcherFactory searcherFactory);@param;SearcherFactory searcherFactory;SearcherFactory searcherFactory;An optional SearcherFactory. Pass null if you don't require the searcher to be warmed before going live or other custom behavior.;true
org.apache.lucene.search.SearcherManager; SearcherManager(IndexWriter writer, SearcherFactory searcherFactory); SearcherManager(DirectoryReader reader, SearcherFactory searcherFactory);@throws;;;if there is a low-level I/O error;true
org.apache.lucene.search.SearcherManager; SearcherManager(IndexWriter writer, boolean applyAllDeletes, boolean writeAllDeletes, SearcherFactory searcherFactory); SearcherManager(Directory dir, SearcherFactory searcherFactory);@param;SearcherFactory searcherFactory;SearcherFactory searcherFactory;An optional SearcherFactory. Pass null if you don't require the searcher to be warmed before going live or other custom behavior.;true
org.apache.lucene.search.SearcherManager; SearcherManager(IndexWriter writer, boolean applyAllDeletes, boolean writeAllDeletes, SearcherFactory searcherFactory); SearcherManager(Directory dir, SearcherFactory searcherFactory);@throws;;;if there is a low-level I/O error;true
org.apache.lucene.search.SearcherManager; SearcherManager(IndexWriter writer, boolean applyAllDeletes, boolean writeAllDeletes, SearcherFactory searcherFactory); SearcherManager(DirectoryReader reader, SearcherFactory searcherFactory);@param;SearcherFactory searcherFactory;SearcherFactory searcherFactory;An optional SearcherFactory. Pass null if you don't require the searcher to be warmed before going live or other custom behavior.;true
org.apache.lucene.search.SearcherManager; SearcherManager(IndexWriter writer, boolean applyAllDeletes, boolean writeAllDeletes, SearcherFactory searcherFactory); SearcherManager(DirectoryReader reader, SearcherFactory searcherFactory);@throws;;;if there is a low-level I/O error;true
org.apache.lucene.search.SearcherManager; SearcherManager(Directory dir, SearcherFactory searcherFactory); SearcherManager(DirectoryReader reader, SearcherFactory searcherFactory);@param;SearcherFactory searcherFactory;SearcherFactory searcherFactory;An optional SearcherFactory. Pass null if you don't require the searcher to be warmed before going live or other custom behavior.;true
org.apache.lucene.search.SearcherManager; SearcherManager(Directory dir, SearcherFactory searcherFactory); SearcherManager(DirectoryReader reader, SearcherFactory searcherFactory);@throws;;;if there is a low-level I/O error;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);Free text;;;Creates a new {@link TopFieldCollector} from the given arguments. <p><b>NOTE</b>: The instances returned by this method pre-allocate a full array of length <code>numHits</code>. ;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@return;;;a TopFieldCollector instance which will sort the results by the sort criteria.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;Sort sort;Sort sort;the sort criteria (SortFields).;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;int numHits;int numHits;the number of results to collect.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;boolean fillFields;boolean fillFields;specifies whether the actual field values should be returned on the results (FieldDoc).;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;boolean trackDocScores;boolean trackDocScores;specifies whether document scores should be tracked and set on the results. Note that if set to false, then the results' scores will be set to Float.NaN. Setting this to true affects performance, as it incurs the score computation on each competitive result. Therefore if document scores are not required by the application, it is recommended to set it to false.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;boolean trackMaxScore;boolean trackMaxScore;specifies whether the query's maxScore should be tracked and set on the resulting TopDocs. Note that if set to false, TopDocs#getMaxScore() returns Float.NaN. Setting this to true affects performance as it incurs the score computation on each result. Also, setting this true automatically sets trackDocScores to true as well.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);Free text;;;Creates a new {@link TopFieldCollector} from the given arguments. <p><b>NOTE</b>: The instances returned by this method pre-allocate a full array of length <code>numHits</code>. ;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);@return;;;a TopFieldCollector instance which will sort the results by the sort criteria.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);@param;Sort sort;Sort sort;the sort criteria (SortFields).;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);@param;int numHits;int numHits;the number of results to collect.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);@param;boolean fillFields;boolean fillFields;specifies whether the actual field values should be returned on the results (FieldDoc).;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);@param;boolean trackDocScores;boolean trackDocScores;specifies whether document scores should be tracked and set on the results. Note that if set to false, then the results' scores will be set to Float.NaN. Setting this to true affects performance, as it incurs the score computation on each competitive result. Therefore if document scores are not required by the application, it is recommended to set it to false.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);@param;boolean trackMaxScore;boolean trackMaxScore;specifies whether the query's maxScore should be tracked and set on the resulting TopDocs. Note that if set to false, TopDocs#getMaxScore() returns Float.NaN. Setting this to true affects performance as it incurs the score computation on each result. Also, setting this true automatically sets trackDocScores to true as well.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);Free text;;;Creates a new {@link TopFieldCollector} from the given arguments. <p><b>NOTE</b>: The instances returned by this method pre-allocate a full array of length <code>numHits</code>. ;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@return;;;a TopFieldCollector instance which will sort the results by the sort criteria.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;Sort sort;Sort sort;the sort criteria (SortFields).;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;int numHits;int numHits;the number of results to collect.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;boolean fillFields;boolean fillFields;specifies whether the actual field values should be returned on the results (FieldDoc).;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;boolean trackDocScores;boolean trackDocScores;specifies whether document scores should be tracked and set on the results. Note that if set to false, then the results' scores will be set to Float.NaN. Setting this to true affects performance, as it incurs the score computation on each competitive result. Therefore if document scores are not required by the application, it is recommended to set it to false.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;boolean trackMaxScore;boolean trackMaxScore;specifies whether the query's maxScore should be tracked and set on the resulting TopDocs. Note that if set to false, TopDocs#getMaxScore() returns Float.NaN. Setting this to true affects performance as it incurs the score computation on each result. Also, setting this true automatically sets trackDocScores to true as well.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);Free text;;;Creates a new {@link TopFieldCollector} from the given arguments. <p><b>NOTE</b>: The instances returned by this method pre-allocate a full array of length <code>numHits</code>. ;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);@return;;;a TopFieldCollector instance which will sort the results by the sort criteria.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);@param;Sort sort;Sort sort;the sort criteria (SortFields).;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);@param;int numHits;int numHits;the number of results to collect.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);@param;boolean fillFields;boolean fillFields;specifies whether the actual field values should be returned on the results (FieldDoc).;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);@param;boolean trackDocScores;boolean trackDocScores;specifies whether document scores should be tracked and set on the results. Note that if set to false, then the results' scores will be set to Float.NaN. Setting this to true affects performance, as it incurs the score computation on each competitive result. Therefore if document scores are not required by the application, it is recommended to set it to false.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);@param;boolean trackMaxScore;boolean trackMaxScore;specifies whether the query's maxScore should be tracked and set on the resulting TopDocs. Note that if set to false, TopDocs#getMaxScore() returns Float.NaN. Setting this to true affects performance as it incurs the score computation on each result. Also, setting this true automatically sets trackDocScores to true as well.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);Free text;;;Creates a new {@link TopFieldCollector} from the given arguments. <p><b>NOTE</b>: The instances returned by this method pre-allocate a full array of length <code>numHits</code>. ;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@return;;;a TopFieldCollector instance which will sort the results by the sort criteria.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;Sort sort;Sort sort;the sort criteria (SortFields).;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;int numHits;int numHits;the number of results to collect.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;boolean fillFields;boolean fillFields;specifies whether the actual field values should be returned on the results (FieldDoc).;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;boolean trackDocScores;boolean trackDocScores;specifies whether document scores should be tracked and set on the results. Note that if set to false, then the results' scores will be set to Float.NaN. Setting this to true affects performance, as it incurs the score computation on each competitive result. Therefore if document scores are not required by the application, it is recommended to set it to false.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;boolean trackMaxScore;boolean trackMaxScore;specifies whether the query's maxScore should be tracked and set on the resulting TopDocs. Note that if set to false, TopDocs#getMaxScore() returns Float.NaN. Setting this to true affects performance as it incurs the score computation on each result. Also, setting this true automatically sets trackDocScores to true as well.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;boolean trackTotalHits;boolean trackTotalHits;specifies whether the total number of hits should be tracked. If set to false, the value of TopFieldDocs#totalHits will be approximated.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);Free text;;;Creates a new {@link TopFieldCollector} from the given arguments. <p><b>NOTE</b>: The instances returned by this method pre-allocate a full array of length <code>numHits</code>. ;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@return;;;a TopFieldCollector instance which will sort the results by the sort criteria.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;Sort sort;Sort sort;the sort criteria (SortFields).;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;int numHits;int numHits;the number of results to collect.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;FieldDoc after;FieldDoc after;only hits after this FieldDoc will be collected;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;boolean fillFields;boolean fillFields;specifies whether the actual field values should be returned on the results (FieldDoc).;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;boolean trackDocScores;boolean trackDocScores;specifies whether document scores should be tracked and set on the results. Note that if set to false, then the results' scores will be set to Float.NaN. Setting this to true affects performance, as it incurs the score computation on each competitive result. Therefore if document scores are not required by the application, it is recommended to set it to false.;true
org.apache.lucene.search.TopFieldCollector;TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore);TopFieldCollector create(Sort sort, int numHits, FieldDoc after, boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits);@param;boolean trackMaxScore;boolean trackMaxScore;specifies whether the query's maxScore should be tracked and set on the resulting TopDocs. Note that if set to false, TopDocs#getMaxScore() returns Float.NaN. Setting this to true affects performance as it incurs the score computation on each result. Also, setting this true automatically sets trackDocScores to true as well.;true
org.apache.lucene.search.ConjunctionDISI;DocIdSetIterator intersectScorers(Collection scorers);DocIdSetIterator intersectIterators(List iterators);Whole;;;returned {@link DocIdSetIterator} might leverage two-phase iteration in which case it is possible to retrieve the {@link TwoPhaseIterator} using {@link TwoPhaseIterator#unwrap}.    ;false
org.apache.lucene.search.ConjunctionDISI;DocIdSetIterator intersectScorers(Collection scorers);DocIdSetIterator intersectSpans(List spanList);Whole;;;returned {@link DocIdSetIterator} might leverage two-phase iteration in which case it is possible to retrieve the {@link TwoPhaseIterator} using {@link TwoPhaseIterator#unwrap}.    ;false
org.apache.lucene.search.ConjunctionDISI;DocIdSetIterator intersectIterators(List iterators);DocIdSetIterator intersectSpans(List spanList);Whole;;;returned {@link DocIdSetIterator} might leverage two-phase iteration in which case it is possible to retrieve the {@link TwoPhaseIterator} using {@link TwoPhaseIterator#unwrap}.    ;false
org.apache.lucene.search.ReferenceManager;G refreshIfNeeded(G referenceToRefresh);boolean tryIncRef(G reference);@throws;;;if the reference manager has been close() closed.;true
org.apache.lucene.search.ReferenceManager;G refreshIfNeeded(G referenceToRefresh);G acquire();@throws;;;if the reference manager has been close() closed.;true
org.apache.lucene.search.ReferenceManager;G refreshIfNeeded(G referenceToRefresh);boolean maybeRefresh();@throws;;;if the reference manager has been close() closed.;true
org.apache.lucene.search.ReferenceManager;G refreshIfNeeded(G referenceToRefresh);void maybeRefreshBlocking();@throws;;;if the reference manager has been close() closed.;true
org.apache.lucene.search.ReferenceManager;boolean tryIncRef(G reference);G acquire();@throws;;;if the reference manager has been close() closed.;true
org.apache.lucene.search.ReferenceManager;boolean tryIncRef(G reference);boolean maybeRefresh();@throws;;;if the reference manager has been close() closed.;true
org.apache.lucene.search.ReferenceManager;boolean tryIncRef(G reference);void maybeRefreshBlocking();@throws;;;if the reference manager has been close() closed.;true
org.apache.lucene.search.ReferenceManager;G acquire();boolean maybeRefresh();@throws;;;if the reference manager has been close() closed.;true
org.apache.lucene.search.ReferenceManager;G acquire();void maybeRefreshBlocking();@throws;;;if the reference manager has been close() closed.;true
org.apache.lucene.search.ReferenceManager;boolean maybeRefresh();void maybeRefreshBlocking();@throws;;;if refreshing the resource causes an IOException;true
org.apache.lucene.search.ReferenceManager;boolean maybeRefresh();void maybeRefreshBlocking();@throws;;;if the reference manager has been close() closed.;true
org.apache.lucene.search.SortField; SortField(String field, Type type); SortField(String field, Type type, boolean reverse);@param;String field;String field;Name of field to sort by. Can be null if type is SCORE or DOC.;true
org.apache.lucene.search.SortField; SortField(String field, Type type); SortField(String field, Type type, boolean reverse);@param;Type type;Type type;Type of values in the terms.;true
org.apache.lucene.search.SortField; SortField(String field, Type type, boolean reverse); SortField(String field, FieldComparatorSource comparator, boolean reverse);@param;boolean reverse;boolean reverse;True if natural order should be reversed.;true
org.apache.lucene.search.SortField; SortField(String field, FieldComparatorSource comparator); SortField(String field, FieldComparatorSource comparator, boolean reverse);@param;String field;String field;Name of field to sort by, cannot be null.;true
org.apache.lucene.search.SortField; SortField(String field, FieldComparatorSource comparator); SortField(String field, FieldComparatorSource comparator, boolean reverse);@param;FieldComparatorSource comparator;FieldComparatorSource comparator;Returns a comparator for sorting hits.;true
org.apache.lucene.search.CachingCollector;CachingCollector create(Collector other, boolean cacheScores, double maxRAMMB);CachingCollector create(Collector other, boolean cacheScores, int maxDocsToCache);@param;Collector other;Collector other;the Collector to wrap and delegate calls to.;true
org.apache.lucene.search.CachingCollector;CachingCollector create(Collector other, boolean cacheScores, double maxRAMMB);CachingCollector create(Collector other, boolean cacheScores, int maxDocsToCache);@param;boolean cacheScores;boolean cacheScores;whether to cache scores in addition to document IDs. Note that this increases the RAM consumed per doc;true
org.apache.lucene.search.FilterScorer; FilterScorer(Scorer in); FilterScorer(Scorer in, Weight weight);@param;Scorer in;Scorer in;the Scorer to wrap;true
org.apache.lucene.search.LeafFieldComparator;int compareBottom(int doc);int compareTop(int doc);@param;int doc;int doc;that was hit;true
org.apache.lucene.search.BulkScorer;void score(LeafCollector collector, Bits acceptDocs);int score(LeafCollector collector, Bits acceptDocs, int min, int max);@param;LeafCollector collector;LeafCollector collector;The collector to which all matching documents are passed.;true
org.apache.lucene.search.BulkScorer;void score(LeafCollector collector, Bits acceptDocs);int score(LeafCollector collector, Bits acceptDocs, int min, int max);@param;Bits acceptDocs;Bits acceptDocs;Bits that represents the allowed documents to match, or null if they are all allowed to match.;true
org.apache.lucene.search.Explanation;Explanation match(float value, String description, Collection details);Explanation match(float value, String description, Explanation details);Whole;;;Create a new explanation for a match.  @param the contribution to the score of the document@param how value was computed@param sub explanations that contributed to this explanation  ;false
org.apache.lucene.search.Explanation;Explanation noMatch(String description, Collection details);Explanation noMatch(String description, Explanation details);Whole;;;Create a new explanation for a document which does not match.    ;false
org.apache.lucene.search.Weight;Scorer scorer(LeafReaderContext context);BulkScorer bulkScorer(LeafReaderContext context);@param;LeafReaderContext context;LeafReaderContext context;the org.apache.lucene.index.LeafReaderContext for which to return the Scorer.;true
org.apache.lucene.search.Weight;Scorer scorer(LeafReaderContext context);BulkScorer bulkScorer(LeafReaderContext context);@throws;;;if there is a low-level I/O error;true
org.apache.lucene.search.ControlledRealTimeReopenThread;void waitForGeneration(long targetGen);boolean waitForGeneration(long targetGen, int maxMS);@param;long targetGen;long targetGen;the generation to wait for;true
org.apache.lucene.index.IndexWriter;void advanceSegmentInfosVersion(long newVersion);void setKeepFullyDeletedSegments(boolean v);Whole;;;@lucene.internal    ;false
org.apache.lucene.index.IndexWriter;void advanceSegmentInfosVersion(long newVersion);void incRefDeleter(SegmentInfos segmentInfos);Whole;;;@lucene.internal    ;false
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long addDocuments(Iterable docs);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long addDocuments(Iterable docs);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long addDocuments(Iterable docs);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long updateDocuments(Term delTerm, Iterable docs);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long updateDocuments(Term delTerm, Iterable docs);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long updateDocuments(Term delTerm, Iterable docs);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long deleteDocuments(Term terms);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long deleteDocuments(Term terms);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long deleteDocuments(Term terms);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long deleteDocuments(Query queries);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long deleteDocuments(Query queries);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long deleteDocuments(Query queries);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long updateDocument(Term term, Iterable doc);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long updateDocument(Term term, Iterable doc);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long updateDocument(Term term, Iterable doc);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long updateNumericDocValue(Term term, String field, long value);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long updateNumericDocValue(Term term, String field, long value);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long updateNumericDocValue(Term term, String field, long value);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long updateBinaryDocValue(Term term, String field, BytesRef value);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long updateBinaryDocValue(Term term, String field, BytesRef value);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long updateBinaryDocValue(Term term, String field, BytesRef value);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long updateDocValues(Term term, Field updates);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long updateDocValues(Term term, Field updates);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long updateDocValues(Term term, Field updates);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);void forceMerge(int maxNumSegments);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);void forceMerge(int maxNumSegments);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);void rollback();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long deleteAll();@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long addIndexes(Directory dirs);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long addIndexes(Directory dirs);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long addIndexes(Directory dirs);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long addIndexes(CodecReader readers);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long addIndexes(CodecReader readers);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addDocument(Iterable doc);long addIndexes(CodecReader readers);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long updateDocuments(Term delTerm, Iterable docs);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long updateDocuments(Term delTerm, Iterable docs);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long updateDocuments(Term delTerm, Iterable docs);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long deleteDocuments(Term terms);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long deleteDocuments(Term terms);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long deleteDocuments(Term terms);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long deleteDocuments(Query queries);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long deleteDocuments(Query queries);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long deleteDocuments(Query queries);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long updateDocument(Term term, Iterable doc);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long updateDocument(Term term, Iterable doc);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long updateDocument(Term term, Iterable doc);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long updateNumericDocValue(Term term, String field, long value);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long updateNumericDocValue(Term term, String field, long value);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long updateNumericDocValue(Term term, String field, long value);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long updateBinaryDocValue(Term term, String field, BytesRef value);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long updateBinaryDocValue(Term term, String field, BytesRef value);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long updateBinaryDocValue(Term term, String field, BytesRef value);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long updateDocValues(Term term, Field updates);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long updateDocValues(Term term, Field updates);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long updateDocValues(Term term, Field updates);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);void forceMerge(int maxNumSegments);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);void forceMerge(int maxNumSegments);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);void rollback();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long deleteAll();@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long addIndexes(Directory dirs);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long addIndexes(Directory dirs);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long addIndexes(Directory dirs);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long addIndexes(CodecReader readers);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long addIndexes(CodecReader readers);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addDocuments(Iterable docs);long addIndexes(CodecReader readers);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long deleteDocuments(Term terms);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long deleteDocuments(Term terms);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long deleteDocuments(Term terms);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long deleteDocuments(Query queries);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long deleteDocuments(Query queries);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long deleteDocuments(Query queries);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long updateDocument(Term term, Iterable doc);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long updateDocument(Term term, Iterable doc);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long updateDocument(Term term, Iterable doc);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long updateNumericDocValue(Term term, String field, long value);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long updateNumericDocValue(Term term, String field, long value);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long updateNumericDocValue(Term term, String field, long value);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long updateBinaryDocValue(Term term, String field, BytesRef value);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long updateBinaryDocValue(Term term, String field, BytesRef value);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long updateBinaryDocValue(Term term, String field, BytesRef value);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long updateDocValues(Term term, Field updates);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long updateDocValues(Term term, Field updates);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long updateDocValues(Term term, Field updates);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);void forceMerge(int maxNumSegments);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);void forceMerge(int maxNumSegments);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);void rollback();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long deleteAll();@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long addIndexes(Directory dirs);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long addIndexes(Directory dirs);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long addIndexes(Directory dirs);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long addIndexes(CodecReader readers);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long addIndexes(CodecReader readers);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateDocuments(Term delTerm, Iterable docs);long addIndexes(CodecReader readers);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long deleteDocuments(Query queries);@return;;;The sequence number for this operation;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long deleteDocuments(Query queries);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long deleteDocuments(Query queries);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long updateDocument(Term term, Iterable doc);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long updateDocument(Term term, Iterable doc);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long updateDocument(Term term, Iterable doc);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long updateNumericDocValue(Term term, String field, long value);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long updateNumericDocValue(Term term, String field, long value);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long updateNumericDocValue(Term term, String field, long value);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long updateBinaryDocValue(Term term, String field, BytesRef value);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long updateBinaryDocValue(Term term, String field, BytesRef value);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long updateBinaryDocValue(Term term, String field, BytesRef value);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long updateDocValues(Term term, Field updates);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long updateDocValues(Term term, Field updates);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long updateDocValues(Term term, Field updates);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);void forceMerge(int maxNumSegments);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);void forceMerge(int maxNumSegments);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);void rollback();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long deleteAll();@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long addIndexes(Directory dirs);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long addIndexes(Directory dirs);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long addIndexes(Directory dirs);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long addIndexes(CodecReader readers);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long addIndexes(CodecReader readers);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Term terms);long addIndexes(CodecReader readers);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);long updateDocument(Term term, Iterable doc);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);long updateDocument(Term term, Iterable doc);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);long updateDocument(Term term, Iterable doc);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);long updateNumericDocValue(Term term, String field, long value);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);long updateNumericDocValue(Term term, String field, long value);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);long updateNumericDocValue(Term term, String field, long value);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);long updateBinaryDocValue(Term term, String field, BytesRef value);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);long updateBinaryDocValue(Term term, String field, BytesRef value);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);long updateBinaryDocValue(Term term, String field, BytesRef value);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);long updateDocValues(Term term, Field updates);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);long updateDocValues(Term term, Field updates);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);long updateDocValues(Term term, Field updates);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);void forceMerge(int maxNumSegments);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);void forceMerge(int maxNumSegments);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);void rollback();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);long deleteAll();@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);long addIndexes(Directory dirs);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);long addIndexes(Directory dirs);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);long addIndexes(Directory dirs);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);long addIndexes(CodecReader readers);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);long addIndexes(CodecReader readers);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long deleteDocuments(Query queries);long addIndexes(CodecReader readers);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateDocument(Term term, Iterable doc);long updateNumericDocValue(Term term, String field, long value);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateDocument(Term term, Iterable doc);long updateNumericDocValue(Term term, String field, long value);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateDocument(Term term, Iterable doc);long updateNumericDocValue(Term term, String field, long value);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateDocument(Term term, Iterable doc);long updateBinaryDocValue(Term term, String field, BytesRef value);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateDocument(Term term, Iterable doc);long updateBinaryDocValue(Term term, String field, BytesRef value);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateDocument(Term term, Iterable doc);long updateBinaryDocValue(Term term, String field, BytesRef value);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateDocument(Term term, Iterable doc);long updateDocValues(Term term, Field updates);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateDocument(Term term, Iterable doc);long updateDocValues(Term term, Field updates);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateDocument(Term term, Iterable doc);long updateDocValues(Term term, Field updates);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateDocument(Term term, Iterable doc);void forceMerge(int maxNumSegments);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateDocument(Term term, Iterable doc);void forceMerge(int maxNumSegments);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateDocument(Term term, Iterable doc);void rollback();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateDocument(Term term, Iterable doc);long deleteAll();@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateDocument(Term term, Iterable doc);long addIndexes(Directory dirs);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateDocument(Term term, Iterable doc);long addIndexes(Directory dirs);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateDocument(Term term, Iterable doc);long addIndexes(Directory dirs);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateDocument(Term term, Iterable doc);long addIndexes(CodecReader readers);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateDocument(Term term, Iterable doc);long addIndexes(CodecReader readers);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateDocument(Term term, Iterable doc);long addIndexes(CodecReader readers);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateNumericDocValue(Term term, String field, long value);long updateBinaryDocValue(Term term, String field, BytesRef value);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateNumericDocValue(Term term, String field, long value);long updateBinaryDocValue(Term term, String field, BytesRef value);@param;Term term;Term term;the term to identify the document(s) to be updated;true
org.apache.lucene.index.IndexWriter;long updateNumericDocValue(Term term, String field, long value);long updateBinaryDocValue(Term term, String field, BytesRef value);@param;long value;BytesRef value;new value for the field;true
org.apache.lucene.index.IndexWriter;long updateNumericDocValue(Term term, String field, long value);long updateBinaryDocValue(Term term, String field, BytesRef value);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateNumericDocValue(Term term, String field, long value);long updateBinaryDocValue(Term term, String field, BytesRef value);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateNumericDocValue(Term term, String field, long value);long updateDocValues(Term term, Field updates);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateNumericDocValue(Term term, String field, long value);long updateDocValues(Term term, Field updates);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateNumericDocValue(Term term, String field, long value);long updateDocValues(Term term, Field updates);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateNumericDocValue(Term term, String field, long value);void forceMerge(int maxNumSegments);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateNumericDocValue(Term term, String field, long value);void forceMerge(int maxNumSegments);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateNumericDocValue(Term term, String field, long value);void rollback();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateNumericDocValue(Term term, String field, long value);long deleteAll();@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateNumericDocValue(Term term, String field, long value);long addIndexes(Directory dirs);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateNumericDocValue(Term term, String field, long value);long addIndexes(Directory dirs);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateNumericDocValue(Term term, String field, long value);long addIndexes(Directory dirs);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateNumericDocValue(Term term, String field, long value);long addIndexes(CodecReader readers);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateNumericDocValue(Term term, String field, long value);long addIndexes(CodecReader readers);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateNumericDocValue(Term term, String field, long value);long addIndexes(CodecReader readers);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateBinaryDocValue(Term term, String field, BytesRef value);long updateDocValues(Term term, Field updates);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateBinaryDocValue(Term term, String field, BytesRef value);long updateDocValues(Term term, Field updates);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateBinaryDocValue(Term term, String field, BytesRef value);long updateDocValues(Term term, Field updates);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateBinaryDocValue(Term term, String field, BytesRef value);void forceMerge(int maxNumSegments);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateBinaryDocValue(Term term, String field, BytesRef value);void forceMerge(int maxNumSegments);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateBinaryDocValue(Term term, String field, BytesRef value);void rollback();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateBinaryDocValue(Term term, String field, BytesRef value);long deleteAll();@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateBinaryDocValue(Term term, String field, BytesRef value);long addIndexes(Directory dirs);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateBinaryDocValue(Term term, String field, BytesRef value);long addIndexes(Directory dirs);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateBinaryDocValue(Term term, String field, BytesRef value);long addIndexes(Directory dirs);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateBinaryDocValue(Term term, String field, BytesRef value);long addIndexes(CodecReader readers);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateBinaryDocValue(Term term, String field, BytesRef value);long addIndexes(CodecReader readers);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateBinaryDocValue(Term term, String field, BytesRef value);long addIndexes(CodecReader readers);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateDocValues(Term term, Field updates);void forceMerge(int maxNumSegments);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateDocValues(Term term, Field updates);void forceMerge(int maxNumSegments);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateDocValues(Term term, Field updates);void rollback();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateDocValues(Term term, Field updates);long deleteAll();@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateDocValues(Term term, Field updates);long addIndexes(Directory dirs);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateDocValues(Term term, Field updates);long addIndexes(Directory dirs);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateDocValues(Term term, Field updates);long addIndexes(Directory dirs);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long updateDocValues(Term term, Field updates);long addIndexes(CodecReader readers);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long updateDocValues(Term term, Field updates);long addIndexes(CodecReader readers);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long updateDocValues(Term term, Field updates);long addIndexes(CodecReader readers);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;void forceMerge(int maxNumSegments);void rollback();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;void forceMerge(int maxNumSegments);long addIndexes(Directory dirs);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;void forceMerge(int maxNumSegments);long addIndexes(Directory dirs);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;void forceMerge(int maxNumSegments);long addIndexes(CodecReader readers);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;void forceMerge(int maxNumSegments);long addIndexes(CodecReader readers);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;void rollback();long addIndexes(Directory dirs);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;void rollback();long addIndexes(CodecReader readers);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long deleteAll();long addIndexes(Directory dirs);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long deleteAll();long addIndexes(CodecReader readers);@return;;;The sequence number for this operation;false
org.apache.lucene.index.IndexWriter;long addIndexes(Directory dirs);long addIndexes(CodecReader readers);@return;;;The sequence number for this operation;true
org.apache.lucene.index.IndexWriter;long addIndexes(Directory dirs);long addIndexes(CodecReader readers);@throws;;;if the index is corrupt;true
org.apache.lucene.index.IndexWriter;long addIndexes(Directory dirs);long addIndexes(CodecReader readers);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.IndexWriter;long prepareCommit();long commit();@return;;;The sequence number of the last operation in the commit. All sequence numbers <= this value will be reflected in the commit, and all others will not.;false
org.apache.lucene.index.IndexWriter;void mergeInit(MergePolicy.OneMerge merge);void mergeFinish(MergePolicy.OneMerge merge);Whole;;; the synchronized lock on IndexWriter instance.    ;false
org.apache.lucene.index.IndexWriter;void setKeepFullyDeletedSegments(boolean v);void incRefDeleter(SegmentInfos segmentInfos);Whole;;;@lucene.internal    ;false
org.apache.lucene.index.SegmentInfo;void addFiles(Collection files);void addFile(String file);Whole;;; segment.    ;false
org.apache.lucene.index.IndexReader;boolean equals(Object obj);int hashCode();Whole;;;<p>{@code IndexReader} subclasses are not allowed to implement equals/hashCode, so methods are declared final.    ;false
org.apache.lucene.index.ReaderUtil;int subIndex(int n, int[] docStarts);int subIndex(int n, List leaves);Whole;;;Returns index of the searcher/reader for document <code>n</code> in the array used to construct this searcher/reader.    ;false
org.apache.lucene.index.StandardDirectoryReader;DirectoryReader open(Directory directory, SegmentInfos infos, List oldReaders);SegmentInfos getSegmentInfos();Free text;;; @lucene.internal ;false
org.apache.lucene.index.DirectoryReader;DirectoryReader open(Directory directory);DirectoryReader open(IndexWriter writer);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(Directory directory);DirectoryReader open(IndexCommit commit);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(Directory directory);DirectoryReader openIfChanged(DirectoryReader oldReader);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(Directory directory);DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(Directory directory);DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer, boolean applyAllDeletes);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(Directory directory);DirectoryReader doOpenIfChanged();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(Directory directory);DirectoryReader doOpenIfChanged(IndexCommit commit);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(Directory directory);DirectoryReader doOpenIfChanged(IndexWriter writer, boolean applyAllDeletes);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(Directory directory);boolean isCurrent();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexWriter writer);DirectoryReader open(IndexWriter writer, boolean applyAllDeletes, boolean writeAllDeletes);@param;IndexWriter writer;IndexWriter writer;The IndexWriter to open from;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexWriter writer);DirectoryReader open(IndexCommit commit);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexWriter writer);DirectoryReader openIfChanged(DirectoryReader oldReader);@throws;;;if the index is corrupt;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexWriter writer);DirectoryReader openIfChanged(DirectoryReader oldReader);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexWriter writer);DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer);@param;IndexWriter writer;IndexWriter writer;The IndexWriter to open from;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexWriter writer);DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexWriter writer);DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer, boolean applyAllDeletes);@param;IndexWriter writer;IndexWriter writer;The IndexWriter to open from;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexWriter writer);DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer, boolean applyAllDeletes);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexWriter writer);DirectoryReader doOpenIfChanged();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexWriter writer);DirectoryReader doOpenIfChanged(IndexCommit commit);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexWriter writer);DirectoryReader doOpenIfChanged(IndexWriter writer, boolean applyAllDeletes);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexWriter writer);boolean isCurrent();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexWriter writer, boolean applyAllDeletes, boolean writeAllDeletes);DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer);@param;IndexWriter writer;IndexWriter writer;The IndexWriter to open from;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexWriter writer, boolean applyAllDeletes, boolean writeAllDeletes);DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer, boolean applyAllDeletes);@param;IndexWriter writer;IndexWriter writer;The IndexWriter to open from;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexWriter writer, boolean applyAllDeletes, boolean writeAllDeletes);DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer, boolean applyAllDeletes);@param;boolean applyAllDeletes;boolean applyAllDeletes;If true, all buffered deletes will be applied (made visible) in the returned reader. If false, the deletes are not applied but remain buffered (in IndexWriter) so that they will be applied in the future. Applying deletes can be costly, so if your app can tolerate deleted documents being returned you might gain some performance by passing false.;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexCommit commit);DirectoryReader openIfChanged(DirectoryReader oldReader);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexCommit commit);DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexCommit commit);DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer, boolean applyAllDeletes);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexCommit commit);DirectoryReader doOpenIfChanged();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexCommit commit);DirectoryReader doOpenIfChanged(IndexCommit commit);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexCommit commit);DirectoryReader doOpenIfChanged(IndexWriter writer, boolean applyAllDeletes);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader open(IndexCommit commit);boolean isCurrent();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader openIfChanged(DirectoryReader oldReader);DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader openIfChanged(DirectoryReader oldReader);DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer, boolean applyAllDeletes);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader openIfChanged(DirectoryReader oldReader);DirectoryReader doOpenIfChanged();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader openIfChanged(DirectoryReader oldReader);DirectoryReader doOpenIfChanged(IndexCommit commit);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader openIfChanged(DirectoryReader oldReader);DirectoryReader doOpenIfChanged(IndexWriter writer, boolean applyAllDeletes);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader openIfChanged(DirectoryReader oldReader);boolean isCurrent();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer);DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer, boolean applyAllDeletes);@param;IndexWriter writer;IndexWriter writer;The IndexWriter to open from;true
org.apache.lucene.index.DirectoryReader;DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer);DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer, boolean applyAllDeletes);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer);DirectoryReader doOpenIfChanged();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer);DirectoryReader doOpenIfChanged(IndexCommit commit);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer);DirectoryReader doOpenIfChanged(IndexWriter writer, boolean applyAllDeletes);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer);boolean isCurrent();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer, boolean applyAllDeletes);DirectoryReader doOpenIfChanged();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer, boolean applyAllDeletes);DirectoryReader doOpenIfChanged(IndexCommit commit);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer, boolean applyAllDeletes);DirectoryReader doOpenIfChanged(IndexWriter writer, boolean applyAllDeletes);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader openIfChanged(DirectoryReader oldReader, IndexWriter writer, boolean applyAllDeletes);boolean isCurrent();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader doOpenIfChanged();DirectoryReader doOpenIfChanged(IndexCommit commit);@return;;;null if there are no changes, else, a new DirectoryReader instance.;true
org.apache.lucene.index.DirectoryReader;DirectoryReader doOpenIfChanged();DirectoryReader doOpenIfChanged(IndexCommit commit);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader doOpenIfChanged();DirectoryReader doOpenIfChanged(IndexWriter writer, boolean applyAllDeletes);@return;;;null if there are no changes, else, a new DirectoryReader instance.;true
org.apache.lucene.index.DirectoryReader;DirectoryReader doOpenIfChanged();DirectoryReader doOpenIfChanged(IndexWriter writer, boolean applyAllDeletes);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader doOpenIfChanged();boolean isCurrent();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader doOpenIfChanged(IndexCommit commit);DirectoryReader doOpenIfChanged(IndexWriter writer, boolean applyAllDeletes);@return;;;null if there are no changes, else, a new DirectoryReader instance.;true
org.apache.lucene.index.DirectoryReader;DirectoryReader doOpenIfChanged(IndexCommit commit);DirectoryReader doOpenIfChanged(IndexWriter writer, boolean applyAllDeletes);@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader doOpenIfChanged(IndexCommit commit);boolean isCurrent();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.DirectoryReader;DirectoryReader doOpenIfChanged(IndexWriter writer, boolean applyAllDeletes);boolean isCurrent();@throws;;;if there is a low-level IO error;true
org.apache.lucene.index.LogMergePolicy;long sizeDocs(SegmentCommitInfo info, IndexWriter writer);long sizeBytes(SegmentCommitInfo info, IndexWriter writer);Whole;;; SegmentCommitInfo}, pro-rated by percentage of  non-deleted documents if {@link  #setCalibrateSizeByDeletes} is set.    ;false
org.apache.lucene.index.ReaderManager; ReaderManager(IndexWriter writer); ReaderManager(IndexWriter writer, boolean applyAllDeletes, boolean writeAllDeletes);@param;IndexWriter writer;IndexWriter writer;the IndexWriter to open the IndexReader from.;true
org.apache.lucene.index.ReaderManager; ReaderManager(IndexWriter writer); ReaderManager(IndexWriter writer, boolean applyAllDeletes, boolean writeAllDeletes);@throws;;;If there is a low-level I/O error;true
org.apache.lucene.index.ReaderManager; ReaderManager(IndexWriter writer); ReaderManager(Directory dir);@throws;;;If there is a low-level I/O error;true
org.apache.lucene.index.ReaderManager; ReaderManager(IndexWriter writer); ReaderManager(DirectoryReader reader);@throws;;;If there is a low-level I/O error;true
org.apache.lucene.index.ReaderManager; ReaderManager(IndexWriter writer, boolean applyAllDeletes, boolean writeAllDeletes); ReaderManager(Directory dir);@throws;;;If there is a low-level I/O error;true
org.apache.lucene.index.ReaderManager; ReaderManager(IndexWriter writer, boolean applyAllDeletes, boolean writeAllDeletes); ReaderManager(DirectoryReader reader);@throws;;;If there is a low-level I/O error;true
org.apache.lucene.index.ReaderManager; ReaderManager(Directory dir); ReaderManager(DirectoryReader reader);@throws;;;If there is a low-level I/O error;true
org.apache.lucene.index.IndexFormatTooOldException; IndexFormatTooOldException(String resourceDescription, String reason); IndexFormatTooOldException(DataInput in, String reason);@param;String reason;String reason;the reason for this exception if the version is not available;true
org.apache.lucene.index.IndexFormatTooOldException; IndexFormatTooOldException(String resourceDescription, String reason); IndexFormatTooOldException(String resourceDescription, int version, int minVersion, int maxVersion);@param;String resourceDescription;String resourceDescription;describes the file that was too old;true
org.apache.lucene.index.IndexFormatTooOldException; IndexFormatTooOldException(DataInput in, String reason); IndexFormatTooOldException(DataInput in, int version, int minVersion, int maxVersion);@param;DataInput in;DataInput in;the open file that's too old;true
org.apache.lucene.index.IndexFormatTooOldException; IndexFormatTooOldException(String resourceDescription, int version, int minVersion, int maxVersion); IndexFormatTooOldException(DataInput in, int version, int minVersion, int maxVersion);@param;int version;int version;the version of the file that was too old;true
org.apache.lucene.index.IndexFormatTooOldException; IndexFormatTooOldException(String resourceDescription, int version, int minVersion, int maxVersion); IndexFormatTooOldException(DataInput in, int version, int minVersion, int maxVersion);@param;int minVersion;int minVersion;the minimum version accepted;true
org.apache.lucene.index.IndexFormatTooOldException; IndexFormatTooOldException(String resourceDescription, int version, int minVersion, int maxVersion); IndexFormatTooOldException(DataInput in, int version, int minVersion, int maxVersion);@param;int maxVersion;int maxVersion;the maximum version accepted;true
org.apache.lucene.index.Terms;BytesRef getMin();BytesRef getMax();Whole;;; Note that, just like other term measures, this measure does not  take deleted documents into account.  This returns  null when there are no terms.    ;false
org.apache.lucene.index.DocValues;LegacySortedDocValues emptyLegacySorted();SortedDocValues emptySorted();Whole;;;An empty SortedDocValues which returns {@link BytesRef#EMPTY_BYTES} for every document    ;false
org.apache.lucene.index.DocValues;LegacySortedDocValues emptyLegacySorted();SortedSetDocValues emptySortedSet();Whole;;;An empty SortedDocValues which returns {@link BytesRef#EMPTY_BYTES} for every document    ;false
org.apache.lucene.index.DocValues;SortedDocValues emptySorted();SortedSetDocValues emptySortedSet();Whole;;;An empty SortedDocValues which returns {@link BytesRef#EMPTY_BYTES} for every document    ;false
org.apache.lucene.index.DocValues;NumericDocValues getNumeric(LeafReader reader, String field);BinaryDocValues getBinary(LeafReader reader, String field);@return;;;docvalues instance, or an empty instance if field does not exist in this reader.;false
org.apache.lucene.index.DocValues;NumericDocValues getNumeric(LeafReader reader, String field);BinaryDocValues getBinary(LeafReader reader, String field);@throws;;;if field exists, but was not indexed with docvalues.;true
org.apache.lucene.index.DocValues;NumericDocValues getNumeric(LeafReader reader, String field);BinaryDocValues getBinary(LeafReader reader, String field);@throws;;;if an I/O error occurs.;true
org.apache.lucene.index.DocValues;NumericDocValues getNumeric(LeafReader reader, String field);SortedDocValues getSorted(LeafReader reader, String field);@return;;;docvalues instance, or an empty instance if field does not exist in this reader.;false
org.apache.lucene.index.DocValues;NumericDocValues getNumeric(LeafReader reader, String field);SortedDocValues getSorted(LeafReader reader, String field);@throws;;;if field exists, but was not indexed with docvalues.;true
org.apache.lucene.index.DocValues;NumericDocValues getNumeric(LeafReader reader, String field);SortedDocValues getSorted(LeafReader reader, String field);@throws;;;if an I/O error occurs.;true
org.apache.lucene.index.DocValues;NumericDocValues getNumeric(LeafReader reader, String field);SortedNumericDocValues getSortedNumeric(LeafReader reader, String field);@return;;;docvalues instance, or an empty instance if field does not exist in this reader.;false
org.apache.lucene.index.DocValues;NumericDocValues getNumeric(LeafReader reader, String field);SortedNumericDocValues getSortedNumeric(LeafReader reader, String field);@throws;;;if field exists, but was not indexed with docvalues.;true
org.apache.lucene.index.DocValues;NumericDocValues getNumeric(LeafReader reader, String field);SortedNumericDocValues getSortedNumeric(LeafReader reader, String field);@throws;;;if an I/O error occurs.;true
org.apache.lucene.index.DocValues;NumericDocValues getNumeric(LeafReader reader, String field);SortedSetDocValues getSortedSet(LeafReader reader, String field);@return;;;docvalues instance, or an empty instance if field does not exist in this reader.;false
org.apache.lucene.index.DocValues;NumericDocValues getNumeric(LeafReader reader, String field);SortedSetDocValues getSortedSet(LeafReader reader, String field);@throws;;;if field exists, but was not indexed with docvalues.;true
org.apache.lucene.index.DocValues;NumericDocValues getNumeric(LeafReader reader, String field);SortedSetDocValues getSortedSet(LeafReader reader, String field);@throws;;;if an I/O error occurs.;true
org.apache.lucene.index.DocValues;BinaryDocValues getBinary(LeafReader reader, String field);SortedDocValues getSorted(LeafReader reader, String field);@return;;;docvalues instance, or an empty instance if field does not exist in this reader.;false
org.apache.lucene.index.DocValues;BinaryDocValues getBinary(LeafReader reader, String field);SortedDocValues getSorted(LeafReader reader, String field);@throws;;;if field exists, but was not indexed with docvalues.;true
org.apache.lucene.index.DocValues;BinaryDocValues getBinary(LeafReader reader, String field);SortedDocValues getSorted(LeafReader reader, String field);@throws;;;if an I/O error occurs.;true
org.apache.lucene.index.DocValues;BinaryDocValues getBinary(LeafReader reader, String field);SortedNumericDocValues getSortedNumeric(LeafReader reader, String field);@return;;;docvalues instance, or an empty instance if field does not exist in this reader.;false
org.apache.lucene.index.DocValues;BinaryDocValues getBinary(LeafReader reader, String field);SortedNumericDocValues getSortedNumeric(LeafReader reader, String field);@throws;;;if field exists, but was not indexed with docvalues.;true
org.apache.lucene.index.DocValues;BinaryDocValues getBinary(LeafReader reader, String field);SortedNumericDocValues getSortedNumeric(LeafReader reader, String field);@throws;;;if an I/O error occurs.;true
org.apache.lucene.index.DocValues;BinaryDocValues getBinary(LeafReader reader, String field);SortedSetDocValues getSortedSet(LeafReader reader, String field);@return;;;docvalues instance, or an empty instance if field does not exist in this reader.;false
org.apache.lucene.index.DocValues;BinaryDocValues getBinary(LeafReader reader, String field);SortedSetDocValues getSortedSet(LeafReader reader, String field);@throws;;;if field exists, but was not indexed with docvalues.;true
org.apache.lucene.index.DocValues;BinaryDocValues getBinary(LeafReader reader, String field);SortedSetDocValues getSortedSet(LeafReader reader, String field);@throws;;;if an I/O error occurs.;true
org.apache.lucene.index.DocValues;SortedDocValues getSorted(LeafReader reader, String field);SortedNumericDocValues getSortedNumeric(LeafReader reader, String field);@return;;;docvalues instance, or an empty instance if field does not exist in this reader.;false
org.apache.lucene.index.DocValues;SortedDocValues getSorted(LeafReader reader, String field);SortedNumericDocValues getSortedNumeric(LeafReader reader, String field);@throws;;;if field exists, but was not indexed with docvalues.;true
org.apache.lucene.index.DocValues;SortedDocValues getSorted(LeafReader reader, String field);SortedNumericDocValues getSortedNumeric(LeafReader reader, String field);@throws;;;if an I/O error occurs.;true
org.apache.lucene.index.DocValues;SortedDocValues getSorted(LeafReader reader, String field);SortedSetDocValues getSortedSet(LeafReader reader, String field);@return;;;docvalues instance, or an empty instance if field does not exist in this reader.;false
org.apache.lucene.index.DocValues;SortedDocValues getSorted(LeafReader reader, String field);SortedSetDocValues getSortedSet(LeafReader reader, String field);@throws;;;if field exists, but was not indexed with docvalues.;true
org.apache.lucene.index.DocValues;SortedDocValues getSorted(LeafReader reader, String field);SortedSetDocValues getSortedSet(LeafReader reader, String field);@throws;;;if an I/O error occurs.;true
org.apache.lucene.index.DocValues;SortedNumericDocValues getSortedNumeric(LeafReader reader, String field);SortedSetDocValues getSortedSet(LeafReader reader, String field);@return;;;docvalues instance, or an empty instance if field does not exist in this reader.;false
org.apache.lucene.index.DocValues;SortedNumericDocValues getSortedNumeric(LeafReader reader, String field);SortedSetDocValues getSortedSet(LeafReader reader, String field);@throws;;;if field exists, but was not indexed with docvalues.;true
org.apache.lucene.index.DocValues;SortedNumericDocValues getSortedNumeric(LeafReader reader, String field);SortedSetDocValues getSortedSet(LeafReader reader, String field);@throws;;;if an I/O error occurs.;true
org.apache.lucene.index.FilteredTermsEnum; FilteredTermsEnum(TermsEnum tenum); FilteredTermsEnum(TermsEnum tenum, boolean startWithSeek);Whole;;;Creates a filtered {@link TermsEnum} on a terms enum.  @param the terms enumeration to filter.  ;false
org.apache.lucene.index.FilteredTermsEnum;boolean seekExact(BytesRef term);SeekStatus seekCeil(BytesRef term);Whole;;;   @throws In general, subclasses do not support seeking.;false
org.apache.lucene.index.FilteredTermsEnum;boolean seekExact(BytesRef term);void seekExact(long ord);Whole;;;   @throws In general, subclasses do not support seeking.;false
org.apache.lucene.index.FilteredTermsEnum;boolean seekExact(BytesRef term);void seekExact(BytesRef term, TermState state);Whole;;;   @throws In general, subclasses do not support seeking.;false
org.apache.lucene.index.FilteredTermsEnum;SeekStatus seekCeil(BytesRef term);void seekExact(long ord);Whole;;;   @throws In general, subclasses do not support seeking.;false
org.apache.lucene.index.FilteredTermsEnum;SeekStatus seekCeil(BytesRef term);void seekExact(BytesRef term, TermState state);Whole;;;   @throws In general, subclasses do not support seeking.;false
org.apache.lucene.index.FilteredTermsEnum;void seekExact(long ord);void seekExact(BytesRef term, TermState state);Whole;;;   @throws In general, subclasses do not support seeking.;false
org.apache.lucene.index.SegmentInfos;long getLastCommitGeneration(Directory directory);String getLastCommitSegmentsFileName(Directory directory);@param;Directory directory;Directory directory;-- directory to search for the latest segments_N file;true
org.apache.lucene.index.CheckIndex;Status.TermIndexStatus testPostings(CodecReader reader, PrintStream infoStream, Version version);Status.TermIndexStatus testPostings(CodecReader reader, PrintStream infoStream, boolean verbose, boolean failFast, Version version);Whole;;;Test the term index. @lucene.experimental    ;false
org.apache.lucene.index.CheckIndex;Status.TermVectorStatus testTermVectors(CodecReader reader, PrintStream infoStream, Version version);Status.TermVectorStatus testTermVectors(CodecReader reader, PrintStream infoStream, boolean verbose, boolean crossCheckTermVectors, boolean failFast, Version version);Whole;;;Test term vectors. @lucene.experimental    ;false
org.apache.lucene.index.IndexFormatTooNewException; IndexFormatTooNewException(String resourceDescription, int version, int minVersion, int maxVersion); IndexFormatTooNewException(DataInput in, int version, int minVersion, int maxVersion);@param;int version;int version;the version of the file that was too new;true
org.apache.lucene.index.IndexFormatTooNewException; IndexFormatTooNewException(String resourceDescription, int version, int minVersion, int maxVersion); IndexFormatTooNewException(DataInput in, int version, int minVersion, int maxVersion);@param;int minVersion;int minVersion;the minimum version accepted;true
org.apache.lucene.index.IndexFormatTooNewException; IndexFormatTooNewException(String resourceDescription, int version, int minVersion, int maxVersion); IndexFormatTooNewException(DataInput in, int version, int minVersion, int maxVersion);@param;int maxVersion;int maxVersion;the maximum version accepted;true
org.apache.lucene.index.PersistentSnapshotDeletionPolicy; PersistentSnapshotDeletionPolicy(IndexDeletionPolicy primary, Directory dir); PersistentSnapshotDeletionPolicy(IndexDeletionPolicy primary, Directory dir, OpenMode mode);@param;IndexDeletionPolicy primary;IndexDeletionPolicy primary;the IndexDeletionPolicy that is used on non-snapshotted commits. Snapshotted commits, by definition, are not deleted until explicitly released via release.;true
org.apache.lucene.index.PersistentSnapshotDeletionPolicy; PersistentSnapshotDeletionPolicy(IndexDeletionPolicy primary, Directory dir); PersistentSnapshotDeletionPolicy(IndexDeletionPolicy primary, Directory dir, OpenMode mode);@param;Directory dir;Directory dir;the Directory which will be used to persist the snapshots information.;true
org.apache.lucene.index.TermsEnum;PostingsEnum postings(PostingsEnum reuse);PostingsEnum postings(PostingsEnum reuse, int flags);@param;PostingsEnum reuse;PostingsEnum reuse;pass a prior PostingsEnum for possible reuse;true
org.apache.lucene.index.MergePolicy;MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos segmentInfos, IndexWriter writer);MergeSpecification findForcedMerges(SegmentInfos segmentInfos, int maxSegmentCount, Map segmentsToMerge, IndexWriter writer);@param;SegmentInfos segmentInfos;SegmentInfos segmentInfos;the total set of segments in the index;true
org.apache.lucene.index.MergePolicy;MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos segmentInfos, IndexWriter writer);MergeSpecification findForcedMerges(SegmentInfos segmentInfos, int maxSegmentCount, Map segmentsToMerge, IndexWriter writer);@param;IndexWriter writer;IndexWriter writer;the IndexWriter to find the merges on;true
org.apache.lucene.index.MergePolicy;MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos segmentInfos, IndexWriter writer);MergeSpecification findForcedDeletesMerges(SegmentInfos segmentInfos, IndexWriter writer);@param;SegmentInfos segmentInfos;SegmentInfos segmentInfos;the total set of segments in the index;true
org.apache.lucene.index.MergePolicy;MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos segmentInfos, IndexWriter writer);MergeSpecification findForcedDeletesMerges(SegmentInfos segmentInfos, IndexWriter writer);@param;IndexWriter writer;IndexWriter writer;the IndexWriter to find the merges on;true
org.apache.lucene.index.MergePolicy;MergeSpecification findForcedMerges(SegmentInfos segmentInfos, int maxSegmentCount, Map segmentsToMerge, IndexWriter writer);MergeSpecification findForcedDeletesMerges(SegmentInfos segmentInfos, IndexWriter writer);@param;SegmentInfos segmentInfos;SegmentInfos segmentInfos;the total set of segments in the index;true
org.apache.lucene.index.MergePolicy;MergeSpecification findForcedMerges(SegmentInfos segmentInfos, int maxSegmentCount, Map segmentsToMerge, IndexWriter writer);MergeSpecification findForcedDeletesMerges(SegmentInfos segmentInfos, IndexWriter writer);@param;IndexWriter writer;IndexWriter writer;the IndexWriter to find the merges on;true
org.apache.lucene.index.KeepOnlyLastCommitDeletionPolicy;void onInit(List commits);void onCommit(List commits);Whole;;;Deletes all commits except the most recent one.    ;false
org.apache.lucene.store.NIOFSDirectory; NIOFSDirectory(Path path, LockFactory lockFactory); NIOFSDirectory(Path path);Free text;;; The directory is created at the named location if it does not yet exist. ;true
org.apache.lucene.store.NIOFSDirectory; NIOFSDirectory(Path path, LockFactory lockFactory); NIOFSDirectory(Path path);@param;Path path;Path path;the path of the directory;true
org.apache.lucene.store.NIOFSDirectory; NIOFSDirectory(Path path, LockFactory lockFactory); NIOFSDirectory(Path path);@throws;;;if there is a low-level I/O error;true
org.apache.lucene.store.SimpleFSDirectory; SimpleFSDirectory(Path path, LockFactory lockFactory); SimpleFSDirectory(Path path);Free text;;; The directory is created at the named location if it does not yet exist. ;true
org.apache.lucene.store.SimpleFSDirectory; SimpleFSDirectory(Path path, LockFactory lockFactory); SimpleFSDirectory(Path path);@param;Path path;Path path;the path of the directory;true
org.apache.lucene.store.SimpleFSDirectory; SimpleFSDirectory(Path path, LockFactory lockFactory); SimpleFSDirectory(Path path);@throws;;;if there is a low-level I/O error;true
org.apache.lucene.store.SleepingLockWrapper; SleepingLockWrapper(Directory delegate, long lockWaitTimeout); SleepingLockWrapper(Directory delegate, long lockWaitTimeout, long pollInterval);Free text;;;Create a new SleepingLockFactory ;true
org.apache.lucene.store.SleepingLockWrapper; SleepingLockWrapper(Directory delegate, long lockWaitTimeout); SleepingLockWrapper(Directory delegate, long lockWaitTimeout, long pollInterval);@param;Directory delegate;Directory delegate;underlying directory to wrap;true
org.apache.lucene.store.SleepingLockWrapper; SleepingLockWrapper(Directory delegate, long lockWaitTimeout); SleepingLockWrapper(Directory delegate, long lockWaitTimeout, long pollInterval);@param;long lockWaitTimeout;long lockWaitTimeout;length of time to wait in milliseconds or LOCK_OBTAIN_WAIT_FOREVER to retry forever.;true
org.apache.lucene.store.DataOutput;void writeBytes(byte[] b, int length);void writeBytes(byte[] b, int offset, int length);@param;byte[] b;byte[] b;the bytes to write;true
org.apache.lucene.store.DataOutput;void writeBytes(byte[] b, int length);void writeBytes(byte[] b, int offset, int length);@param;int length;int length;the number of bytes to write;true
org.apache.lucene.store.MMapDirectory; MMapDirectory(Path path, LockFactory lockFactory); MMapDirectory(Path path);Free text;;; The directory is created at the named location if it does not yet exist. ;true
org.apache.lucene.store.MMapDirectory; MMapDirectory(Path path, LockFactory lockFactory); MMapDirectory(Path path);@param;Path path;Path path;the path of the directory;true
org.apache.lucene.store.MMapDirectory; MMapDirectory(Path path, LockFactory lockFactory); MMapDirectory(Path path);@throws;;;if there is a low-level I/O error;true
org.apache.lucene.store.MMapDirectory; MMapDirectory(Path path, LockFactory lockFactory); MMapDirectory(Path path, int maxChunkSize);Free text;;; The directory is created at the named location if it does not yet exist. ;true
org.apache.lucene.store.MMapDirectory; MMapDirectory(Path path, LockFactory lockFactory); MMapDirectory(Path path, int maxChunkSize);@param;Path path;Path path;the path of the directory;true
org.apache.lucene.store.MMapDirectory; MMapDirectory(Path path, LockFactory lockFactory); MMapDirectory(Path path, int maxChunkSize);@throws;;;if there is a low-level I/O error;true
org.apache.lucene.store.MMapDirectory; MMapDirectory(Path path, LockFactory lockFactory); MMapDirectory(Path path, LockFactory lockFactory, int maxChunkSize);@param;Path path;Path path;the path of the directory;true
org.apache.lucene.store.MMapDirectory; MMapDirectory(Path path, LockFactory lockFactory); MMapDirectory(Path path, LockFactory lockFactory, int maxChunkSize);@throws;;;if there is a low-level I/O error;true
org.apache.lucene.store.MMapDirectory; MMapDirectory(Path path); MMapDirectory(Path path, int maxChunkSize);Free text;;; The directory is created at the named location if it does not yet exist. ;true
org.apache.lucene.store.MMapDirectory; MMapDirectory(Path path); MMapDirectory(Path path, int maxChunkSize);@param;Path path;Path path;the path of the directory;true
org.apache.lucene.store.MMapDirectory; MMapDirectory(Path path); MMapDirectory(Path path, int maxChunkSize);@throws;;;if there is a low-level I/O error;true
org.apache.lucene.store.MMapDirectory; MMapDirectory(Path path); MMapDirectory(Path path, LockFactory lockFactory, int maxChunkSize);@param;Path path;Path path;the path of the directory;true
org.apache.lucene.store.MMapDirectory; MMapDirectory(Path path); MMapDirectory(Path path, LockFactory lockFactory, int maxChunkSize);@throws;;;if there is a low-level I/O error;true
org.apache.lucene.store.MMapDirectory; MMapDirectory(Path path, int maxChunkSize); MMapDirectory(Path path, LockFactory lockFactory, int maxChunkSize);@param;Path path;Path path;the path of the directory;true
org.apache.lucene.store.MMapDirectory; MMapDirectory(Path path, int maxChunkSize); MMapDirectory(Path path, LockFactory lockFactory, int maxChunkSize);@param;int maxChunkSize;int maxChunkSize;maximum chunk size (default is 1 GiBytes for 64 bit JVMs and 256 MiBytes for 32 bit JVMs) used for memory mapping.;true
org.apache.lucene.store.MMapDirectory; MMapDirectory(Path path, int maxChunkSize); MMapDirectory(Path path, LockFactory lockFactory, int maxChunkSize);@throws;;;if there is a low-level I/O error;true
org.apache.lucene.store.DataInput;byte readByte();short readShort();Whole;;;@see DataOutput#writeByte(byte)    ;false
org.apache.lucene.store.DataInput;void readBytes(byte[] b, int offset, int len);void readBytes(byte[] b, int offset, int len, boolean useBuffer);@param;byte[] b;byte[] b;the array to read bytes into;true
org.apache.lucene.store.DataInput;void readBytes(byte[] b, int offset, int len);void readBytes(byte[] b, int offset, int len, boolean useBuffer);@param;int offset;int offset;the offset in the array to start storing bytes;true
org.apache.lucene.store.DataInput;void readBytes(byte[] b, int offset, int len);void readBytes(byte[] b, int offset, int len, boolean useBuffer);@param;int len;int len;the number of bytes to read;true
