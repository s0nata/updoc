package mapper;

import parser.MethodNode;
import semantic.SemanticMatcher;

import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;

/**
 * This class implements a mapping between identifiers of AST nodes and doc comment sentences, based
 * on respective bag of words representations' similarity. Essentially, a mapping goes from an AST
 * Node to the IDs of the sentences considered relevant for it (i.e., similar to the AST node).
 */
public class MapBuilder {

    /**
     * The original method comment, composed of CommentSentences
     */
    private MethodComment methodComment;

    /**
     * The original method body, composed of ASTNodes
     */
    private MethodBody methodBody;

    /**
     * The similarity threshold above which we consider a relatedness
     */
    private final double similarityThreshold;

    private static final double SEMANTIC_THRESHOLD = -1;
    /**
     * The mapping between a node ID and related sentences (with similarities)
     */
    private Hashtable<Integer, List<RelatedSentence>> mapping;

    private static final String DEFAULT_SIM_FORMAT = "0.000";
    private String simFormat;


    /**
     * To build a mapping on only a single (method) node.
     *
     * @param mbn
     * @param bowSimilarity
     * @param semantic
     * @param format
     */
    public MapBuilder(MethodNode mbn, double bowSimilarity, boolean semantic, String format) {
        this.similarityThreshold = bowSimilarity;

        if (mbn.getComments().isPresent()) {
            this.methodComment = new MethodComment(mbn.getDocComment(), mbn.getComments().get());
        } else {
            this.methodComment = new MethodComment(mbn.getDocComment());
        }

        // The map builder creates a MethodBody starting from the MethodNode
        // generated by the parser
        this.methodBody = new MethodBody(mbn);

        // As soon as a MapBuilder is instantiated,
        // the mapping between code and comment is created and stored
        if (!semantic) {
            this.mapping = mapCommentToCode();
        } else {
            this.mapping = mapCommentToCodeSemantic();
        }

        if (format.isEmpty()) {
            this.simFormat = DEFAULT_SIM_FORMAT;
        } else {
            this.simFormat = format;
        }
    }

    /**
     * To build a mapping on multiple nodes, as would happen from a normal source file.
     *
     * @param nodes
     * @param bowSimilarity
     * @param semantic
     * @param format
     */
    public MapBuilder(List<MethodNode> nodes, double bowSimilarity, boolean semantic, String format) {
        this.similarityThreshold = bowSimilarity;

        for (MethodNode mbn : nodes) {
            if (mbn.getComments().isPresent()) {
                this.methodComment = new MethodComment(mbn.getDocComment(), mbn.getComments().get());
            } else {
                this.methodComment = new MethodComment(mbn.getDocComment());
            }

            // The map builder creates a MethodBody starting from the MethodNode
            // generated by the parser
            this.methodBody = new MethodBody(mbn);

            // As soon as a MapBuilder is instantiated,
            // the mapping between code and comment is created and stored
            if (!semantic) {
                this.mapping = mapCommentToCode();
            } else {
                this.mapping = mapCommentToCodeSemantic();
            }

            if (format.isEmpty()) {
                this.simFormat = DEFAULT_SIM_FORMAT;
            } else {
                this.simFormat = format;
            }
        }
    }

    /**
     * Creates a mapping between each AST node of a method body and all relevant sentences from the
     * doc comment. The map ties the AST Node ID (an Integer) to multiples sentences IDs (a list of
     * Integers).
     *
     * @return Returns the mapping
     */
    private Hashtable<Integer, List<RelatedSentence>> mapCommentToCode() {

        // The final code-doc mapping to be returned
        Hashtable<Integer, List<RelatedSentence>> mapping = new Hashtable<>();

        for (ASTNode methodNode : methodBody.getBodyNodes()) {
            WordBag methodBoW = methodNode.toBagOfWords();

            // Related sentences, with their ID and similarity
            List<RelatedSentence> relatedSentences = new ArrayList<>();

            for (CommentSentence sentence : methodComment.getCommentSentences()) {
                WordBag sentenceBoW = sentence.toBagOfWords();

                // FIXME this computation is repeated in toString() method.
                // FIXME Save instead this computation result.
                // FIXME currently this method only saves the related sentence ID
                double cosineSim = methodBoW.cosineSim(sentenceBoW);
                if (cosineSim > this.similarityThreshold) {
                    relatedSentences.add(new RelatedSentence(sentence.getId(), sentence.toString(), cosineSim, methodNode));
                }
            }
            mapping.put(methodNode.getNodeId(), relatedSentences);
        }

        return mapping;
    }

    /**
     * Creates a mapping between each AST node of a method body and all relevant sentences from the
     * doc comment. The map ties the AST Node ID (an Integer) to multiples sentences IDs (a list of
     * Integers).
     *
     * @return Returns the mapping
     */
    private Hashtable<Integer, List<RelatedSentence>> mapCommentToCodeSemantic() {

        // The final code-doc mapping to be returned
        Hashtable<Integer, List<RelatedSentence>> mapping = new Hashtable<>();

        for (ASTNode methodNode : methodBody.getBodyNodes()) {
            WordBag methodBoW = methodNode.toBagOfWords();

            // Related sentences, with their ID and similarity
            List<RelatedSentence> relatedSentences = new ArrayList<>();

            for (CommentSentence sentence : methodComment.getCommentSentences()) {
                WordBag sentenceBoW = sentence.toBagOfWords();

                double wordMovDistance = SemanticMatcher.wmdMatch(sentenceBoW, methodBoW);
                double normalizedWMD = wordMovDistance / 10;
                double semanticSim = 1 - normalizedWMD;
                if (semanticSim > SEMANTIC_THRESHOLD) {
                    relatedSentences.add(new RelatedSentence(sentence.getId(), sentence.toString(), semanticSim, methodNode));
                }
            }
            mapping.put(methodNode.getNodeId(), relatedSentences);
        }

        return mapping;
    }

    public Hashtable<Integer, List<RelatedSentence>> getMapping() {
        return this.mapping;
    }

    //  public Hashtable<Integer, Double> getIDsAndSimilarities(){
    //
    //  }

    public MethodComment getMethodComment() {
        return methodComment;
    }

    public ASTNode getASTNodeByID(int id) {
        return this.methodBody.getBodyNodes().get(id);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }

        if (!(obj instanceof MapBuilder)) {
            return false;
        }

        MapBuilder other = (MapBuilder) obj;

        boolean sameElements = false;

        for (Integer key : this.mapping.keySet()) {
            sameElements = this.mapping.get(key).equals(other.mapping.get(key));
        }

        return sameElements;
    }

    @Override
    public String toString() {

        String prettyMapping = "";

        prettyMapping = "MapBuilder \n" +
                "\n> methodComment\n" + methodComment.toString() +
                "\n> methodBody\n" + methodBody.toString() +
                "\n> similarityThreshold\n" + similarityThreshold +
                "\n> mapping\n";

        for (Integer key : mapping.keySet()) {
            prettyMapping += "\tfor node [" + key + "]\n";
            for (RelatedSentence relsent : mapping.get(key)) {
                prettyMapping += "\t" + relsent.toString() + "\n";
            }
        }

        return prettyMapping;
    }

}
